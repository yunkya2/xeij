//========================================================================================
//  MC68060.java
//    en:MC68060 core
//    ja:MC68060コア
//  Copyright (C) 2003-2025 Makoto Kamada
//
//  This file is part of the XEiJ (X68000 Emulator in Java).
//  You can use, modify and redistribute the XEiJ if the conditions are met.
//  Read the XEiJ License for more details.
//  https://stdkmd.net/xeij/
//========================================================================================

package xeij;

import java.lang.*;  //Boolean,Character,Class,Comparable,Double,Exception,Float,IllegalArgumentException,Integer,Long,Math,Number,Object,Runnable,SecurityException,String,StringBuilder,System
import java.util.*;  //ArrayList,Arrays,Calendar,GregorianCalendar,HashMap,Map,Map.Entry,Timer,TimerTask,TreeMap

public class MC68060 {

  public static void mpuCore () {

    //例外ループ
    //  別のメソッドで検出された例外を命令ループの外側でcatchすることで命令ループを高速化する
  errorLoop:
    while (XEiJ.mpuClockTime < XEiJ.mpuClockLimit) {
      try {
        //命令ループ
        while (XEiJ.mpuClockTime < XEiJ.mpuClockLimit) {
          int t;
          //命令を実行する
          M68kException.m6eIncremented = 0L;  //アドレスレジスタの増分
          XEiJ.mpuTraceFlag = XEiJ.regSRT1;  //命令実行前のsrT1
          XEiJ.mpuCycleCount = 0;  //第1オペコードからROMのアクセスウエイトを有効にする。命令のサイクル数はすべてXEiJ.mpuCycleCount+=～で加えること
          XEiJ.regPC0 = t = XEiJ.regPC;  //命令の先頭アドレス
          XEiJ.regPC = t + 2;
          //XEiJ.regOC = mmuReadWordZeroOpword (t, XEiJ.regSRS);  //第1オペコード。必ずゼロ拡張すること。pcに奇数が入っていることはないのでアドレスエラーのチェックを省略する
          if (XEiJ.regSRS != 0) {  //スーパーバイザモード
            M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_OPWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_CODE;
            t = mmuTranslateReadSuperCode (t);
            XEiJ.regOC = (InstructionBreakPoint.IBP_ON ? InstructionBreakPoint.ibpOp1SuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdRwz (t);
          } else {  //ユーザモード
            M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_OPWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_CODE;
            t = mmuTranslateReadUserCode (t);
            XEiJ.regOC = (InstructionBreakPoint.IBP_ON ? InstructionBreakPoint.ibpOp1UserMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdRwz (t);
          }

          //命令の処理
          //  第1オペコードの上位10ビットで分岐する
        irpSwitch:
          switch (XEiJ.regOC >>> 6) {  //第1オペコードの上位10ビット。XEiJ.regOCはゼロ拡張されているので0b1111_111_111&を省略

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ORI.B #<data>,<ea>                              |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_000_000_mmm_rrr-{data}
            //OR.B #<data>,<ea>                               |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_000_000_mmm_rrr-{data}  [ORI.B #<data>,<ea>]
            //ORI.B #<data>,CCR                               |-|012346|-|*****|*****|          |0000_000_000_111_100-{data}
          case 0b0000_000_000:
            irpOriByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ORI.W #<data>,<ea>                              |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_000_001_mmm_rrr-{data}
            //OR.W #<data>,<ea>                               |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_000_001_mmm_rrr-{data}  [ORI.W #<data>,<ea>]
            //ORI.W #<data>,SR                                |-|012346|P|*****|*****|          |0000_000_001_111_100-{data}
          case 0b0000_000_001:
            irpOriWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ORI.L #<data>,<ea>                              |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_000_010_mmm_rrr-{data}
            //OR.L #<data>,<ea>                               |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_000_010_mmm_rrr-{data}  [ORI.L #<data>,<ea>]
          case 0b0000_000_010:
            irpOriLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BITREV.L Dr                                     |-|------|-|-----|-----|D         |0000_000_011_000_rrr (ISA_C)
            //CMP2.B <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_000_011_mmm_rrr-rnnn000000000000
            //CHK2.B <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_000_011_mmm_rrr-rnnn100000000000
          case 0b0000_000_011:
            irpCmp2Chk2Byte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BTST.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_100_000_rrr
            //MOVEP.W (d16,Ar),Dq                             |-|01234S|-|-----|-----|          |0000_qqq_100_001_rrr-{data}
            //BTST.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZPI|0000_qqq_100_mmm_rrr
          case 0b0000_000_100:
          case 0b0000_001_100:
          case 0b0000_010_100:
          case 0b0000_011_100:
          case 0b0000_100_100:
          case 0b0000_101_100:
          case 0b0000_110_100:
          case 0b0000_111_100:
            irpBtstReg ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCHG.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_101_000_rrr
            //MOVEP.L (d16,Ar),Dq                             |-|01234S|-|-----|-----|          |0000_qqq_101_001_rrr-{data}
            //BCHG.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZ  |0000_qqq_101_mmm_rrr
          case 0b0000_000_101:
          case 0b0000_001_101:
          case 0b0000_010_101:
          case 0b0000_011_101:
          case 0b0000_100_101:
          case 0b0000_101_101:
          case 0b0000_110_101:
          case 0b0000_111_101:
            irpBchgReg ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCLR.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_110_000_rrr
            //MOVEP.W Dq,(d16,Ar)                             |-|01234S|-|-----|-----|          |0000_qqq_110_001_rrr-{data}
            //BCLR.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZ  |0000_qqq_110_mmm_rrr
          case 0b0000_000_110:
          case 0b0000_001_110:
          case 0b0000_010_110:
          case 0b0000_011_110:
          case 0b0000_100_110:
          case 0b0000_101_110:
          case 0b0000_110_110:
          case 0b0000_111_110:
            irpBclrReg ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BSET.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_111_000_rrr
            //MOVEP.L Dq,(d16,Ar)                             |-|01234S|-|-----|-----|          |0000_qqq_111_001_rrr-{data}
            //BSET.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZ  |0000_qqq_111_mmm_rrr
          case 0b0000_000_111:
          case 0b0000_001_111:
          case 0b0000_010_111:
          case 0b0000_011_111:
          case 0b0000_100_111:
          case 0b0000_101_111:
          case 0b0000_110_111:
          case 0b0000_111_111:
            irpBsetReg ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ANDI.B #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_001_000_mmm_rrr-{data}
            //AND.B #<data>,<ea>                              |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_001_000_mmm_rrr-{data}  [ANDI.B #<data>,<ea>]
            //ANDI.B #<data>,CCR                              |-|012346|-|*****|*****|          |0000_001_000_111_100-{data}
          case 0b0000_001_000:
            irpAndiByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ANDI.W #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_001_001_mmm_rrr-{data}
            //AND.W #<data>,<ea>                              |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_001_001_mmm_rrr-{data}  [ANDI.W #<data>,<ea>]
            //ANDI.W #<data>,SR                               |-|012346|P|*****|*****|          |0000_001_001_111_100-{data}
          case 0b0000_001_001:
            irpAndiWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ANDI.L #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_001_010_mmm_rrr-{data}
            //AND.L #<data>,<ea>                              |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_001_010_mmm_rrr-{data}  [ANDI.L #<data>,<ea>]
          case 0b0000_001_010:
            irpAndiLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BYTEREV.L Dr                                    |-|------|-|-----|-----|D         |0000_001_011_000_rrr (ISA_C)
            //CMP2.W <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_001_011_mmm_rrr-rnnn000000000000
            //CHK2.W <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_001_011_mmm_rrr-rnnn100000000000
          case 0b0000_001_011:
            irpCmp2Chk2Word ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBI.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_010_000_mmm_rrr-{data}
            //SUB.B #<data>,<ea>                              |A|012346|-|UUUUU|*****|  M+-WXZ  |0000_010_000_mmm_rrr-{data}  [SUBI.B #<data>,<ea>]
          case 0b0000_010_000:
            irpSubiByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBI.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_010_001_mmm_rrr-{data}
            //SUB.W #<data>,<ea>                              |A|012346|-|UUUUU|*****|  M+-WXZ  |0000_010_001_mmm_rrr-{data}  [SUBI.W #<data>,<ea>]
          case 0b0000_010_001:
            irpSubiWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBI.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_010_010_mmm_rrr-{data}
            //SUB.L #<data>,<ea>                              |A|012346|-|UUUUU|*****|  M+-WXZ  |0000_010_010_mmm_rrr-{data}  [SUBI.L #<data>,<ea>]
          case 0b0000_010_010:
            irpSubiLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FF1.L Dr                                        |-|------|-|-UUUU|-**00|D         |0000_010_011_000_rrr (ISA_C)
            //CMP2.L <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_010_011_mmm_rrr-rnnn000000000000
            //CHK2.L <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_010_011_mmm_rrr-rnnn100000000000
          case 0b0000_010_011:
            irpCmp2Chk2Long ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDI.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_011_000_mmm_rrr-{data}
          case 0b0000_011_000:
            irpAddiByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDI.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_011_001_mmm_rrr-{data}
          case 0b0000_011_001:
            irpAddiWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDI.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_011_010_mmm_rrr-{data}
          case 0b0000_011_010:
            irpAddiLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BTST.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_000_000_rrr-{data}
            //BTST.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZP |0000_100_000_mmm_rrr-{data}
          case 0b0000_100_000:
            irpBtstImm ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCHG.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_001_000_rrr-{data}
            //BCHG.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZ  |0000_100_001_mmm_rrr-{data}
          case 0b0000_100_001:
            irpBchgImm ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCLR.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_010_000_rrr-{data}
            //BCLR.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZ  |0000_100_010_mmm_rrr-{data}
          case 0b0000_100_010:
            irpBclrImm ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BSET.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_011_000_rrr-{data}
            //BSET.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZ  |0000_100_011_mmm_rrr-{data}
          case 0b0000_100_011:
            irpBsetImm ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EORI.B #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_000_mmm_rrr-{data}
            //EOR.B #<data>,<ea>                              |A|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_000_mmm_rrr-{data}  [EORI.B #<data>,<ea>]
            //EORI.B #<data>,CCR                              |-|012346|-|*****|*****|          |0000_101_000_111_100-{data}
          case 0b0000_101_000:
            irpEoriByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EORI.W #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_001_mmm_rrr-{data}
            //EOR.W #<data>,<ea>                              |A|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_001_mmm_rrr-{data}  [EORI.W #<data>,<ea>]
            //EORI.W #<data>,SR                               |-|012346|P|*****|*****|          |0000_101_001_111_100-{data}
          case 0b0000_101_001:
            irpEoriWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EORI.L #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_010_mmm_rrr-{data}
            //EOR.L #<data>,<ea>                              |A|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_010_mmm_rrr-{data}  [EORI.L #<data>,<ea>]
          case 0b0000_101_010:
            irpEoriLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CAS.B Dc,Du,<ea>                                |-|--2346|-|-UUUU|-****|  M+-WXZ  |0000_101_011_mmm_rrr-0000000uuu000ccc
          case 0b0000_101_011:
            irpCasByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMPI.B #<data>,<ea>                             |-|--2346|-|-UUUU|-****|D M+-WXZP |0000_110_000_mmm_rrr-{data}
            //CMP.B #<data>,<ea>                              |A|--2346|-|-UUUU|-****|  M+-WXZP |0000_110_000_mmm_rrr-{data}  [CMPI.B #<data>,<ea>]
          case 0b0000_110_000:
            irpCmpiByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMPI.W #<data>,<ea>                             |-|--2346|-|-UUUU|-****|D M+-WXZP |0000_110_001_mmm_rrr-{data}
            //CMP.W #<data>,<ea>                              |A|--2346|-|-UUUU|-****|  M+-WXZP |0000_110_001_mmm_rrr-{data}  [CMPI.W #<data>,<ea>]
          case 0b0000_110_001:
            irpCmpiWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMPI.L #<data>,<ea>                             |-|--2346|-|-UUUU|-****|D M+-WXZP |0000_110_010_mmm_rrr-{data}
            //CMP.L #<data>,<ea>                              |A|--2346|-|-UUUU|-****|  M+-WXZP |0000_110_010_mmm_rrr-{data}  [CMPI.L #<data>,<ea>]
          case 0b0000_110_010:
            irpCmpiLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CAS.W Dc,Du,<ea>                                |-|--2346|-|-UUUU|-****|  M+-WXZ  |0000_110_011_mmm_rrr-0000000uuu000ccc        (68060 software emulate misaligned <ea>)
            //CAS2.W Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)              |-|--234S|-|-UUUU|-****|          |0000_110_011_111_100-rnnn000uuu000ccc(1)-rnnn_000_uuu_000_ccc(2)
          case 0b0000_110_011:
            irpCasWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVES.B <ea>,Rn                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_000_mmm_rrr-rnnn000000000000
            //MOVES.B Rn,<ea>                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_000_mmm_rrr-rnnn100000000000
          case 0b0000_111_000:
            irpMovesByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVES.W <ea>,Rn                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_001_mmm_rrr-rnnn000000000000
            //MOVES.W Rn,<ea>                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_001_mmm_rrr-rnnn100000000000
          case 0b0000_111_001:
            irpMovesWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVES.L <ea>,Rn                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_010_mmm_rrr-rnnn000000000000
            //MOVES.L Rn,<ea>                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_010_mmm_rrr-rnnn100000000000
          case 0b0000_111_010:
            irpMovesLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CAS.L Dc,Du,<ea>                                |-|--2346|-|-UUUU|-****|  M+-WXZ  |0000_111_011_mmm_rrr-0000000uuu000ccc        (68060 software emulate misaligned <ea>)
            //CAS2.L Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)              |-|--234S|-|-UUUU|-****|          |0000_111_011_111_100-rnnn000uuu000ccc(1)-rnnn_000_uuu_000_ccc(2)
          case 0b0000_111_011:
            irpCasLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,Dq                                  |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_000_mmm_rrr
          case 0b0001_000_000:
          case 0b0001_001_000:
          case 0b0001_010_000:
          case 0b0001_011_000:
          case 0b0001_100_000:
          case 0b0001_101_000:
          case 0b0001_110_000:
          case 0b0001_111_000:
            irpMoveToDRByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,(Aq)                                |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_010_mmm_rrr
          case 0b0001_000_010:
          case 0b0001_001_010:
          case 0b0001_010_010:
          case 0b0001_011_010:
          case 0b0001_100_010:
          case 0b0001_101_010:
          case 0b0001_110_010:
          case 0b0001_111_010:
            irpMoveToMMByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,(Aq)+                               |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_011_mmm_rrr
          case 0b0001_000_011:
          case 0b0001_001_011:
          case 0b0001_010_011:
          case 0b0001_011_011:
          case 0b0001_100_011:
          case 0b0001_101_011:
          case 0b0001_110_011:
          case 0b0001_111_011:
            irpMoveToMPByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,-(Aq)                               |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_100_mmm_rrr
          case 0b0001_000_100:
          case 0b0001_001_100:
          case 0b0001_010_100:
          case 0b0001_011_100:
          case 0b0001_100_100:
          case 0b0001_101_100:
          case 0b0001_110_100:
          case 0b0001_111_100:
            irpMoveToMNByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,(d16,Aq)                            |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_101_mmm_rrr
          case 0b0001_000_101:
          case 0b0001_001_101:
          case 0b0001_010_101:
          case 0b0001_011_101:
          case 0b0001_100_101:
          case 0b0001_101_101:
          case 0b0001_110_101:
          case 0b0001_111_101:
            irpMoveToMWByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,(d8,Aq,Rn.wl)                       |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_110_mmm_rrr
          case 0b0001_000_110:
          case 0b0001_001_110:
          case 0b0001_010_110:
          case 0b0001_011_110:
          case 0b0001_100_110:
          case 0b0001_101_110:
          case 0b0001_110_110:
          case 0b0001_111_110:
            irpMoveToMXByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,(xxx).W                             |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_000_111_mmm_rrr
          case 0b0001_000_111:
            irpMoveToZWByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.B <ea>,(xxx).L                             |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_001_111_mmm_rrr
          case 0b0001_001_111:
            irpMoveToZLByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,Dq                                  |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_000_mmm_rrr
          case 0b0010_000_000:
          case 0b0010_001_000:
          case 0b0010_010_000:
          case 0b0010_011_000:
          case 0b0010_100_000:
          case 0b0010_101_000:
          case 0b0010_110_000:
          case 0b0010_111_000:
            irpMoveToDRLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVEA.L <ea>,Aq                                 |-|012346|-|-----|-----|DAM+-WXZPI|0010_qqq_001_mmm_rrr
            //MOVE.L <ea>,Aq                                  |A|012346|-|-----|-----|DAM+-WXZPI|0010_qqq_001_mmm_rrr [MOVEA.L <ea>,Aq]
          case 0b0010_000_001:
          case 0b0010_001_001:
          case 0b0010_010_001:
          case 0b0010_011_001:
          case 0b0010_100_001:
          case 0b0010_101_001:
          case 0b0010_110_001:
          case 0b0010_111_001:
            irpMoveaLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,(Aq)                                |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_010_mmm_rrr
          case 0b0010_000_010:
          case 0b0010_001_010:
          case 0b0010_010_010:
          case 0b0010_011_010:
          case 0b0010_100_010:
          case 0b0010_101_010:
          case 0b0010_110_010:
          case 0b0010_111_010:
            irpMoveToMMLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,(Aq)+                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_011_mmm_rrr
          case 0b0010_000_011:
          case 0b0010_001_011:
          case 0b0010_010_011:
          case 0b0010_011_011:
          case 0b0010_100_011:
          case 0b0010_101_011:
          case 0b0010_110_011:
          case 0b0010_111_011:
            irpMoveToMPLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,-(Aq)                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_100_mmm_rrr
          case 0b0010_000_100:
          case 0b0010_001_100:
          case 0b0010_010_100:
          case 0b0010_011_100:
          case 0b0010_100_100:
          case 0b0010_101_100:
          case 0b0010_110_100:
          case 0b0010_111_100:
            irpMoveToMNLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,(d16,Aq)                            |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_101_mmm_rrr
          case 0b0010_000_101:
          case 0b0010_001_101:
          case 0b0010_010_101:
          case 0b0010_011_101:
          case 0b0010_100_101:
          case 0b0010_101_101:
          case 0b0010_110_101:
          case 0b0010_111_101:
            irpMoveToMWLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,(d8,Aq,Rn.wl)                       |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_110_mmm_rrr
          case 0b0010_000_110:
          case 0b0010_001_110:
          case 0b0010_010_110:
          case 0b0010_011_110:
          case 0b0010_100_110:
          case 0b0010_101_110:
          case 0b0010_110_110:
          case 0b0010_111_110:
            irpMoveToMXLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,(xxx).W                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_000_111_mmm_rrr
          case 0b0010_000_111:
            irpMoveToZWLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.L <ea>,(xxx).L                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_001_111_mmm_rrr
          case 0b0010_001_111:
            irpMoveToZLLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,Dq                                  |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_000_mmm_rrr
          case 0b0011_000_000:
          case 0b0011_001_000:
          case 0b0011_010_000:
          case 0b0011_011_000:
          case 0b0011_100_000:
          case 0b0011_101_000:
          case 0b0011_110_000:
          case 0b0011_111_000:
            irpMoveToDRWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVEA.W <ea>,Aq                                 |-|012346|-|-----|-----|DAM+-WXZPI|0011_qqq_001_mmm_rrr
            //MOVE.W <ea>,Aq                                  |A|012346|-|-----|-----|DAM+-WXZPI|0011_qqq_001_mmm_rrr [MOVEA.W <ea>,Aq]
          case 0b0011_000_001:
          case 0b0011_001_001:
          case 0b0011_010_001:
          case 0b0011_011_001:
          case 0b0011_100_001:
          case 0b0011_101_001:
          case 0b0011_110_001:
          case 0b0011_111_001:
            irpMoveaWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,(Aq)                                |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_010_mmm_rrr
          case 0b0011_000_010:
          case 0b0011_001_010:
          case 0b0011_010_010:
          case 0b0011_011_010:
          case 0b0011_100_010:
          case 0b0011_101_010:
          case 0b0011_110_010:
          case 0b0011_111_010:
            irpMoveToMMWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,(Aq)+                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_011_mmm_rrr
          case 0b0011_000_011:
          case 0b0011_001_011:
          case 0b0011_010_011:
          case 0b0011_011_011:
          case 0b0011_100_011:
          case 0b0011_101_011:
          case 0b0011_110_011:
          case 0b0011_111_011:
            irpMoveToMPWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,-(Aq)                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_100_mmm_rrr
          case 0b0011_000_100:
          case 0b0011_001_100:
          case 0b0011_010_100:
          case 0b0011_011_100:
          case 0b0011_100_100:
          case 0b0011_101_100:
          case 0b0011_110_100:
          case 0b0011_111_100:
            irpMoveToMNWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,(d16,Aq)                            |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_101_mmm_rrr
          case 0b0011_000_101:
          case 0b0011_001_101:
          case 0b0011_010_101:
          case 0b0011_011_101:
          case 0b0011_100_101:
          case 0b0011_101_101:
          case 0b0011_110_101:
          case 0b0011_111_101:
            irpMoveToMWWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,(d8,Aq,Rn.wl)                       |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_110_mmm_rrr
          case 0b0011_000_110:
          case 0b0011_001_110:
          case 0b0011_010_110:
          case 0b0011_011_110:
          case 0b0011_100_110:
          case 0b0011_101_110:
          case 0b0011_110_110:
          case 0b0011_111_110:
            irpMoveToMXWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,(xxx).W                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_000_111_mmm_rrr
          case 0b0011_000_111:
            irpMoveToZWWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,(xxx).L                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_001_111_mmm_rrr
          case 0b0011_001_111:
            irpMoveToZLWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NEGX.B <ea>                                     |-|012346|-|*UUUU|*****|D M+-WXZ  |0100_000_000_mmm_rrr
          case 0b0100_000_000:
            irpNegxByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NEGX.W <ea>                                     |-|012346|-|*UUUU|*****|D M+-WXZ  |0100_000_001_mmm_rrr
          case 0b0100_000_001:
            irpNegxWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NEGX.L <ea>                                     |-|012346|-|*UUUU|*****|D M+-WXZ  |0100_000_010_mmm_rrr
          case 0b0100_000_010:
            irpNegxLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W SR,<ea>                                  |-|-12346|P|*****|-----|D M+-WXZ  |0100_000_011_mmm_rrr
          case 0b0100_000_011:
            irpMoveFromSR ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CHK.L <ea>,Dq                                   |-|--2346|-|-UUUU|-*UUU|D M+-WXZPI|0100_qqq_100_mmm_rrr
          case 0b0100_000_100:
          case 0b0100_001_100:
          case 0b0100_010_100:
          case 0b0100_011_100:
          case 0b0100_100_100:
          case 0b0100_101_100:
          case 0b0100_110_100:
          case 0b0100_111_100:
            irpChkLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CHK.W <ea>,Dq                                   |-|012346|-|-UUUU|-*UUU|D M+-WXZPI|0100_qqq_110_mmm_rrr
          case 0b0100_000_110:
          case 0b0100_001_110:
          case 0b0100_010_110:
          case 0b0100_011_110:
          case 0b0100_100_110:
          case 0b0100_101_110:
          case 0b0100_110_110:
          case 0b0100_111_110:
            irpChkWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //LEA.L <ea>,Aq                                   |-|012346|-|-----|-----|  M  WXZP |0100_qqq_111_mmm_rrr
            //EXTB.L Dr                                       |-|--2346|-|-UUUU|-**00|D         |0100_100_111_000_rrr
          case 0b0100_000_111:
          case 0b0100_001_111:
          case 0b0100_010_111:
          case 0b0100_011_111:
          case 0b0100_100_111:
          case 0b0100_101_111:
          case 0b0100_110_111:
          case 0b0100_111_111:
            irpLea ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CLR.B <ea>                                      |-|012346|-|-UUUU|-0100|D M+-WXZ  |0100_001_000_mmm_rrr (68000 and 68008 read before clear)
          case 0b0100_001_000:
            irpClrByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CLR.W <ea>                                      |-|012346|-|-UUUU|-0100|D M+-WXZ  |0100_001_001_mmm_rrr (68000 and 68008 read before clear)
          case 0b0100_001_001:
            irpClrWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CLR.L <ea>                                      |-|012346|-|-UUUU|-0100|D M+-WXZ  |0100_001_010_mmm_rrr (68000 and 68008 read before clear)
          case 0b0100_001_010:
            irpClrLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W CCR,<ea>                                 |-|-12346|-|*****|-----|D M+-WXZ  |0100_001_011_mmm_rrr
          case 0b0100_001_011:
            irpMoveFromCCR ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NEG.B <ea>                                      |-|012346|-|UUUUU|*****|D M+-WXZ  |0100_010_000_mmm_rrr
          case 0b0100_010_000:
            irpNegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NEG.W <ea>                                      |-|012346|-|UUUUU|*****|D M+-WXZ  |0100_010_001_mmm_rrr
          case 0b0100_010_001:
            irpNegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NEG.L <ea>                                      |-|012346|-|UUUUU|*****|D M+-WXZ  |0100_010_010_mmm_rrr
          case 0b0100_010_010:
            irpNegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,CCR                                 |-|012346|-|UUUUU|*****|D M+-WXZPI|0100_010_011_mmm_rrr
          case 0b0100_010_011:
            irpMoveToCCR ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NOT.B <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_011_000_mmm_rrr
          case 0b0100_011_000:
            irpNotByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NOT.W <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_011_001_mmm_rrr
          case 0b0100_011_001:
            irpNotWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NOT.L <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_011_010_mmm_rrr
          case 0b0100_011_010:
            irpNotLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE.W <ea>,SR                                  |-|012346|P|UUUUU|*****|D M+-WXZPI|0100_011_011_mmm_rrr
          case 0b0100_011_011:
            irpMoveToSR ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //NBCD.B <ea>                                     |-|012346|-|UUUUU|*U*U*|D M+-WXZ  |0100_100_000_mmm_rrr
            //LINK.L Ar,#<data>                               |-|--2346|-|-----|-----|          |0100_100_000_001_rrr-{data}
          case 0b0100_100_000:
            irpNbcd ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SWAP.W Dr                                       |-|012346|-|-UUUU|-**00|D         |0100_100_001_000_rrr
            //BKPT #<data>                                    |-|-12346|-|-----|-----|          |0100_100_001_001_ddd
            //PEA.L <ea>                                      |-|012346|-|-----|-----|  M  WXZP |0100_100_001_mmm_rrr
          case 0b0100_100_001:
            irpPea ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EXT.W Dr                                        |-|012346|-|-UUUU|-**00|D         |0100_100_010_000_rrr
            //MOVEM.W <list>,<ea>                             |-|012346|-|-----|-----|  M -WXZ  |0100_100_010_mmm_rrr-llllllllllllllll
          case 0b0100_100_010:
            irpMovemToMemWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EXT.L Dr                                        |-|012346|-|-UUUU|-**00|D         |0100_100_011_000_rrr
            //MOVEM.L <list>,<ea>                             |-|012346|-|-----|-----|  M -WXZ  |0100_100_011_mmm_rrr-llllllllllllllll
          case 0b0100_100_011:
            irpMovemToMemLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //TST.B <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_000_mmm_rrr
            //TST.B <ea>                                      |-|--2346|-|-UUUU|-**00|        PI|0100_101_000_mmm_rrr
          case 0b0100_101_000:
            irpTstByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //TST.W <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_001_mmm_rrr
            //TST.W <ea>                                      |-|--2346|-|-UUUU|-**00| A      PI|0100_101_001_mmm_rrr
          case 0b0100_101_001:
            irpTstWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //TST.L <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_010_mmm_rrr
            //TST.L <ea>                                      |-|--2346|-|-UUUU|-**00| A      PI|0100_101_010_mmm_rrr
          case 0b0100_101_010:
            irpTstLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //TAS.B <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_011_mmm_rrr
            //ILLEGAL                                         |-|012346|-|-----|-----|          |0100_101_011_111_100
          case 0b0100_101_011:
            irpTas ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MULU.L <ea>,Dl                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll000000000hhh        (h is not used)
            //MULU.L <ea>,Dh:Dl                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll010000000hhh        (if h=l then result is not defined)
            //MULS.L <ea>,Dl                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll100000000hhh        (h is not used)
            //MULS.L <ea>,Dh:Dl                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll110000000hhh        (if h=l then result is not defined)
          case 0b0100_110_000:
            irpMuluMulsLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //DIVU.L <ea>,Dq                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq000000000qqq
            //DIVUL.L <ea>,Dr:Dq                              |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq000000000rrr        (q is not equal to r)
            //DIVU.L <ea>,Dr:Dq                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq010000000rrr        (q is not equal to r)
            //DIVS.L <ea>,Dq                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq100000000qqq
            //DIVSL.L <ea>,Dr:Dq                              |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq100000000rrr        (q is not equal to r)
            //DIVS.L <ea>,Dr:Dq                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq110000000rrr        (q is not equal to r)
          case 0b0100_110_001:
            irpDivuDivsLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SATS.L Dr                                       |-|------|-|-UUUU|-**00|D         |0100_110_010_000_rrr (ISA_B)
            //MOVEM.W <ea>,<list>                             |-|012346|-|-----|-----|  M+ WXZP |0100_110_010_mmm_rrr-llllllllllllllll
          case 0b0100_110_010:
            irpMovemToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVEM.L <ea>,<list>                             |-|012346|-|-----|-----|  M+ WXZP |0100_110_011_mmm_rrr-llllllllllllllll
          case 0b0100_110_011:
            irpMovemToRegLong ();
            break irpSwitch;

          case 0b0100_111_001:
            switch (XEiJ.regOC & 0b111_111) {

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //TRAP #<vector>                                  |-|012346|-|-----|-----|          |0100_111_001_00v_vvv
            case 0b000_000:
            case 0b000_001:
            case 0b000_010:
            case 0b000_011:
            case 0b000_100:
            case 0b000_101:
            case 0b000_110:
            case 0b000_111:
            case 0b001_000:
            case 0b001_001:
            case 0b001_010:
            case 0b001_011:
            case 0b001_100:
            case 0b001_101:
            case 0b001_110:
              irpTrap ();
              break irpSwitch;
            case 0b001_111:
              irpTrap15 ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //LINK.W Ar,#<data>                               |-|012346|-|-----|-----|          |0100_111_001_010_rrr-{data}
            case 0b010_000:
            case 0b010_001:
            case 0b010_010:
            case 0b010_011:
            case 0b010_100:
            case 0b010_101:
            case 0b010_110:
            case 0b010_111:
              irpLinkWord ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //UNLK Ar                                         |-|012346|-|-----|-----|          |0100_111_001_011_rrr
            case 0b011_000:
            case 0b011_001:
            case 0b011_010:
            case 0b011_011:
            case 0b011_100:
            case 0b011_101:
            case 0b011_110:
            case 0b011_111:
              irpUnlk ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //MOVE.L Ar,USP                                   |-|012346|P|-----|-----|          |0100_111_001_100_rrr
            case 0b100_000:
            case 0b100_001:
            case 0b100_010:
            case 0b100_011:
            case 0b100_100:
            case 0b100_101:
            case 0b100_110:
            case 0b100_111:
              irpMoveToUsp ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //MOVE.L USP,Ar                                   |-|012346|P|-----|-----|          |0100_111_001_101_rrr
            case 0b101_000:
            case 0b101_001:
            case 0b101_010:
            case 0b101_011:
            case 0b101_100:
            case 0b101_101:
            case 0b101_110:
            case 0b101_111:
              irpMoveFromUsp ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //RESET                                           |-|012346|P|-----|-----|          |0100_111_001_110_000
            case 0b110_000:
              irpReset ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //NOP                                             |-|012346|-|-----|-----|          |0100_111_001_110_001
            case 0b110_001:
              irpNop ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //STOP #<data>                                    |-|012346|P|UUUUU|*****|          |0100_111_001_110_010-{data}
            case 0b110_010:
              irpStop ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //RTE                                             |-|012346|P|UUUUU|*****|          |0100_111_001_110_011
            case 0b110_011:
              irpRte ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //RTD #<data>                                     |-|-12346|-|-----|-----|          |0100_111_001_110_100-{data}
            case 0b110_100:
              irpRtd ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //RTS                                             |-|012346|-|-----|-----|          |0100_111_001_110_101
            case 0b110_101:
              irpRts ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //TRAPV                                           |-|012346|-|---*-|-----|          |0100_111_001_110_110
            case 0b110_110:
              irpTrapv ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //RTR                                             |-|012346|-|UUUUU|*****|          |0100_111_001_110_111
            case 0b110_111:
              irpRtr ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //MOVEC.L Rc,Rn                                   |-|-12346|P|-----|-----|          |0100_111_001_111_010-rnnncccccccccccc
            case 0b111_010:
              irpMovecFromControl ();
              break irpSwitch;

              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
              //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
              //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
              //MOVEC.L Rn,Rc                                   |-|-12346|P|-----|-----|          |0100_111_001_111_011-rnnncccccccccccc
            case 0b111_011:
              irpMovecToControl ();
              break irpSwitch;

            default:
              irpIllegal ();

            }  //switch XEiJ.regOC & 0b111_111
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //JSR <ea>                                        |-|012346|-|-----|-----|  M  WXZP |0100_111_010_mmm_rrr
            //JBSR.L <label>                                  |A|012346|-|-----|-----|          |0100_111_010_111_001-{address}       [JSR <label>]
          case 0b0100_111_010:
            irpJsr ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //JMP <ea>                                        |-|012346|-|-----|-----|  M  WXZP |0100_111_011_mmm_rrr
            //JBRA.L <label>                                  |A|012346|-|-----|-----|          |0100_111_011_111_001-{address}       [JMP <label>]
          case 0b0100_111_011:
            irpJmp ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDQ.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_000_mmm_rrr
            //INC.B <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_000_mmm_rrr [ADDQ.B #1,<ea>]
          case 0b0101_000_000:
          case 0b0101_001_000:
          case 0b0101_010_000:
          case 0b0101_011_000:
          case 0b0101_100_000:
          case 0b0101_101_000:
          case 0b0101_110_000:
          case 0b0101_111_000:
            irpAddqByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDQ.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_001_mmm_rrr
            //ADDQ.W #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_001_001_rrr
            //INC.W <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_001_mmm_rrr [ADDQ.W #1,<ea>]
            //INC.W Ar                                        |A|012346|-|-----|-----| A        |0101_001_001_001_rrr [ADDQ.W #1,Ar]
          case 0b0101_000_001:
          case 0b0101_001_001:
          case 0b0101_010_001:
          case 0b0101_011_001:
          case 0b0101_100_001:
          case 0b0101_101_001:
          case 0b0101_110_001:
          case 0b0101_111_001:
            irpAddqWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDQ.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_010_mmm_rrr
            //ADDQ.L #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_010_001_rrr
            //INC.L <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_010_mmm_rrr [ADDQ.L #1,<ea>]
            //INC.L Ar                                        |A|012346|-|-----|-----| A        |0101_001_010_001_rrr [ADDQ.L #1,Ar]
          case 0b0101_000_010:
          case 0b0101_001_010:
          case 0b0101_010_010:
          case 0b0101_011_010:
          case 0b0101_100_010:
          case 0b0101_101_010:
          case 0b0101_110_010:
          case 0b0101_111_010:
            irpAddqLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ST.B <ea>                                       |-|012346|-|-----|-----|D M+-WXZ  |0101_000_011_mmm_rrr
            //SNF.B <ea>                                      |A|012346|-|-----|-----|D M+-WXZ  |0101_000_011_mmm_rrr [ST.B <ea>]
            //DBT.W Dr,<label>                                |-|012346|-|-----|-----|          |0101_000_011_001_rrr-{offset}
            //DBNF.W Dr,<label>                               |A|012346|-|-----|-----|          |0101_000_011_001_rrr-{offset}        [DBT.W Dr,<label>]
            //TRAPT.W #<data>                                 |-|--2346|-|-----|-----|          |0101_000_011_111_010-{data}
            //TPNF.W #<data>                                  |A|--2346|-|-----|-----|          |0101_000_011_111_010-{data}  [TRAPT.W #<data>]
            //TPT.W #<data>                                   |A|--2346|-|-----|-----|          |0101_000_011_111_010-{data}  [TRAPT.W #<data>]
            //TRAPNF.W #<data>                                |A|--2346|-|-----|-----|          |0101_000_011_111_010-{data}  [TRAPT.W #<data>]
            //TRAPT.L #<data>                                 |-|--2346|-|-----|-----|          |0101_000_011_111_011-{data}
            //TPNF.L #<data>                                  |A|--2346|-|-----|-----|          |0101_000_011_111_011-{data}  [TRAPT.L #<data>]
            //TPT.L #<data>                                   |A|--2346|-|-----|-----|          |0101_000_011_111_011-{data}  [TRAPT.L #<data>]
            //TRAPNF.L #<data>                                |A|--2346|-|-----|-----|          |0101_000_011_111_011-{data}  [TRAPT.L #<data>]
            //TRAPT                                           |-|--2346|-|-----|-----|          |0101_000_011_111_100
            //TPNF                                            |A|--2346|-|-----|-----|          |0101_000_011_111_100 [TRAPT]
            //TPT                                             |A|--2346|-|-----|-----|          |0101_000_011_111_100 [TRAPT]
            //TRAPNF                                          |A|--2346|-|-----|-----|          |0101_000_011_111_100 [TRAPT]
          case 0b0101_000_011:
            irpSt ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBQ.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_100_mmm_rrr
            //DEC.B <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_100_mmm_rrr [SUBQ.B #1,<ea>]
          case 0b0101_000_100:
          case 0b0101_001_100:
          case 0b0101_010_100:
          case 0b0101_011_100:
          case 0b0101_100_100:
          case 0b0101_101_100:
          case 0b0101_110_100:
          case 0b0101_111_100:
            irpSubqByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBQ.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_101_mmm_rrr
            //SUBQ.W #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_101_001_rrr
            //DEC.W <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_101_mmm_rrr [SUBQ.W #1,<ea>]
            //DEC.W Ar                                        |A|012346|-|-----|-----| A        |0101_001_101_001_rrr [SUBQ.W #1,Ar]
          case 0b0101_000_101:
          case 0b0101_001_101:
          case 0b0101_010_101:
          case 0b0101_011_101:
          case 0b0101_100_101:
          case 0b0101_101_101:
          case 0b0101_110_101:
          case 0b0101_111_101:
            irpSubqWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBQ.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_110_mmm_rrr
            //SUBQ.L #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_110_001_rrr
            //DEC.L <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_110_mmm_rrr [SUBQ.L #1,<ea>]
            //DEC.L Ar                                        |A|012346|-|-----|-----| A        |0101_001_110_001_rrr [SUBQ.L #1,Ar]
          case 0b0101_000_110:
          case 0b0101_001_110:
          case 0b0101_010_110:
          case 0b0101_011_110:
          case 0b0101_100_110:
          case 0b0101_101_110:
          case 0b0101_110_110:
          case 0b0101_111_110:
            irpSubqLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SF.B <ea>                                       |-|012346|-|-----|-----|D M+-WXZ  |0101_000_111_mmm_rrr
            //SNT.B <ea>                                      |A|012346|-|-----|-----|D M+-WXZ  |0101_000_111_mmm_rrr [SF.B <ea>]
            //DBF.W Dr,<label>                                |-|012346|-|-----|-----|          |0101_000_111_001_rrr-{offset}
            //DBNT.W Dr,<label>                               |A|012346|-|-----|-----|          |0101_000_111_001_rrr-{offset}        [DBF.W Dr,<label>]
            //DBRA.W Dr,<label>                               |A|012346|-|-----|-----|          |0101_000_111_001_rrr-{offset}        [DBF.W Dr,<label>]
            //TRAPF.W #<data>                                 |-|--2346|-|-----|-----|          |0101_000_111_111_010-{data}
            //TPF.W #<data>                                   |A|--2346|-|-----|-----|          |0101_000_111_111_010-{data}  [TRAPF.W #<data>]
            //TPNT.W #<data>                                  |A|--2346|-|-----|-----|          |0101_000_111_111_010-{data}  [TRAPF.W #<data>]
            //TRAPNT.W #<data>                                |A|--2346|-|-----|-----|          |0101_000_111_111_010-{data}  [TRAPF.W #<data>]
            //TRAPF.L #<data>                                 |-|--2346|-|-----|-----|          |0101_000_111_111_011-{data}
            //TPF.L #<data>                                   |A|--2346|-|-----|-----|          |0101_000_111_111_011-{data}  [TRAPF.L #<data>]
            //TPNT.L #<data>                                  |A|--2346|-|-----|-----|          |0101_000_111_111_011-{data}  [TRAPF.L #<data>]
            //TRAPNT.L #<data>                                |A|--2346|-|-----|-----|          |0101_000_111_111_011-{data}  [TRAPF.L #<data>]
            //TRAPF                                           |-|--2346|-|-----|-----|          |0101_000_111_111_100
            //TPF                                             |A|--2346|-|-----|-----|          |0101_000_111_111_100 [TRAPF]
            //TPNT                                            |A|--2346|-|-----|-----|          |0101_000_111_111_100 [TRAPF]
            //TRAPNT                                          |A|--2346|-|-----|-----|          |0101_000_111_111_100 [TRAPF]
          case 0b0101_000_111:
            irpSf ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SHI.B <ea>                                      |-|012346|-|--*-*|-----|D M+-WXZ  |0101_001_011_mmm_rrr
            //SNLS.B <ea>                                     |A|012346|-|--*-*|-----|D M+-WXZ  |0101_001_011_mmm_rrr [SHI.B <ea>]
            //DBHI.W Dr,<label>                               |-|012346|-|--*-*|-----|          |0101_001_011_001_rrr-{offset}
            //DBNLS.W Dr,<label>                              |A|012346|-|--*-*|-----|          |0101_001_011_001_rrr-{offset}        [DBHI.W Dr,<label>]
            //TRAPHI.W #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}
            //TPHI.W #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}  [TRAPHI.W #<data>]
            //TPNLS.W #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}  [TRAPHI.W #<data>]
            //TRAPNLS.W #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}  [TRAPHI.W #<data>]
            //TRAPHI.L #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}
            //TPHI.L #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}  [TRAPHI.L #<data>]
            //TPNLS.L #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}  [TRAPHI.L #<data>]
            //TRAPNLS.L #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}  [TRAPHI.L #<data>]
            //TRAPHI                                          |-|--2346|-|--*-*|-----|          |0101_001_011_111_100
            //TPHI                                            |A|--2346|-|--*-*|-----|          |0101_001_011_111_100 [TRAPHI]
            //TPNLS                                           |A|--2346|-|--*-*|-----|          |0101_001_011_111_100 [TRAPHI]
            //TRAPNLS                                         |A|--2346|-|--*-*|-----|          |0101_001_011_111_100 [TRAPHI]
          case 0b0101_001_011:
            irpShi ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SLS.B <ea>                                      |-|012346|-|--*-*|-----|D M+-WXZ  |0101_001_111_mmm_rrr
            //SNHI.B <ea>                                     |A|012346|-|--*-*|-----|D M+-WXZ  |0101_001_111_mmm_rrr [SLS.B <ea>]
            //DBLS.W Dr,<label>                               |-|012346|-|--*-*|-----|          |0101_001_111_001_rrr-{offset}
            //DBNHI.W Dr,<label>                              |A|012346|-|--*-*|-----|          |0101_001_111_001_rrr-{offset}        [DBLS.W Dr,<label>]
            //TRAPLS.W #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}
            //TPLS.W #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}
            //TPNHI.W #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}  [TRAPLS.W #<data>]
            //TRAPNHI.W #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}  [TRAPLS.W #<data>]
            //TRAPLS.L #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}
            //TPLS.L #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}
            //TPNHI.L #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}  [TRAPLS.L #<data>]
            //TRAPNHI.L #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}  [TRAPLS.L #<data>]
            //TRAPLS                                          |-|--2346|-|--*-*|-----|          |0101_001_111_111_100
            //TPLS                                            |A|--2346|-|--*-*|-----|          |0101_001_111_111_100 [TRAPLS]
            //TPNHI                                           |A|--2346|-|--*-*|-----|          |0101_001_111_111_100 [TRAPLS]
            //TRAPNHI                                         |A|--2346|-|--*-*|-----|          |0101_001_111_111_100 [TRAPLS]
          case 0b0101_001_111:
            irpSls ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SCC.B <ea>                                      |-|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr
            //SHS.B <ea>                                      |A|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr [SCC.B <ea>]
            //SNCS.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr [SCC.B <ea>]
            //SNLO.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr [SCC.B <ea>]
            //DBCC.W Dr,<label>                               |-|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}
            //DBHS.W Dr,<label>                               |A|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}        [DBCC.W Dr,<label>]
            //DBNCS.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}        [DBCC.W Dr,<label>]
            //DBNLO.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}        [DBCC.W Dr,<label>]
            //TRAPCC.W #<data>                                |-|--2346|-|----*|-----|          |0101_010_011_111_010-{data}
            //TPCC.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TPHS.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TPNCS.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TPNLO.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TRAPHS.W #<data>                                |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TRAPNCS.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TRAPNLO.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
            //TRAPCC.L #<data>                                |-|--2346|-|----*|-----|          |0101_010_011_111_011-{data}
            //TPCC.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TPHS.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TPNCS.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TPNLO.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TRAPHS.L #<data>                                |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TRAPNCS.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TRAPNLO.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
            //TRAPCC                                          |-|--2346|-|----*|-----|          |0101_010_011_111_100
            //TPCC                                            |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
            //TPHS                                            |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
            //TPNCS                                           |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
            //TPNLO                                           |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
            //TRAPHS                                          |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
            //TRAPNCS                                         |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
            //TRAPNLO                                         |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
          case 0b0101_010_011:
            irpShs ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SCS.B <ea>                                      |-|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr
            //SLO.B <ea>                                      |A|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr [SCS.B <ea>]
            //SNCC.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr [SCS.B <ea>]
            //SNHS.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr [SCS.B <ea>]
            //DBCS.W Dr,<label>                               |-|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}
            //DBLO.W Dr,<label>                               |A|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}        [DBCS.W Dr,<label>]
            //DBNCC.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}        [DBCS.W Dr,<label>]
            //DBNHS.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}        [DBCS.W Dr,<label>]
            //TRAPCS.W #<data>                                |-|--2346|-|----*|-----|          |0101_010_111_111_010-{data}
            //TPCS.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TPLO.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TPNCC.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TPNHS.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TRAPLO.W #<data>                                |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TRAPNCC.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TRAPNHS.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
            //TRAPCS.L #<data>                                |-|--2346|-|----*|-----|          |0101_010_111_111_011-{data}
            //TPCS.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TPLO.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TPNCC.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TPNHS.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TRAPLO.L #<data>                                |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TRAPNCC.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TRAPNHS.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
            //TRAPCS                                          |-|--2346|-|----*|-----|          |0101_010_111_111_100
            //TPCS                                            |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
            //TPLO                                            |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
            //TPNCC                                           |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
            //TPNHS                                           |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
            //TRAPLO                                          |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
            //TRAPNCC                                         |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
            //TRAPNHS                                         |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
          case 0b0101_010_111:
            irpSlo ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SNE.B <ea>                                      |-|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr
            //SNEQ.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr [SNE.B <ea>]
            //SNZ.B <ea>                                      |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr [SNE.B <ea>]
            //SNZE.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr [SNE.B <ea>]
            //DBNE.W Dr,<label>                               |-|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}
            //DBNEQ.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}        [DBNE.W Dr,<label>]
            //DBNZ.W Dr,<label>                               |A|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}        [DBNE.W Dr,<label>]
            //DBNZE.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}        [DBNE.W Dr,<label>]
            //TRAPNE.W #<data>                                |-|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}
            //TPNE.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TPNEQ.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TPNZ.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TPNZE.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TRAPNEQ.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TRAPNZ.W #<data>                                |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TRAPNZE.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
            //TRAPNE.L #<data>                                |-|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}
            //TPNE.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TPNEQ.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TPNZ.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TPNZE.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TRAPNEQ.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TRAPNZ.L #<data>                                |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TRAPNZE.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
            //TRAPNE                                          |-|--2346|-|--*--|-----|          |0101_011_011_111_100
            //TPNE                                            |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
            //TPNEQ                                           |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
            //TPNZ                                            |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
            //TPNZE                                           |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
            //TRAPNEQ                                         |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
            //TRAPNZ                                          |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
            //TRAPNZE                                         |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
          case 0b0101_011_011:
            irpSne ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SEQ.B <ea>                                      |-|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr
            //SNNE.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr [SEQ.B <ea>]
            //SNNZ.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr [SEQ.B <ea>]
            //SZE.B <ea>                                      |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr [SEQ.B <ea>]
            //DBEQ.W Dr,<label>                               |-|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}
            //DBNNE.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}        [DBEQ.W Dr,<label>]
            //DBNNZ.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}        [DBEQ.W Dr,<label>]
            //DBZE.W Dr,<label>                               |A|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}        [DBEQ.W Dr,<label>]
            //TRAPEQ.W #<data>                                |-|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}
            //TPEQ.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TPNNE.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TPNNZ.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TPZE.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TRAPNNE.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TRAPNNZ.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TRAPZE.W #<data>                                |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
            //TRAPEQ.L #<data>                                |-|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}
            //TPEQ.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TPNNE.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TPNNZ.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TPZE.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TRAPNNE.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TRAPNNZ.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TRAPZE.L #<data>                                |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
            //TRAPEQ                                          |-|--2346|-|--*--|-----|          |0101_011_111_111_100
            //TPEQ                                            |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
            //TPNNE                                           |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
            //TPNNZ                                           |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
            //TPZE                                            |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
            //TRAPNNE                                         |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
            //TRAPNNZ                                         |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
            //TRAPZE                                          |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
          case 0b0101_011_111:
            irpSeq ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SVC.B <ea>                                      |-|012346|-|---*-|-----|D M+-WXZ  |0101_100_011_mmm_rrr
            //SNVS.B <ea>                                     |A|012346|-|---*-|-----|D M+-WXZ  |0101_100_011_mmm_rrr [SVC.B <ea>]
            //DBVC.W Dr,<label>                               |-|012346|-|---*-|-----|          |0101_100_011_001_rrr-{offset}
            //DBNVS.W Dr,<label>                              |A|012346|-|---*-|-----|          |0101_100_011_001_rrr-{offset}        [DBVC.W Dr,<label>]
            //TRAPVC.W #<data>                                |-|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}
            //TPNVS.W #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}  [TRAPVC.W #<data>]
            //TPVC.W #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}  [TRAPVC.W #<data>]
            //TRAPNVS.W #<data>                               |A|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}  [TRAPVC.W #<data>]
            //TRAPVC.L #<data>                                |-|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}
            //TPNVS.L #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}  [TRAPVC.L #<data>]
            //TPVC.L #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}  [TRAPVC.L #<data>]
            //TRAPNVS.L #<data>                               |A|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}  [TRAPVC.L #<data>]
            //TRAPVC                                          |-|--2346|-|---*-|-----|          |0101_100_011_111_100
            //TPNVS                                           |A|--2346|-|---*-|-----|          |0101_100_011_111_100 [TRAPVC]
            //TPVC                                            |A|--2346|-|---*-|-----|          |0101_100_011_111_100 [TRAPVC]
            //TRAPNVS                                         |A|--2346|-|---*-|-----|          |0101_100_011_111_100 [TRAPVC]
          case 0b0101_100_011:
            irpSvc ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SVS.B <ea>                                      |-|012346|-|---*-|-----|D M+-WXZ  |0101_100_111_mmm_rrr
            //SNVC.B <ea>                                     |A|012346|-|---*-|-----|D M+-WXZ  |0101_100_111_mmm_rrr [SVS.B <ea>]
            //DBVS.W Dr,<label>                               |-|012346|-|---*-|-----|          |0101_100_111_001_rrr-{offset}
            //DBNVC.W Dr,<label>                              |A|012346|-|---*-|-----|          |0101_100_111_001_rrr-{offset}        [DBVS.W Dr,<label>]
            //TRAPVS.W #<data>                                |-|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}
            //TPNVC.W #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}  [TRAPVS.W #<data>]
            //TPVS.W #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}  [TRAPVS.W #<data>]
            //TRAPNVC.W #<data>                               |A|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}  [TRAPVS.W #<data>]
            //TRAPVS.L #<data>                                |-|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}
            //TPNVC.L #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}  [TRAPVS.L #<data>]
            //TPVS.L #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}  [TRAPVS.L #<data>]
            //TRAPNVC.L #<data>                               |A|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}  [TRAPVS.L #<data>]
            //TRAPVS                                          |-|--2346|-|---*-|-----|          |0101_100_111_111_100
            //TPNVC                                           |A|--2346|-|---*-|-----|          |0101_100_111_111_100 [TRAPVS]
            //TPVS                                            |A|--2346|-|---*-|-----|          |0101_100_111_111_100 [TRAPVS]
            //TRAPNVC                                         |A|--2346|-|---*-|-----|          |0101_100_111_111_100 [TRAPVS]
          case 0b0101_100_111:
            irpSvs ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SPL.B <ea>                                      |-|012346|-|-*---|-----|D M+-WXZ  |0101_101_011_mmm_rrr
            //SNMI.B <ea>                                     |A|012346|-|-*---|-----|D M+-WXZ  |0101_101_011_mmm_rrr [SPL.B <ea>]
            //DBPL.W Dr,<label>                               |-|012346|-|-*---|-----|          |0101_101_011_001_rrr-{offset}
            //DBNMI.W Dr,<label>                              |A|012346|-|-*---|-----|          |0101_101_011_001_rrr-{offset}        [DBPL.W Dr,<label>]
            //TRAPPL.W #<data>                                |-|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}
            //TPNMI.W #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}  [TRAPPL.W #<data>]
            //TPPL.W #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}  [TRAPPL.W #<data>]
            //TRAPNMI.W #<data>                               |A|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}  [TRAPPL.W #<data>]
            //TRAPPL.L #<data>                                |-|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}
            //TPNMI.L #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}  [TRAPPL.L #<data>]
            //TPPL.L #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}  [TRAPPL.L #<data>]
            //TRAPNMI.L #<data>                               |A|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}  [TRAPPL.L #<data>]
            //TRAPPL                                          |-|--2346|-|-*---|-----|          |0101_101_011_111_100
            //TPNMI                                           |A|--2346|-|-*---|-----|          |0101_101_011_111_100 [TRAPPL]
            //TPPL                                            |A|--2346|-|-*---|-----|          |0101_101_011_111_100 [TRAPPL]
            //TRAPNMI                                         |A|--2346|-|-*---|-----|          |0101_101_011_111_100 [TRAPPL]
          case 0b0101_101_011:
            irpSpl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SMI.B <ea>                                      |-|012346|-|-*---|-----|D M+-WXZ  |0101_101_111_mmm_rrr
            //SNPL.B <ea>                                     |A|012346|-|-*---|-----|D M+-WXZ  |0101_101_111_mmm_rrr [SMI.B <ea>]
            //DBMI.W Dr,<label>                               |-|012346|-|-*---|-----|          |0101_101_111_001_rrr-{offset}
            //DBNPL.W Dr,<label>                              |A|012346|-|-*---|-----|          |0101_101_111_001_rrr-{offset}        [DBMI.W Dr,<label>]
            //TRAPMI.W #<data>                                |-|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}
            //TPMI.W #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}  [TRAPMI.W #<data>]
            //TPNPL.W #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}  [TRAPMI.W #<data>]
            //TRAPNPL.W #<data>                               |A|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}  [TRAPMI.W #<data>]
            //TRAPMI.L #<data>                                |-|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}
            //TPMI.L #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}  [TRAPMI.L #<data>]
            //TPNPL.L #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}  [TRAPMI.L #<data>]
            //TRAPNPL.L #<data>                               |A|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}  [TRAPMI.L #<data>]
            //TRAPMI                                          |-|--2346|-|-*---|-----|          |0101_101_111_111_100
            //TPMI                                            |A|--2346|-|-*---|-----|          |0101_101_111_111_100 [TRAPMI]
            //TPNPL                                           |A|--2346|-|-*---|-----|          |0101_101_111_111_100 [TRAPMI]
            //TRAPNPL                                         |A|--2346|-|-*---|-----|          |0101_101_111_111_100 [TRAPMI]
          case 0b0101_101_111:
            irpSmi ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SGE.B <ea>                                      |-|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_011_mmm_rrr
            //SNLT.B <ea>                                     |A|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_011_mmm_rrr [SGE.B <ea>]
            //DBGE.W Dr,<label>                               |-|012346|-|-*-*-|-----|          |0101_110_011_001_rrr-{offset}
            //DBNLT.W Dr,<label>                              |A|012346|-|-*-*-|-----|          |0101_110_011_001_rrr-{offset}        [DBGE.W Dr,<label>]
            //TRAPGE.W #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}
            //TPGE.W #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}  [TRAPGE.W #<data>]
            //TPNLT.W #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}  [TRAPGE.W #<data>]
            //TRAPNLT.W #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}  [TRAPGE.W #<data>]
            //TRAPGE.L #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}
            //TPGE.L #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}  [TRAPGE.L #<data>]
            //TPNLT.L #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}  [TRAPGE.L #<data>]
            //TRAPNLT.L #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}  [TRAPGE.L #<data>]
            //TRAPGE                                          |-|--2346|-|-*-*-|-----|          |0101_110_011_111_100
            //TPGE                                            |A|--2346|-|-*-*-|-----|          |0101_110_011_111_100 [TRAPGE]
            //TPNLT                                           |A|--2346|-|-*-*-|-----|          |0101_110_011_111_100 [TRAPGE]
            //TRAPNLT                                         |A|--2346|-|-*-*-|-----|          |0101_110_011_111_100 [TRAPGE]
          case 0b0101_110_011:
            irpSge ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SLT.B <ea>                                      |-|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_111_mmm_rrr
            //SNGE.B <ea>                                     |A|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_111_mmm_rrr [SLT.B <ea>]
            //DBLT.W Dr,<label>                               |-|012346|-|-*-*-|-----|          |0101_110_111_001_rrr-{offset}
            //DBNGE.W Dr,<label>                              |A|012346|-|-*-*-|-----|          |0101_110_111_001_rrr-{offset}        [DBLT.W Dr,<label>]
            //TRAPLT.W #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}
            //TPLT.W #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}  [TRAPLT.W #<data>]
            //TPNGE.W #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}  [TRAPLT.W #<data>]
            //TRAPNGE.W #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}  [TRAPLT.W #<data>]
            //TRAPLT.L #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}
            //TPLT.L #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}  [TRAPLT.L #<data>]
            //TPNGE.L #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}  [TRAPLT.L #<data>]
            //TRAPNGE.L #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}  [TRAPLT.L #<data>]
            //TRAPLT                                          |-|--2346|-|-*-*-|-----|          |0101_110_111_111_100
            //TPLT                                            |A|--2346|-|-*-*-|-----|          |0101_110_111_111_100 [TRAPLT]
            //TPNGE                                           |A|--2346|-|-*-*-|-----|          |0101_110_111_111_100 [TRAPLT]
            //TRAPNGE                                         |A|--2346|-|-*-*-|-----|          |0101_110_111_111_100 [TRAPLT]
          case 0b0101_110_111:
            irpSlt ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SGT.B <ea>                                      |-|012346|-|-***-|-----|D M+-WXZ  |0101_111_011_mmm_rrr
            //SNLE.B <ea>                                     |A|012346|-|-***-|-----|D M+-WXZ  |0101_111_011_mmm_rrr [SGT.B <ea>]
            //DBGT.W Dr,<label>                               |-|012346|-|-***-|-----|          |0101_111_011_001_rrr-{offset}
            //DBNLE.W Dr,<label>                              |A|012346|-|-***-|-----|          |0101_111_011_001_rrr-{offset}        [DBGT.W Dr,<label>]
            //TRAPGT.W #<data>                                |-|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}
            //TPGT.W #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}  [TRAPGT.W #<data>]
            //TPNLE.W #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}  [TRAPGT.W #<data>]
            //TRAPNLE.W #<data>                               |A|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}  [TRAPGT.W #<data>]
            //TRAPGT.L #<data>                                |-|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}
            //TPGT.L #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}  [TRAPGT.L #<data>]
            //TPNLE.L #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}  [TRAPGT.L #<data>]
            //TRAPNLE.L #<data>                               |A|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}  [TRAPGT.L #<data>]
            //TRAPGT                                          |-|--2346|-|-***-|-----|          |0101_111_011_111_100
            //TPGT                                            |A|--2346|-|-***-|-----|          |0101_111_011_111_100 [TRAPGT]
            //TPNLE                                           |A|--2346|-|-***-|-----|          |0101_111_011_111_100 [TRAPGT]
            //TRAPNLE                                         |A|--2346|-|-***-|-----|          |0101_111_011_111_100 [TRAPGT]
          case 0b0101_111_011:
            irpSgt ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SLE.B <ea>                                      |-|012346|-|-***-|-----|D M+-WXZ  |0101_111_111_mmm_rrr
            //SNGT.B <ea>                                     |A|012346|-|-***-|-----|D M+-WXZ  |0101_111_111_mmm_rrr [SLE.B <ea>]
            //DBLE.W Dr,<label>                               |-|012346|-|-***-|-----|          |0101_111_111_001_rrr-{offset}
            //DBNGT.W Dr,<label>                              |A|012346|-|-***-|-----|          |0101_111_111_001_rrr-{offset}        [DBLE.W Dr,<label>]
            //TRAPLE.W #<data>                                |-|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}
            //TPLE.W #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}  [TRAPLE.W #<data>]
            //TPNGT.W #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}  [TRAPLE.W #<data>]
            //TRAPNGT.W #<data>                               |A|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}  [TRAPLE.W #<data>]
            //TRAPLE.L #<data>                                |-|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}
            //TPLE.L #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}  [TRAPLE.L #<data>]
            //TPNGT.L #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}  [TRAPLE.L #<data>]
            //TRAPNGT.L #<data>                               |A|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}  [TRAPLE.L #<data>]
            //TRAPLE                                          |-|--2346|-|-***-|-----|          |0101_111_111_111_100
            //TPLE                                            |A|--2346|-|-***-|-----|          |0101_111_111_111_100 [TRAPLE]
            //TPNGT                                           |A|--2346|-|-***-|-----|          |0101_111_111_111_100 [TRAPLE]
            //TRAPNGT                                         |A|--2346|-|-***-|-----|          |0101_111_111_111_100 [TRAPLE]
          case 0b0101_111_111:
            irpSle ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BRA.W <label>                                   |-|012346|-|-----|-----|          |0110_000_000_000_000-{offset}
            //JBRA.W <label>                                  |A|012346|-|-----|-----|          |0110_000_000_000_000-{offset}        [BRA.W <label>]
            //BRA.S <label>                                   |-|012346|-|-----|-----|          |0110_000_000_sss_sss (s is not equal to 0)
            //JBRA.S <label>                                  |A|012346|-|-----|-----|          |0110_000_000_sss_sss (s is not equal to 0)   [BRA.S <label>]
          case 0b0110_000_000:
            irpBrasw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BRA.S <label>                                   |-|012346|-|-----|-----|          |0110_000_001_sss_sss
            //JBRA.S <label>                                  |A|012346|-|-----|-----|          |0110_000_001_sss_sss [BRA.S <label>]
          case 0b0110_000_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BRA.S <label>                                   |-|012346|-|-----|-----|          |0110_000_010_sss_sss
            //JBRA.S <label>                                  |A|012346|-|-----|-----|          |0110_000_010_sss_sss [BRA.S <label>]
          case 0b0110_000_010:
            irpBras ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BRA.S <label>                                   |-|--2346|-|-----|-----|          |0110_000_011_sss_sss (s is not equal to 63)
            //JBRA.S <label>                                  |A|--2346|-|-----|-----|          |0110_000_011_sss_sss (s is not equal to 63)  [BRA.S <label>]
            //BRA.L <label>                                   |-|--2346|-|-----|-----|          |0110_000_011_111_111-{offset}
          case 0b0110_000_011:
            irpBrasl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BSR.W <label>                                   |-|012346|-|-----|-----|          |0110_000_100_000_000-{offset}
            //JBSR.W <label>                                  |A|012346|-|-----|-----|          |0110_000_100_000_000-{offset}        [BSR.W <label>]
            //BSR.S <label>                                   |-|012346|-|-----|-----|          |0110_000_100_sss_sss (s is not equal to 0)
            //JBSR.S <label>                                  |A|012346|-|-----|-----|          |0110_000_100_sss_sss (s is not equal to 0)   [BSR.S <label>]
          case 0b0110_000_100:
            irpBsrsw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BSR.S <label>                                   |-|012346|-|-----|-----|          |0110_000_101_sss_sss
            //JBSR.S <label>                                  |A|012346|-|-----|-----|          |0110_000_101_sss_sss [BSR.S <label>]
          case 0b0110_000_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BSR.S <label>                                   |-|012346|-|-----|-----|          |0110_000_110_sss_sss
            //JBSR.S <label>                                  |A|012346|-|-----|-----|          |0110_000_110_sss_sss [BSR.S <label>]
          case 0b0110_000_110:
            irpBsrs ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BSR.S <label>                                   |-|--2346|-|-----|-----|          |0110_000_111_sss_sss (s is not equal to 63)
            //JBSR.S <label>                                  |A|--2346|-|-----|-----|          |0110_000_111_sss_sss (s is not equal to 63)  [BSR.S <label>]
            //BSR.L <label>                                   |-|--2346|-|-----|-----|          |0110_000_111_111_111-{offset}
          case 0b0110_000_111:
            irpBsrsl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BHI.W <label>                                   |-|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}
            //BNLS.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}        [BHI.W <label>]
            //JBHI.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}        [BHI.W <label>]
            //JBNLS.W <label>                                 |A|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}        [BHI.W <label>]
            //BHI.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)
            //BNLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)   [BHI.S <label>]
            //JBHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)   [BHI.S <label>]
            //JBNLS.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)   [BHI.S <label>]
            //JBLS.L <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_000_110-0100111011111001-{address}      [BHI.S (*)+8;JMP <label>]
            //JBNHI.L <label>                                 |A|012346|-|--*-*|-----|          |0110_001_000_000_110-0100111011111001-{address}      [BHI.S (*)+8;JMP <label>]
          case 0b0110_001_000:
            irpBhisw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BHI.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_001_sss_sss
            //BNLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_001_sss_sss [BHI.S <label>]
            //JBHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_001_sss_sss [BHI.S <label>]
            //JBNLS.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_001_sss_sss [BHI.S <label>]
          case 0b0110_001_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BHI.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_010_sss_sss
            //BNLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_010_sss_sss [BHI.S <label>]
            //JBHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_010_sss_sss [BHI.S <label>]
            //JBNLS.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_010_sss_sss [BHI.S <label>]
          case 0b0110_001_010:
            irpBhis ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BHI.S <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)
            //BNLS.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)  [BHI.S <label>]
            //JBHI.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)  [BHI.S <label>]
            //JBNLS.S <label>                                 |A|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)  [BHI.S <label>]
            //BHI.L <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_011_111_111-{offset}
            //BNLS.L <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_011_111_111-{offset}        [BHI.L <label>]
          case 0b0110_001_011:
            irpBhisl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLS.W <label>                                   |-|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}
            //BNHI.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}        [BLS.W <label>]
            //JBLS.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}        [BLS.W <label>]
            //JBNHI.W <label>                                 |A|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}        [BLS.W <label>]
            //BLS.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)
            //BNHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)   [BLS.S <label>]
            //JBLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)   [BLS.S <label>]
            //JBNHI.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)   [BLS.S <label>]
            //JBHI.L <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_000_110-0100111011111001-{address}      [BLS.S (*)+8;JMP <label>]
            //JBNLS.L <label>                                 |A|012346|-|--*-*|-----|          |0110_001_100_000_110-0100111011111001-{address}      [BLS.S (*)+8;JMP <label>]
          case 0b0110_001_100:
            irpBlssw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLS.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_101_sss_sss
            //BNHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_101_sss_sss [BLS.S <label>]
            //JBLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_101_sss_sss [BLS.S <label>]
            //JBNHI.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_101_sss_sss [BLS.S <label>]
          case 0b0110_001_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLS.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_110_sss_sss
            //BNHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_110_sss_sss [BLS.S <label>]
            //JBLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_110_sss_sss [BLS.S <label>]
            //JBNHI.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_110_sss_sss [BLS.S <label>]
          case 0b0110_001_110:
            irpBlss ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLS.S <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)
            //BNHI.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)  [BLS.S <label>]
            //JBLS.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)  [BLS.S <label>]
            //JBNHI.S <label>                                 |A|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)  [BLS.S <label>]
            //BLS.L <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_111_111_111-{offset}
            //BNHI.L <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_111_111_111-{offset}        [BLS.L <label>]
          case 0b0110_001_111:
            irpBlssl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCC.W <label>                                   |-|012346|-|----*|-----|          |0110_010_000_000_000-{offset}
            //BHS.W <label>                                   |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //BNCS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //BNLO.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //JBCC.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //JBHS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //JBNCS.W <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //JBNLO.W <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
            //BCC.S <label>                                   |-|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)
            //BHS.S <label>                                   |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //BNCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //BNLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //JBCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //JBHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //JBNCS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //JBNLO.S <label>                                 |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
            //JBCS.L <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
            //JBLO.L <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
            //JBNCC.L <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
            //JBNHS.L <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
          case 0b0110_010_000:
            irpBhssw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCC.S <label>                                   |-|012346|-|----*|-----|          |0110_010_001_sss_sss
            //BHS.S <label>                                   |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
            //BNCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
            //BNLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
            //JBCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
            //JBHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
            //JBNCS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
            //JBNLO.S <label>                                 |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
          case 0b0110_010_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCC.S <label>                                   |-|012346|-|----*|-----|          |0110_010_010_sss_sss
            //BHS.S <label>                                   |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
            //BNCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
            //BNLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
            //JBCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
            //JBHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
            //JBNCS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
            //JBNLO.S <label>                                 |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
          case 0b0110_010_010:
            irpBhss ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCC.S <label>                                   |-|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)
            //BHS.S <label>                                   |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //BNCS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //BNLO.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //JBCC.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //JBHS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //JBNCS.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //JBNLO.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
            //BCC.L <label>                                   |-|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}
            //BHS.L <label>                                   |A|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}        [BCC.L <label>]
            //BNCS.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}        [BCC.L <label>]
            //BNLO.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}        [BCC.L <label>]
          case 0b0110_010_011:
            irpBhssl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCS.W <label>                                   |-|012346|-|----*|-----|          |0110_010_100_000_000-{offset}
            //BLO.W <label>                                   |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //BNCC.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //BNHS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //JBCS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //JBLO.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //JBNCC.W <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //JBNHS.W <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
            //BCS.S <label>                                   |-|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)
            //BLO.S <label>                                   |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //BNCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //BNHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //JBCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //JBLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //JBNCC.S <label>                                 |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //JBNHS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
            //JBCC.L <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
            //JBHS.L <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
            //JBNCS.L <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
            //JBNLO.L <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
          case 0b0110_010_100:
            irpBlosw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCS.S <label>                                   |-|012346|-|----*|-----|          |0110_010_101_sss_sss
            //BLO.S <label>                                   |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
            //BNCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
            //BNHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
            //JBCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
            //JBLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
            //JBNCC.S <label>                                 |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
            //JBNHS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
          case 0b0110_010_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCS.S <label>                                   |-|012346|-|----*|-----|          |0110_010_110_sss_sss
            //BLO.S <label>                                   |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
            //BNCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
            //BNHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
            //JBCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
            //JBLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
            //JBNCC.S <label>                                 |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
            //JBNHS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
          case 0b0110_010_110:
            irpBlos ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BCS.S <label>                                   |-|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)
            //BLO.S <label>                                   |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //BNCC.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //BNHS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //JBCS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //JBLO.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //JBNCC.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //JBNHS.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
            //BCS.L <label>                                   |-|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}
            //BLO.L <label>                                   |A|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}        [BCS.L <label>]
            //BNCC.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}        [BCS.L <label>]
            //BNHS.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}        [BCS.L <label>]
          case 0b0110_010_111:
            irpBlosl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BNE.W <label>                                   |-|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}
            //BNEQ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //BNZ.W <label>                                   |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //BNZE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //JBNE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //JBNEQ.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //JBNZ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //JBNZE.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
            //BNE.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)
            //BNEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //BNZ.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //BNZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //JBNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //JBNEQ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //JBNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //JBNZE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
            //JBEQ.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
            //JBNEQ.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
            //JBNNE.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
            //JBNNZ.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
            //JBNZ.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
            //JBNZE.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
            //JBZE.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
          case 0b0110_011_000:
            irpBnesw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BNE.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_001_sss_sss
            //BNEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
            //BNZ.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
            //BNZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
            //JBNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
            //JBNEQ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
            //JBNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
            //JBNZE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
          case 0b0110_011_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BNE.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_010_sss_sss
            //BNEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
            //BNZ.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
            //BNZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
            //JBNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
            //JBNEQ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
            //JBNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
            //JBNZE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
          case 0b0110_011_010:
            irpBnes ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BNE.S <label>                                   |-|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)
            //BNEQ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //BNZ.S <label>                                   |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //BNZE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //JBNE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //JBNEQ.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //JBNZ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //JBNZE.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
            //BNE.L <label>                                   |-|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}
            //BNEQ.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}        [BNE.L <label>]
            //BNZ.L <label>                                   |A|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}        [BNE.L <label>]
            //BNZE.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}        [BNE.L <label>]
          case 0b0110_011_011:
            irpBnesl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BEQ.W <label>                                   |-|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}
            //BNNE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //BNNZ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //BZE.W <label>                                   |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //JBEQ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //JBNNE.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //JBNNZ.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //JBZE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
            //BEQ.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)
            //BNNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //BNNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //BZE.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //JBEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //JBNNE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //JBNNZ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //JBZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
            //JBNE.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_110-0100111011111001-{address}      [BEQ.S (*)+8;JMP <label>]
          case 0b0110_011_100:
            irpBeqsw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BEQ.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_101_sss_sss
            //BNNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
            //BNNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
            //BZE.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
            //JBEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
            //JBNNE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
            //JBNNZ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
            //JBZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
          case 0b0110_011_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BEQ.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_110_sss_sss
            //BNNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
            //BNNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
            //BZE.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
            //JBEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
            //JBNNE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
            //JBNNZ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
            //JBZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
          case 0b0110_011_110:
            irpBeqs ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BEQ.S <label>                                   |-|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)
            //BNNE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //BNNZ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //BZE.S <label>                                   |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //JBEQ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //JBNNE.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //JBNNZ.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //JBZE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
            //BEQ.L <label>                                   |-|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}
            //BNNE.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}        [BEQ.L <label>]
            //BNNZ.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}        [BEQ.L <label>]
            //BZE.L <label>                                   |A|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}        [BEQ.L <label>]
          case 0b0110_011_111:
            irpBeqsl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVC.W <label>                                   |-|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}
            //BNVS.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}        [BVC.W <label>]
            //JBNVS.W <label>                                 |A|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}        [BVC.W <label>]
            //JBVC.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}        [BVC.W <label>]
            //BVC.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)
            //BNVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)   [BVC.S <label>]
            //JBNVS.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)   [BVC.S <label>]
            //JBVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)   [BVC.S <label>]
            //JBNVC.L <label>                                 |A|012346|-|---*-|-----|          |0110_100_000_000_110-0100111011111001-{address}      [BVC.S (*)+8;JMP <label>]
            //JBVS.L <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_000_110-0100111011111001-{address}      [BVC.S (*)+8;JMP <label>]
          case 0b0110_100_000:
            irpBvcsw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVC.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_001_sss_sss
            //BNVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_001_sss_sss [BVC.S <label>]
            //JBNVS.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_001_sss_sss [BVC.S <label>]
            //JBVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_001_sss_sss [BVC.S <label>]
          case 0b0110_100_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVC.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_010_sss_sss
            //BNVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_010_sss_sss [BVC.S <label>]
            //JBNVS.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_010_sss_sss [BVC.S <label>]
            //JBVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_010_sss_sss [BVC.S <label>]
          case 0b0110_100_010:
            irpBvcs ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVC.S <label>                                   |-|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)
            //BNVS.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)  [BVC.S <label>]
            //JBNVS.S <label>                                 |A|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)  [BVC.S <label>]
            //JBVC.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)  [BVC.S <label>]
            //BVC.L <label>                                   |-|--2346|-|---*-|-----|          |0110_100_011_111_111-{offset}
            //BNVS.L <label>                                  |A|--2346|-|---*-|-----|          |0110_100_011_111_111-{offset}        [BVC.L <label>]
          case 0b0110_100_011:
            irpBvcsl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVS.W <label>                                   |-|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}
            //BNVC.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}        [BVS.W <label>]
            //JBNVC.W <label>                                 |A|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}        [BVS.W <label>]
            //JBVS.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}        [BVS.W <label>]
            //BVS.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)
            //BNVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)   [BVS.S <label>]
            //JBNVC.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)   [BVS.S <label>]
            //JBVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)   [BVS.S <label>]
            //JBNVS.L <label>                                 |A|012346|-|---*-|-----|          |0110_100_100_000_110-0100111011111001-{address}      [BVS.S (*)+8;JMP <label>]
            //JBVC.L <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_000_110-0100111011111001-{address}      [BVS.S (*)+8;JMP <label>]
          case 0b0110_100_100:
            irpBvssw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVS.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_101_sss_sss
            //BNVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_101_sss_sss [BVS.S <label>]
            //JBNVC.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_101_sss_sss [BVS.S <label>]
            //JBVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_101_sss_sss [BVS.S <label>]
          case 0b0110_100_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVS.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_110_sss_sss
            //BNVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_110_sss_sss [BVS.S <label>]
            //JBNVC.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_110_sss_sss [BVS.S <label>]
            //JBVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_110_sss_sss [BVS.S <label>]
          case 0b0110_100_110:
            irpBvss ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BVS.S <label>                                   |-|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)
            //BNVC.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)  [BVS.S <label>]
            //JBNVC.S <label>                                 |A|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)  [BVS.S <label>]
            //JBVS.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)  [BVS.S <label>]
            //BVS.L <label>                                   |-|--2346|-|---*-|-----|          |0110_100_111_111_111-{offset}
            //BNVC.L <label>                                  |A|--2346|-|---*-|-----|          |0110_100_111_111_111-{offset}        [BVS.L <label>]
          case 0b0110_100_111:
            irpBvssl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BPL.W <label>                                   |-|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}
            //BNMI.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}        [BPL.W <label>]
            //JBNMI.W <label>                                 |A|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}        [BPL.W <label>]
            //JBPL.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}        [BPL.W <label>]
            //BPL.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)
            //BNMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)   [BPL.S <label>]
            //JBNMI.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)   [BPL.S <label>]
            //JBPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)   [BPL.S <label>]
            //JBMI.L <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_000_110-0100111011111001-{address}      [BPL.S (*)+8;JMP <label>]
            //JBNPL.L <label>                                 |A|012346|-|-*---|-----|          |0110_101_000_000_110-0100111011111001-{address}      [BPL.S (*)+8;JMP <label>]
          case 0b0110_101_000:
            irpBplsw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BPL.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_001_sss_sss
            //BNMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_001_sss_sss [BPL.S <label>]
            //JBNMI.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_001_sss_sss [BPL.S <label>]
            //JBPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_001_sss_sss [BPL.S <label>]
          case 0b0110_101_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BPL.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_010_sss_sss
            //BNMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_010_sss_sss [BPL.S <label>]
            //JBNMI.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_010_sss_sss [BPL.S <label>]
            //JBPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_010_sss_sss [BPL.S <label>]
          case 0b0110_101_010:
            irpBpls ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BPL.S <label>                                   |-|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)
            //BNMI.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)  [BPL.S <label>]
            //JBNMI.S <label>                                 |A|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)  [BPL.S <label>]
            //JBPL.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)  [BPL.S <label>]
            //BPL.L <label>                                   |-|--2346|-|-*---|-----|          |0110_101_011_111_111-{offset}
            //BNMI.L <label>                                  |A|--2346|-|-*---|-----|          |0110_101_011_111_111-{offset}        [BPL.L <label>]
          case 0b0110_101_011:
            irpBplsl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BMI.W <label>                                   |-|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}
            //BNPL.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}        [BMI.W <label>]
            //JBMI.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}        [BMI.W <label>]
            //JBNPL.W <label>                                 |A|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}        [BMI.W <label>]
            //BMI.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)
            //BNPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)   [BMI.S <label>]
            //JBMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)   [BMI.S <label>]
            //JBNPL.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)   [BMI.S <label>]
            //JBNMI.L <label>                                 |A|012346|-|-*---|-----|          |0110_101_100_000_110-0100111011111001-{address}      [BMI.S (*)+8;JMP <label>]
            //JBPL.L <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_000_110-0100111011111001-{address}      [BMI.S (*)+8;JMP <label>]
          case 0b0110_101_100:
            irpBmisw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BMI.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_101_sss_sss
            //BNPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_101_sss_sss [BMI.S <label>]
            //JBMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_101_sss_sss [BMI.S <label>]
            //JBNPL.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_101_sss_sss [BMI.S <label>]
          case 0b0110_101_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BMI.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_110_sss_sss
            //BNPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_110_sss_sss [BMI.S <label>]
            //JBMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_110_sss_sss [BMI.S <label>]
            //JBNPL.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_110_sss_sss [BMI.S <label>]
          case 0b0110_101_110:
            irpBmis ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BMI.S <label>                                   |-|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)
            //BNPL.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)  [BMI.S <label>]
            //JBMI.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)  [BMI.S <label>]
            //JBNPL.S <label>                                 |A|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)  [BMI.S <label>]
            //BMI.L <label>                                   |-|--2346|-|-*---|-----|          |0110_101_111_111_111-{offset}
            //BNPL.L <label>                                  |A|--2346|-|-*---|-----|          |0110_101_111_111_111-{offset}        [BMI.L <label>]
          case 0b0110_101_111:
            irpBmisl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGE.W <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}
            //BNLT.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}        [BGE.W <label>]
            //JBGE.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}        [BGE.W <label>]
            //JBNLT.W <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}        [BGE.W <label>]
            //BGE.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)
            //BNLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)   [BGE.S <label>]
            //JBGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)   [BGE.S <label>]
            //JBNLT.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)   [BGE.S <label>]
            //JBLT.L <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_000_110-0100111011111001-{address}      [BGE.S (*)+8;JMP <label>]
            //JBNGE.L <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_000_000_110-0100111011111001-{address}      [BGE.S (*)+8;JMP <label>]
          case 0b0110_110_000:
            irpBgesw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGE.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_001_sss_sss
            //BNLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_001_sss_sss [BGE.S <label>]
            //JBGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_001_sss_sss [BGE.S <label>]
            //JBNLT.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_001_sss_sss [BGE.S <label>]
          case 0b0110_110_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGE.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_010_sss_sss
            //BNLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_010_sss_sss [BGE.S <label>]
            //JBGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_010_sss_sss [BGE.S <label>]
            //JBNLT.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_010_sss_sss [BGE.S <label>]
          case 0b0110_110_010:
            irpBges ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGE.S <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)
            //BNLT.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)  [BGE.S <label>]
            //JBGE.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)  [BGE.S <label>]
            //JBNLT.S <label>                                 |A|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)  [BGE.S <label>]
            //BGE.L <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_011_111_111-{offset}
            //BNLT.L <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_011_111_111-{offset}        [BGE.L <label>]
          case 0b0110_110_011:
            irpBgesl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLT.W <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}
            //BNGE.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}        [BLT.W <label>]
            //JBLT.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}        [BLT.W <label>]
            //JBNGE.W <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}        [BLT.W <label>]
            //BLT.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)
            //BNGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)   [BLT.S <label>]
            //JBLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)   [BLT.S <label>]
            //JBNGE.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)   [BLT.S <label>]
            //JBGE.L <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_000_110-0100111011111001-{address}      [BLT.S (*)+8;JMP <label>]
            //JBNLT.L <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_100_000_110-0100111011111001-{address}      [BLT.S (*)+8;JMP <label>]
          case 0b0110_110_100:
            irpBltsw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLT.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_101_sss_sss
            //BNGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_101_sss_sss [BLT.S <label>]
            //JBLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_101_sss_sss [BLT.S <label>]
            //JBNGE.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_101_sss_sss [BLT.S <label>]
          case 0b0110_110_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLT.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_110_sss_sss
            //BNGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_110_sss_sss [BLT.S <label>]
            //JBLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_110_sss_sss [BLT.S <label>]
            //JBNGE.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_110_sss_sss [BLT.S <label>]
          case 0b0110_110_110:
            irpBlts ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLT.S <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)
            //BNGE.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)  [BLT.S <label>]
            //JBLT.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)  [BLT.S <label>]
            //JBNGE.S <label>                                 |A|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)  [BLT.S <label>]
            //BLT.L <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_111_111_111-{offset}
            //BNGE.L <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_111_111_111-{offset}        [BLT.L <label>]
          case 0b0110_110_111:
            irpBltsl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGT.W <label>                                   |-|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}
            //BNLE.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}        [BGT.W <label>]
            //JBGT.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}        [BGT.W <label>]
            //JBNLE.W <label>                                 |A|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}        [BGT.W <label>]
            //BGT.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)
            //BNLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)   [BGT.S <label>]
            //JBGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)   [BGT.S <label>]
            //JBNLE.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)   [BGT.S <label>]
            //JBLE.L <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_000_110-0100111011111001-{address}      [BGT.S (*)+8;JMP <label>]
            //JBNGT.L <label>                                 |A|012346|-|-***-|-----|          |0110_111_000_000_110-0100111011111001-{address}      [BGT.S (*)+8;JMP <label>]
          case 0b0110_111_000:
            irpBgtsw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGT.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_001_sss_sss
            //BNLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_001_sss_sss [BGT.S <label>]
            //JBGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_001_sss_sss [BGT.S <label>]
            //JBNLE.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_001_sss_sss [BGT.S <label>]
          case 0b0110_111_001:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGT.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_010_sss_sss
            //BNLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_010_sss_sss [BGT.S <label>]
            //JBGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_010_sss_sss [BGT.S <label>]
            //JBNLE.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_010_sss_sss [BGT.S <label>]
          case 0b0110_111_010:
            irpBgts ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BGT.S <label>                                   |-|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)
            //BNLE.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)  [BGT.S <label>]
            //JBGT.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)  [BGT.S <label>]
            //JBNLE.S <label>                                 |A|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)  [BGT.S <label>]
            //BGT.L <label>                                   |-|--2346|-|-***-|-----|          |0110_111_011_111_111-{offset}
            //BNLE.L <label>                                  |A|--2346|-|-***-|-----|          |0110_111_011_111_111-{offset}        [BGT.L <label>]
          case 0b0110_111_011:
            irpBgtsl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLE.W <label>                                   |-|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}
            //BNGT.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}        [BLE.W <label>]
            //JBLE.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}        [BLE.W <label>]
            //JBNGT.W <label>                                 |A|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}        [BLE.W <label>]
            //BLE.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)
            //BNGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)   [BLE.S <label>]
            //JBLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)   [BLE.S <label>]
            //JBNGT.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)   [BLE.S <label>]
            //JBGT.L <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_000_110-0100111011111001-{address}      [BLE.S (*)+8;JMP <label>]
            //JBNLE.L <label>                                 |A|012346|-|-***-|-----|          |0110_111_100_000_110-0100111011111001-{address}      [BLE.S (*)+8;JMP <label>]
          case 0b0110_111_100:
            irpBlesw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLE.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_101_sss_sss
            //BNGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_101_sss_sss [BLE.S <label>]
            //JBLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_101_sss_sss [BLE.S <label>]
            //JBNGT.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_101_sss_sss [BLE.S <label>]
          case 0b0110_111_101:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLE.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_110_sss_sss
            //BNGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_110_sss_sss [BLE.S <label>]
            //JBLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_110_sss_sss [BLE.S <label>]
            //JBNGT.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_110_sss_sss [BLE.S <label>]
          case 0b0110_111_110:
            irpBles ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BLE.S <label>                                   |-|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)
            //BNGT.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)  [BLE.S <label>]
            //JBLE.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)  [BLE.S <label>]
            //JBNGT.S <label>                                 |A|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)  [BLE.S <label>]
            //BLE.L <label>                                   |-|--2346|-|-***-|-----|          |0110_111_111_111_111-{offset}
            //BNGT.L <label>                                  |A|--2346|-|-***-|-----|          |0110_111_111_111_111-{offset}        [BLE.L <label>]
          case 0b0110_111_111:
            irpBlesl ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //IOCS <name>                                     |A|012346|-|UUUUU|UUUUU|          |0111_000_0dd_ddd_ddd-0100111001001111        [MOVEQ.L #<data>,D0;TRAP #15]
            //MOVEQ.L #<data>,Dq                              |-|012346|-|-UUUU|-**00|          |0111_qqq_0dd_ddd_ddd
          case 0b0111_000_000:
          case 0b0111_000_001:
          case 0b0111_000_010:
          case 0b0111_000_011:
          case 0b0111_001_000:
          case 0b0111_001_001:
          case 0b0111_001_010:
          case 0b0111_001_011:
          case 0b0111_010_000:
          case 0b0111_010_001:
          case 0b0111_010_010:
          case 0b0111_010_011:
          case 0b0111_011_000:
          case 0b0111_011_001:
          case 0b0111_011_010:
          case 0b0111_011_011:
          case 0b0111_100_000:
          case 0b0111_100_001:
          case 0b0111_100_010:
          case 0b0111_100_011:
          case 0b0111_101_000:
          case 0b0111_101_001:
          case 0b0111_101_010:
          case 0b0111_101_011:
          case 0b0111_110_000:
          case 0b0111_110_001:
          case 0b0111_110_010:
          case 0b0111_110_011:
          case 0b0111_111_000:
          case 0b0111_111_001:
          case 0b0111_111_010:
          case 0b0111_111_011:
            irpMoveq ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MVS.B <ea>,Dq                                   |-|------|-|-UUUU|-**00|D M+-WXZPI|0111_qqq_100_mmm_rrr (ISA_B)
          case 0b0111_000_100:
          case 0b0111_001_100:
          case 0b0111_010_100:
          case 0b0111_011_100:
          case 0b0111_100_100:
          case 0b0111_101_100:
          case 0b0111_110_100:
          case 0b0111_111_100:
            irpMvsByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MVS.W <ea>,Dq                                   |-|------|-|-UUUU|-**00|D M+-WXZPI|0111_qqq_101_mmm_rrr (ISA_B)
          case 0b0111_000_101:
          case 0b0111_001_101:
          case 0b0111_010_101:
          case 0b0111_011_101:
          case 0b0111_100_101:
          case 0b0111_101_101:
          case 0b0111_110_101:
          case 0b0111_111_101:
            irpMvsWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MVZ.B <ea>,Dq                                   |-|------|-|-UUUU|-0*00|D M+-WXZPI|0111_qqq_110_mmm_rrr (ISA_B)
          case 0b0111_000_110:
          case 0b0111_001_110:
          case 0b0111_010_110:
          case 0b0111_011_110:
          case 0b0111_100_110:
          case 0b0111_101_110:
          case 0b0111_110_110:
          case 0b0111_111_110:
            irpMvzByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MVZ.W <ea>,Dq                                   |-|------|-|-UUUU|-0*00|D M+-WXZPI|0111_qqq_111_mmm_rrr (ISA_B)
          case 0b0111_000_111:
          case 0b0111_001_111:
          case 0b0111_010_111:
          case 0b0111_011_111:
          case 0b0111_100_111:
          case 0b0111_101_111:
          case 0b0111_110_111:
          case 0b0111_111_111:
            irpMvzWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //OR.B <ea>,Dq                                    |-|012346|-|-UUUU|-**00|D M+-WXZPI|1000_qqq_000_mmm_rrr
          case 0b1000_000_000:
          case 0b1000_001_000:
          case 0b1000_010_000:
          case 0b1000_011_000:
          case 0b1000_100_000:
          case 0b1000_101_000:
          case 0b1000_110_000:
          case 0b1000_111_000:
            irpOrToRegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //OR.W <ea>,Dq                                    |-|012346|-|-UUUU|-**00|D M+-WXZPI|1000_qqq_001_mmm_rrr
          case 0b1000_000_001:
          case 0b1000_001_001:
          case 0b1000_010_001:
          case 0b1000_011_001:
          case 0b1000_100_001:
          case 0b1000_101_001:
          case 0b1000_110_001:
          case 0b1000_111_001:
            irpOrToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //OR.L <ea>,Dq                                    |-|012346|-|-UUUU|-**00|D M+-WXZPI|1000_qqq_010_mmm_rrr
          case 0b1000_000_010:
          case 0b1000_001_010:
          case 0b1000_010_010:
          case 0b1000_011_010:
          case 0b1000_100_010:
          case 0b1000_101_010:
          case 0b1000_110_010:
          case 0b1000_111_010:
            irpOrToRegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //DIVU.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1000_qqq_011_mmm_rrr
          case 0b1000_000_011:
          case 0b1000_001_011:
          case 0b1000_010_011:
          case 0b1000_011_011:
          case 0b1000_100_011:
          case 0b1000_101_011:
          case 0b1000_110_011:
          case 0b1000_111_011:
            irpDivuWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SBCD.B Dr,Dq                                    |-|012346|-|UUUUU|*U*U*|          |1000_qqq_100_000_rrr
            //SBCD.B -(Ar),-(Aq)                              |-|012346|-|UUUUU|*U*U*|          |1000_qqq_100_001_rrr
            //OR.B Dq,<ea>                                    |-|012346|-|-UUUU|-**00|  M+-WXZ  |1000_qqq_100_mmm_rrr
          case 0b1000_000_100:
          case 0b1000_001_100:
          case 0b1000_010_100:
          case 0b1000_011_100:
          case 0b1000_100_100:
          case 0b1000_101_100:
          case 0b1000_110_100:
          case 0b1000_111_100:
            irpOrToMemByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //PACK Dr,Dq,#<data>                              |-|--2346|-|-----|-----|          |1000_qqq_101_000_rrr-{data}
            //PACK -(Ar),-(Aq),#<data>                        |-|--2346|-|-----|-----|          |1000_qqq_101_001_rrr-{data}
            //OR.W Dq,<ea>                                    |-|012346|-|-UUUU|-**00|  M+-WXZ  |1000_qqq_101_mmm_rrr
          case 0b1000_000_101:
          case 0b1000_001_101:
          case 0b1000_010_101:
          case 0b1000_011_101:
          case 0b1000_100_101:
          case 0b1000_101_101:
          case 0b1000_110_101:
          case 0b1000_111_101:
            irpOrToMemWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //UNPK Dr,Dq,#<data>                              |-|--2346|-|-----|-----|          |1000_qqq_110_000_rrr-{data}
            //UNPK -(Ar),-(Aq),#<data>                        |-|--2346|-|-----|-----|          |1000_qqq_110_001_rrr-{data}
            //OR.L Dq,<ea>                                    |-|012346|-|-UUUU|-**00|  M+-WXZ  |1000_qqq_110_mmm_rrr
          case 0b1000_000_110:
          case 0b1000_001_110:
          case 0b1000_010_110:
          case 0b1000_011_110:
          case 0b1000_100_110:
          case 0b1000_101_110:
          case 0b1000_110_110:
          case 0b1000_111_110:
            irpOrToMemLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //DIVS.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1000_qqq_111_mmm_rrr
          case 0b1000_000_111:
          case 0b1000_001_111:
          case 0b1000_010_111:
          case 0b1000_011_111:
          case 0b1000_100_111:
          case 0b1000_101_111:
          case 0b1000_110_111:
          case 0b1000_111_111:
            irpDivsWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUB.B <ea>,Dq                                   |-|012346|-|UUUUU|*****|D M+-WXZPI|1001_qqq_000_mmm_rrr
          case 0b1001_000_000:
          case 0b1001_001_000:
          case 0b1001_010_000:
          case 0b1001_011_000:
          case 0b1001_100_000:
          case 0b1001_101_000:
          case 0b1001_110_000:
          case 0b1001_111_000:
            irpSubToRegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUB.W <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1001_qqq_001_mmm_rrr
          case 0b1001_000_001:
          case 0b1001_001_001:
          case 0b1001_010_001:
          case 0b1001_011_001:
          case 0b1001_100_001:
          case 0b1001_101_001:
          case 0b1001_110_001:
          case 0b1001_111_001:
            irpSubToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUB.L <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1001_qqq_010_mmm_rrr
          case 0b1001_000_010:
          case 0b1001_001_010:
          case 0b1001_010_010:
          case 0b1001_011_010:
          case 0b1001_100_010:
          case 0b1001_101_010:
          case 0b1001_110_010:
          case 0b1001_111_010:
            irpSubToRegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBA.W <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_011_mmm_rrr
            //SUB.W <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_011_mmm_rrr [SUBA.W <ea>,Aq]
            //CLR.W Ar                                        |A|012346|-|-----|-----| A        |1001_rrr_011_001_rrr [SUBA.W Ar,Ar]
          case 0b1001_000_011:
          case 0b1001_001_011:
          case 0b1001_010_011:
          case 0b1001_011_011:
          case 0b1001_100_011:
          case 0b1001_101_011:
          case 0b1001_110_011:
          case 0b1001_111_011:
            irpSubaWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBX.B Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1001_qqq_100_000_rrr
            //SUBX.B -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1001_qqq_100_001_rrr
            //SUB.B Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1001_qqq_100_mmm_rrr
          case 0b1001_000_100:
          case 0b1001_001_100:
          case 0b1001_010_100:
          case 0b1001_011_100:
          case 0b1001_100_100:
          case 0b1001_101_100:
          case 0b1001_110_100:
          case 0b1001_111_100:
            irpSubToMemByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBX.W Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1001_qqq_101_000_rrr
            //SUBX.W -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1001_qqq_101_001_rrr
            //SUB.W Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1001_qqq_101_mmm_rrr
          case 0b1001_000_101:
          case 0b1001_001_101:
          case 0b1001_010_101:
          case 0b1001_011_101:
          case 0b1001_100_101:
          case 0b1001_101_101:
          case 0b1001_110_101:
          case 0b1001_111_101:
            irpSubToMemWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBX.L Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1001_qqq_110_000_rrr
            //SUBX.L -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1001_qqq_110_001_rrr
            //SUB.L Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1001_qqq_110_mmm_rrr
          case 0b1001_000_110:
          case 0b1001_001_110:
          case 0b1001_010_110:
          case 0b1001_011_110:
          case 0b1001_100_110:
          case 0b1001_101_110:
          case 0b1001_110_110:
          case 0b1001_111_110:
            irpSubToMemLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SUBA.L <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_111_mmm_rrr
            //SUB.L <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_111_mmm_rrr [SUBA.L <ea>,Aq]
            //CLR.L Ar                                        |A|012346|-|-----|-----| A        |1001_rrr_111_001_rrr [SUBA.L Ar,Ar]
          case 0b1001_000_111:
          case 0b1001_001_111:
          case 0b1001_010_111:
          case 0b1001_011_111:
          case 0b1001_100_111:
          case 0b1001_101_111:
          case 0b1001_110_111:
          case 0b1001_111_111:
            irpSubaLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //SXCALL <name>                                   |A|012346|-|UUUUU|*****|          |1010_0dd_ddd_ddd_ddd [ALINE #<data>]
          case 0b1010_000_000:
          case 0b1010_000_001:
          case 0b1010_000_010:
          case 0b1010_000_011:
          case 0b1010_000_100:
          case 0b1010_000_101:
          case 0b1010_000_110:
          case 0b1010_000_111:
          case 0b1010_001_000:
          case 0b1010_001_001:
          case 0b1010_001_010:
          case 0b1010_001_011:
          case 0b1010_001_100:
          case 0b1010_001_101:
          case 0b1010_001_110:
          case 0b1010_001_111:
          case 0b1010_010_000:
          case 0b1010_010_001:
          case 0b1010_010_010:
          case 0b1010_010_011:
          case 0b1010_010_100:
          case 0b1010_010_101:
          case 0b1010_010_110:
          case 0b1010_010_111:
          case 0b1010_011_000:
          case 0b1010_011_001:
          case 0b1010_011_010:
          case 0b1010_011_011:
          case 0b1010_011_100:
          case 0b1010_011_101:
          case 0b1010_011_110:
          case 0b1010_011_111:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ALINE #<data>                                   |-|012346|-|UUUUU|*****|          |1010_ddd_ddd_ddd_ddd (line 1010 emulator)
          case 0b1010_100_000:
          case 0b1010_100_001:
          case 0b1010_100_010:
          case 0b1010_100_011:
          case 0b1010_100_100:
          case 0b1010_100_101:
          case 0b1010_100_110:
          case 0b1010_100_111:
          case 0b1010_101_000:
          case 0b1010_101_001:
          case 0b1010_101_010:
          case 0b1010_101_011:
          case 0b1010_101_100:
          case 0b1010_101_101:
          case 0b1010_101_110:
          case 0b1010_101_111:
          case 0b1010_110_000:
          case 0b1010_110_001:
          case 0b1010_110_010:
          case 0b1010_110_011:
          case 0b1010_110_100:
          case 0b1010_110_101:
          case 0b1010_110_110:
          case 0b1010_110_111:
          case 0b1010_111_000:
          case 0b1010_111_001:
          case 0b1010_111_010:
          case 0b1010_111_011:
          case 0b1010_111_100:
          case 0b1010_111_101:
          case 0b1010_111_110:
          case 0b1010_111_111:
            irpAline ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMP.B <ea>,Dq                                   |-|012346|-|-UUUU|-****|D M+-WXZPI|1011_qqq_000_mmm_rrr
          case 0b1011_000_000:
          case 0b1011_001_000:
          case 0b1011_010_000:
          case 0b1011_011_000:
          case 0b1011_100_000:
          case 0b1011_101_000:
          case 0b1011_110_000:
          case 0b1011_111_000:
            irpCmpByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMP.W <ea>,Dq                                   |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_001_mmm_rrr
          case 0b1011_000_001:
          case 0b1011_001_001:
          case 0b1011_010_001:
          case 0b1011_011_001:
          case 0b1011_100_001:
          case 0b1011_101_001:
          case 0b1011_110_001:
          case 0b1011_111_001:
            irpCmpWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMP.L <ea>,Dq                                   |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_010_mmm_rrr
          case 0b1011_000_010:
          case 0b1011_001_010:
          case 0b1011_010_010:
          case 0b1011_011_010:
          case 0b1011_100_010:
          case 0b1011_101_010:
          case 0b1011_110_010:
          case 0b1011_111_010:
            irpCmpLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMPA.W <ea>,Aq                                  |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_011_mmm_rrr
            //CMP.W <ea>,Aq                                   |A|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_011_mmm_rrr [CMPA.W <ea>,Aq]
          case 0b1011_000_011:
          case 0b1011_001_011:
          case 0b1011_010_011:
          case 0b1011_011_011:
          case 0b1011_100_011:
          case 0b1011_101_011:
          case 0b1011_110_011:
          case 0b1011_111_011:
            irpCmpaWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EOR.B Dq,<ea>                                   |-|012346|-|-UUUU|-**00|D M+-WXZ  |1011_qqq_100_mmm_rrr
            //CMPM.B (Ar)+,(Aq)+                              |-|012346|-|-UUUU|-****|          |1011_qqq_100_001_rrr
          case 0b1011_000_100:
          case 0b1011_001_100:
          case 0b1011_010_100:
          case 0b1011_011_100:
          case 0b1011_100_100:
          case 0b1011_101_100:
          case 0b1011_110_100:
          case 0b1011_111_100:
            irpEorByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EOR.W Dq,<ea>                                   |-|012346|-|-UUUU|-**00|D M+-WXZ  |1011_qqq_101_mmm_rrr
            //CMPM.W (Ar)+,(Aq)+                              |-|012346|-|-UUUU|-****|          |1011_qqq_101_001_rrr
          case 0b1011_000_101:
          case 0b1011_001_101:
          case 0b1011_010_101:
          case 0b1011_011_101:
          case 0b1011_100_101:
          case 0b1011_101_101:
          case 0b1011_110_101:
          case 0b1011_111_101:
            irpEorWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EOR.L Dq,<ea>                                   |-|012346|-|-UUUU|-**00|D M+-WXZ  |1011_qqq_110_mmm_rrr
            //CMPM.L (Ar)+,(Aq)+                              |-|012346|-|-UUUU|-****|          |1011_qqq_110_001_rrr
          case 0b1011_000_110:
          case 0b1011_001_110:
          case 0b1011_010_110:
          case 0b1011_011_110:
          case 0b1011_100_110:
          case 0b1011_101_110:
          case 0b1011_110_110:
          case 0b1011_111_110:
            irpEorLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CMPA.L <ea>,Aq                                  |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_111_mmm_rrr
            //CMP.L <ea>,Aq                                   |A|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_111_mmm_rrr [CMPA.L <ea>,Aq]
          case 0b1011_000_111:
          case 0b1011_001_111:
          case 0b1011_010_111:
          case 0b1011_011_111:
          case 0b1011_100_111:
          case 0b1011_101_111:
          case 0b1011_110_111:
          case 0b1011_111_111:
            irpCmpaLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //AND.B <ea>,Dq                                   |-|012346|-|-UUUU|-**00|D M+-WXZPI|1100_qqq_000_mmm_rrr
          case 0b1100_000_000:
          case 0b1100_001_000:
          case 0b1100_010_000:
          case 0b1100_011_000:
          case 0b1100_100_000:
          case 0b1100_101_000:
          case 0b1100_110_000:
          case 0b1100_111_000:
            irpAndToRegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //AND.W <ea>,Dq                                   |-|012346|-|-UUUU|-**00|D M+-WXZPI|1100_qqq_001_mmm_rrr
          case 0b1100_000_001:
          case 0b1100_001_001:
          case 0b1100_010_001:
          case 0b1100_011_001:
          case 0b1100_100_001:
          case 0b1100_101_001:
          case 0b1100_110_001:
          case 0b1100_111_001:
            irpAndToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //AND.L <ea>,Dq                                   |-|012346|-|-UUUU|-**00|D M+-WXZPI|1100_qqq_010_mmm_rrr
          case 0b1100_000_010:
          case 0b1100_001_010:
          case 0b1100_010_010:
          case 0b1100_011_010:
          case 0b1100_100_010:
          case 0b1100_101_010:
          case 0b1100_110_010:
          case 0b1100_111_010:
            irpAndToRegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MULU.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1100_qqq_011_mmm_rrr
          case 0b1100_000_011:
          case 0b1100_001_011:
          case 0b1100_010_011:
          case 0b1100_011_011:
          case 0b1100_100_011:
          case 0b1100_101_011:
          case 0b1100_110_011:
          case 0b1100_111_011:
            irpMuluWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ABCD.B Dr,Dq                                    |-|012346|-|UUUUU|*U*U*|          |1100_qqq_100_000_rrr
            //ABCD.B -(Ar),-(Aq)                              |-|012346|-|UUUUU|*U*U*|          |1100_qqq_100_001_rrr
            //AND.B Dq,<ea>                                   |-|012346|-|-UUUU|-**00|  M+-WXZ  |1100_qqq_100_mmm_rrr
          case 0b1100_000_100:
          case 0b1100_001_100:
          case 0b1100_010_100:
          case 0b1100_011_100:
          case 0b1100_100_100:
          case 0b1100_101_100:
          case 0b1100_110_100:
          case 0b1100_111_100:
            irpAndToMemByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EXG.L Dq,Dr                                     |-|012346|-|-----|-----|          |1100_qqq_101_000_rrr
            //EXG.L Aq,Ar                                     |-|012346|-|-----|-----|          |1100_qqq_101_001_rrr
            //AND.W Dq,<ea>                                   |-|012346|-|-UUUU|-**00|  M+-WXZ  |1100_qqq_101_mmm_rrr
          case 0b1100_000_101:
          case 0b1100_001_101:
          case 0b1100_010_101:
          case 0b1100_011_101:
          case 0b1100_100_101:
          case 0b1100_101_101:
          case 0b1100_110_101:
          case 0b1100_111_101:
            irpAndToMemWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //EXG.L Dq,Ar                                     |-|012346|-|-----|-----|          |1100_qqq_110_001_rrr
            //AND.L Dq,<ea>                                   |-|012346|-|-UUUU|-**00|  M+-WXZ  |1100_qqq_110_mmm_rrr
          case 0b1100_000_110:
          case 0b1100_001_110:
          case 0b1100_010_110:
          case 0b1100_011_110:
          case 0b1100_100_110:
          case 0b1100_101_110:
          case 0b1100_110_110:
          case 0b1100_111_110:
            irpAndToMemLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MULS.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1100_qqq_111_mmm_rrr
          case 0b1100_000_111:
          case 0b1100_001_111:
          case 0b1100_010_111:
          case 0b1100_011_111:
          case 0b1100_100_111:
          case 0b1100_101_111:
          case 0b1100_110_111:
          case 0b1100_111_111:
            irpMulsWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADD.B <ea>,Dq                                   |-|012346|-|UUUUU|*****|D M+-WXZPI|1101_qqq_000_mmm_rrr
          case 0b1101_000_000:
          case 0b1101_001_000:
          case 0b1101_010_000:
          case 0b1101_011_000:
          case 0b1101_100_000:
          case 0b1101_101_000:
          case 0b1101_110_000:
          case 0b1101_111_000:
            irpAddToRegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADD.W <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1101_qqq_001_mmm_rrr
          case 0b1101_000_001:
          case 0b1101_001_001:
          case 0b1101_010_001:
          case 0b1101_011_001:
          case 0b1101_100_001:
          case 0b1101_101_001:
          case 0b1101_110_001:
          case 0b1101_111_001:
            irpAddToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADD.L <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1101_qqq_010_mmm_rrr
          case 0b1101_000_010:
          case 0b1101_001_010:
          case 0b1101_010_010:
          case 0b1101_011_010:
          case 0b1101_100_010:
          case 0b1101_101_010:
          case 0b1101_110_010:
          case 0b1101_111_010:
            irpAddToRegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDA.W <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_011_mmm_rrr
            //ADD.W <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_011_mmm_rrr [ADDA.W <ea>,Aq]
          case 0b1101_000_011:
          case 0b1101_001_011:
          case 0b1101_010_011:
          case 0b1101_011_011:
          case 0b1101_100_011:
          case 0b1101_101_011:
          case 0b1101_110_011:
          case 0b1101_111_011:
            irpAddaWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDX.B Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1101_qqq_100_000_rrr
            //ADDX.B -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1101_qqq_100_001_rrr
            //ADD.B Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1101_qqq_100_mmm_rrr
          case 0b1101_000_100:
          case 0b1101_001_100:
          case 0b1101_010_100:
          case 0b1101_011_100:
          case 0b1101_100_100:
          case 0b1101_101_100:
          case 0b1101_110_100:
          case 0b1101_111_100:
            irpAddToMemByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDX.W Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1101_qqq_101_000_rrr
            //ADDX.W -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1101_qqq_101_001_rrr
            //ADD.W Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1101_qqq_101_mmm_rrr
          case 0b1101_000_101:
          case 0b1101_001_101:
          case 0b1101_010_101:
          case 0b1101_011_101:
          case 0b1101_100_101:
          case 0b1101_101_101:
          case 0b1101_110_101:
          case 0b1101_111_101:
            irpAddToMemWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDX.L Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1101_qqq_110_000_rrr
            //ADDX.L -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1101_qqq_110_001_rrr
            //ADD.L Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1101_qqq_110_mmm_rrr
          case 0b1101_000_110:
          case 0b1101_001_110:
          case 0b1101_010_110:
          case 0b1101_011_110:
          case 0b1101_100_110:
          case 0b1101_101_110:
          case 0b1101_110_110:
          case 0b1101_111_110:
            irpAddToMemLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ADDA.L <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_111_mmm_rrr
            //ADD.L <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_111_mmm_rrr [ADDA.L <ea>,Aq]
          case 0b1101_000_111:
          case 0b1101_001_111:
          case 0b1101_010_111:
          case 0b1101_011_111:
          case 0b1101_100_111:
          case 0b1101_101_111:
          case 0b1101_110_111:
          case 0b1101_111_111:
            irpAddaLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASR.B #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_000_000_rrr
            //LSR.B #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_000_001_rrr
            //ROXR.B #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_000_010_rrr
            //ROR.B #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_000_011_rrr
            //ASR.B Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_000_100_rrr
            //LSR.B Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_000_101_rrr
            //ROXR.B Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_000_110_rrr
            //ROR.B Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_000_111_rrr
            //ASR.B Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_000_000_rrr [ASR.B #1,Dr]
            //LSR.B Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_000_001_rrr [LSR.B #1,Dr]
            //ROXR.B Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_000_010_rrr [ROXR.B #1,Dr]
            //ROR.B Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_000_011_rrr [ROR.B #1,Dr]
          case 0b1110_000_000:
          case 0b1110_001_000:
          case 0b1110_010_000:
          case 0b1110_011_000:
          case 0b1110_100_000:
          case 0b1110_101_000:
          case 0b1110_110_000:
          case 0b1110_111_000:
            irpXxrToRegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASR.W #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_001_000_rrr
            //LSR.W #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_001_001_rrr
            //ROXR.W #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_001_010_rrr
            //ROR.W #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_001_011_rrr
            //ASR.W Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_001_100_rrr
            //LSR.W Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_001_101_rrr
            //ROXR.W Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_001_110_rrr
            //ROR.W Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_001_111_rrr
            //ASR.W Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_001_000_rrr [ASR.W #1,Dr]
            //LSR.W Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_001_001_rrr [LSR.W #1,Dr]
            //ROXR.W Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_001_010_rrr [ROXR.W #1,Dr]
            //ROR.W Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_001_011_rrr [ROR.W #1,Dr]
          case 0b1110_000_001:
          case 0b1110_001_001:
          case 0b1110_010_001:
          case 0b1110_011_001:
          case 0b1110_100_001:
          case 0b1110_101_001:
          case 0b1110_110_001:
          case 0b1110_111_001:
            irpXxrToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASR.L #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_010_000_rrr
            //LSR.L #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_010_001_rrr
            //ROXR.L #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_010_010_rrr
            //ROR.L #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_010_011_rrr
            //ASR.L Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_010_100_rrr
            //LSR.L Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_010_101_rrr
            //ROXR.L Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_010_110_rrr
            //ROR.L Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_010_111_rrr
            //ASR.L Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_010_000_rrr [ASR.L #1,Dr]
            //LSR.L Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_010_001_rrr [LSR.L #1,Dr]
            //ROXR.L Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_010_010_rrr [ROXR.L #1,Dr]
            //ROR.L Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_010_011_rrr [ROR.L #1,Dr]
          case 0b1110_000_010:
          case 0b1110_001_010:
          case 0b1110_010_010:
          case 0b1110_011_010:
          case 0b1110_100_010:
          case 0b1110_101_010:
          case 0b1110_110_010:
          case 0b1110_111_010:
            irpXxrToRegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASR.W <ea>                                      |-|012346|-|UUUUU|***0*|  M+-WXZ  |1110_000_011_mmm_rrr
          case 0b1110_000_011:
            irpAsrToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASL.B #<data>,Dr                                |-|012346|-|UUUUU|*****|          |1110_qqq_100_000_rrr
            //LSL.B #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_100_001_rrr
            //ROXL.B #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_100_010_rrr
            //ROL.B #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_100_011_rrr
            //ASL.B Dq,Dr                                     |-|012346|-|UUUUU|*****|          |1110_qqq_100_100_rrr
            //LSL.B Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_100_101_rrr
            //ROXL.B Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_100_110_rrr
            //ROL.B Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_100_111_rrr
            //ASL.B Dr                                        |A|012346|-|UUUUU|*****|          |1110_001_100_000_rrr [ASL.B #1,Dr]
            //LSL.B Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_100_001_rrr [LSL.B #1,Dr]
            //ROXL.B Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_100_010_rrr [ROXL.B #1,Dr]
            //ROL.B Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_100_011_rrr [ROL.B #1,Dr]
          case 0b1110_000_100:
          case 0b1110_001_100:
          case 0b1110_010_100:
          case 0b1110_011_100:
          case 0b1110_100_100:
          case 0b1110_101_100:
          case 0b1110_110_100:
          case 0b1110_111_100:
            irpXxlToRegByte ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASL.W #<data>,Dr                                |-|012346|-|UUUUU|*****|          |1110_qqq_101_000_rrr
            //LSL.W #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_101_001_rrr
            //ROXL.W #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_101_010_rrr
            //ROL.W #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_101_011_rrr
            //ASL.W Dq,Dr                                     |-|012346|-|UUUUU|*****|          |1110_qqq_101_100_rrr
            //LSL.W Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_101_101_rrr
            //ROXL.W Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_101_110_rrr
            //ROL.W Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_101_111_rrr
            //ASL.W Dr                                        |A|012346|-|UUUUU|*****|          |1110_001_101_000_rrr [ASL.W #1,Dr]
            //LSL.W Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_101_001_rrr [LSL.W #1,Dr]
            //ROXL.W Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_101_010_rrr [ROXL.W #1,Dr]
            //ROL.W Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_101_011_rrr [ROL.W #1,Dr]
          case 0b1110_000_101:
          case 0b1110_001_101:
          case 0b1110_010_101:
          case 0b1110_011_101:
          case 0b1110_100_101:
          case 0b1110_101_101:
          case 0b1110_110_101:
          case 0b1110_111_101:
            irpXxlToRegWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASL.L #<data>,Dr                                |-|012346|-|UUUUU|*****|          |1110_qqq_110_000_rrr
            //LSL.L #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_110_001_rrr
            //ROXL.L #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_110_010_rrr
            //ROL.L #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_110_011_rrr
            //ASL.L Dq,Dr                                     |-|012346|-|UUUUU|*****|          |1110_qqq_110_100_rrr
            //LSL.L Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_110_101_rrr
            //ROXL.L Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_110_110_rrr
            //ROL.L Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_110_111_rrr
            //ASL.L Dr                                        |A|012346|-|UUUUU|*****|          |1110_001_110_000_rrr [ASL.L #1,Dr]
            //LSL.L Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_110_001_rrr [LSL.L #1,Dr]
            //ROXL.L Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_110_010_rrr [ROXL.L #1,Dr]
            //ROL.L Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_110_011_rrr [ROL.L #1,Dr]
          case 0b1110_000_110:
          case 0b1110_001_110:
          case 0b1110_010_110:
          case 0b1110_011_110:
          case 0b1110_100_110:
          case 0b1110_101_110:
          case 0b1110_110_110:
          case 0b1110_111_110:
            irpXxlToRegLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ASL.W <ea>                                      |-|012346|-|UUUUU|*****|  M+-WXZ  |1110_000_111_mmm_rrr
          case 0b1110_000_111:
            irpAslToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //LSR.W <ea>                                      |-|012346|-|UUUUU|*0*0*|  M+-WXZ  |1110_001_011_mmm_rrr
          case 0b1110_001_011:
            irpLsrToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //LSL.W <ea>                                      |-|012346|-|UUUUU|***0*|  M+-WXZ  |1110_001_111_mmm_rrr
          case 0b1110_001_111:
            irpLslToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ROXR.W <ea>                                     |-|012346|-|*UUUU|***0*|  M+-WXZ  |1110_010_011_mmm_rrr
          case 0b1110_010_011:
            irpRoxrToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ROXL.W <ea>                                     |-|012346|-|*UUUU|***0*|  M+-WXZ  |1110_010_111_mmm_rrr
          case 0b1110_010_111:
            irpRoxlToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ROR.W <ea>                                      |-|012346|-|-UUUU|-**0*|  M+-WXZ  |1110_011_011_mmm_rrr
          case 0b1110_011_011:
            irpRorToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //ROL.W <ea>                                      |-|012346|-|-UUUU|-**0*|  M+-WXZ  |1110_011_111_mmm_rrr
          case 0b1110_011_111:
            irpRolToMem ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFTST <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-00000ooooo0wwwww
            //BFTST <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-00000ooooo100www
            //BFTST <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-0000100ooo0wwwww
            //BFTST <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-0000100ooo100www
          case 0b1110_100_011:
            irpBftst ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFEXTU <ea>{#o:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn0ooooo0wwwww
            //BFEXTU <ea>{#o:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn0ooooo100www
            //BFEXTU <ea>{Do:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn100ooo0wwwww
            //BFEXTU <ea>{Do:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn100ooo100www
          case 0b1110_100_111:
            irpBfextu ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFCHG <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-00000ooooo0wwwww
            //BFCHG <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-00000ooooo100www
            //BFCHG <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-0000100ooo0wwwww
            //BFCHG <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-0000100ooo100www
          case 0b1110_101_011:
            irpBfchg ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFEXTS <ea>{#o:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn0ooooo0wwwww
            //BFEXTS <ea>{#o:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn0ooooo100www
            //BFEXTS <ea>{Do:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn100ooo0wwwww
            //BFEXTS <ea>{Do:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn100ooo100www
          case 0b1110_101_111:
            irpBfexts ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFCLR <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-00000ooooo0wwwww
            //BFCLR <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-00000ooooo100www
            //BFCLR <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-0000100ooo0wwwww
            //BFCLR <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-0000100ooo100www
          case 0b1110_110_011:
            irpBfclr ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFFFO <ea>{#o:#w},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn0ooooo0wwwww
            //BFFFO <ea>{#o:Dw},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn0ooooo100www
            //BFFFO <ea>{Do:#w},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn100ooo0wwwww
            //BFFFO <ea>{Do:Dw},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn100ooo100www
          case 0b1110_110_111:
            irpBfffo ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFSET <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-00000ooooo0wwwww
            //BFSET <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-00000ooooo100www
            //BFSET <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-0000100ooo0wwwww
            //BFSET <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-0000100ooo100www
          case 0b1110_111_011:
            irpBfset ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //BFINS Dn,<ea>{#o:#w}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn0ooooo0wwwww
            //BFINS Dn,<ea>{#o:Dw}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn0ooooo100www
            //BFINS Dn,<ea>{Do:#w}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn100ooo0wwwww
            //BFINS Dn,<ea>{Do:Dw}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn100ooo100www
          case 0b1110_111_111:
            irpBfins ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FTST.X FPm                                      |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmm0000111010
            //FMOVE.X FPm,FPn                                 |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000000
            //FINT.X FPm,FPn                                  |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000001
            //FSINH.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000010
            //FINTRZ.X FPm,FPn                                |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000011
            //FSQRT.X FPm,FPn                                 |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000100
            //FLOGNP1.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000110
            //FETOXM1.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001000
            //FTANH.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001001
            //FATAN.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001010
            //FASIN.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001100
            //FATANH.X FPm,FPn                                |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001101
            //FSIN.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001110
            //FTAN.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001111
            //FETOX.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010000
            //FTWOTOX.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010001
            //FTENTOX.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010010
            //FLOGN.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010100
            //FLOG10.X FPm,FPn                                |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010101
            //FLOG2.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010110
            //FABS.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011000
            //FCOSH.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011001
            //FNEG.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011010
            //FACOS.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011100
            //FCOS.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011101
            //FGETEXP.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011110
            //FGETMAN.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011111
            //FDIV.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100000
            //FMOD.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100001
            //FADD.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100010
            //FMUL.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100011
            //FSGLDIV.X FPm,FPn                               |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100100
            //FREM.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100101
            //FSCALE.X FPm,FPn                                |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100110
            //FSGLMUL.X FPm,FPn                               |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100111
            //FSUB.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0101000
            //FCMP.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0111000
            //FSMOVE.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000000
            //FSSQRT.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000001
            //FDMOVE.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000100
            //FDSQRT.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000101
            //FSABS.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011000
            //FSNEG.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011010
            //FDABS.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011100
            //FDNEG.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011110
            //FSDIV.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100000
            //FSADD.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100010
            //FSMUL.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100011
            //FDDIV.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100100
            //FDADD.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100110
            //FDMUL.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100111
            //FSSUB.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1101000
            //FDSUB.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1101100
            //FSINCOS.X FPm,FPc:FPs                           |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmsss0110ccc
            //FMOVECR.X #ccc,FPn                              |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-010111nnn0cccccc
            //FMOVE.L FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011000nnn0000000
            //FMOVE.S FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011001nnn0000000
            //FMOVE.W FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011100nnn0000000
            //FMOVE.B FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011110nnn0000000
            //FMOVE.L FPIAR,<ea>                              |-|--CC46|-|-----|-----|DAM+-WXZ  |1111_001_000_mmm_rrr-1010010000000000
            //FMOVEM.L FPIAR,<ea>                             |-|--CC46|-|-----|-----|DAM+-WXZ  |1111_001_000_mmm_rrr-1010010000000000
            //FMOVE.L FPSR,<ea>                               |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1010100000000000
            //FMOVEM.L FPSR,<ea>                              |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1010100000000000
            //FMOVE.L FPCR,<ea>                               |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1011000000000000
            //FMOVEM.L FPCR,<ea>                              |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1011000000000000
            //FTST.L <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0100000000111010
            //FMOVE.L <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000000
            //FINT.L <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000001
            //FSINH.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000010
            //FINTRZ.L <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000011
            //FSQRT.L <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000100
            //FLOGNP1.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000110
            //FETOXM1.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001000
            //FTANH.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001001
            //FATAN.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001010
            //FASIN.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001100
            //FATANH.L <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001101
            //FSIN.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001110
            //FTAN.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001111
            //FETOX.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010000
            //FTWOTOX.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010001
            //FTENTOX.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010010
            //FLOGN.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010100
            //FLOG10.L <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010101
            //FLOG2.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010110
            //FABS.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011000
            //FCOSH.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011001
            //FNEG.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011010
            //FACOS.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011100
            //FCOS.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011101
            //FGETEXP.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011110
            //FGETMAN.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011111
            //FDIV.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100000
            //FMOD.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100001
            //FADD.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100010
            //FMUL.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100011
            //FSGLDIV.L <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100100
            //FREM.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100101
            //FSCALE.L <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100110
            //FSGLMUL.L <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100111
            //FSUB.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0101000
            //FCMP.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0111000
            //FSMOVE.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000000
            //FSSQRT.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000001
            //FDMOVE.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000100
            //FDSQRT.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000101
            //FSABS.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011000
            //FSNEG.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011010
            //FDABS.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011100
            //FDNEG.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011110
            //FSDIV.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100000
            //FSADD.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100010
            //FSMUL.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100011
            //FDDIV.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100100
            //FDADD.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100110
            //FDMUL.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100111
            //FSSUB.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1101000
            //FDSUB.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1101100
            //FSINCOS.L <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000sss0110ccc
            //FTST.S <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0100010000111010
            //FMOVE.S <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000000
            //FINT.S <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000001
            //FSINH.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000010
            //FINTRZ.S <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000011
            //FSQRT.S <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000100
            //FLOGNP1.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000110
            //FETOXM1.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001000
            //FTANH.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001001
            //FATAN.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001010
            //FASIN.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001100
            //FATANH.S <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001101
            //FSIN.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001110
            //FTAN.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001111
            //FETOX.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010000
            //FTWOTOX.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010001
            //FTENTOX.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010010
            //FLOGN.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010100
            //FLOG10.S <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010101
            //FLOG2.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010110
            //FABS.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011000
            //FCOSH.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011001
            //FNEG.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011010
            //FACOS.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011100
            //FCOS.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011101
            //FGETEXP.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011110
            //FGETMAN.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011111
            //FDIV.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100000
            //FMOD.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100001
            //FADD.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100010
            //FMUL.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100011
            //FSGLDIV.S <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100100
            //FREM.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100101
            //FSCALE.S <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100110
            //FSGLMUL.S <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100111
            //FSUB.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0101000
            //FCMP.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0111000
            //FSMOVE.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000000
            //FSSQRT.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000001
            //FDMOVE.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000100
            //FDSQRT.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000101
            //FSABS.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011000
            //FSNEG.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011010
            //FDABS.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011100
            //FDNEG.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011110
            //FSDIV.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100000
            //FSADD.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100010
            //FSMUL.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100011
            //FDDIV.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100100
            //FDADD.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100110
            //FDMUL.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100111
            //FSSUB.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1101000
            //FDSUB.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1101100
            //FSINCOS.S <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001sss0110ccc
            //FTST.W <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0101000000111010
            //FMOVE.W <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000000
            //FINT.W <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000001
            //FSINH.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000010
            //FINTRZ.W <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000011
            //FSQRT.W <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000100
            //FLOGNP1.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000110
            //FETOXM1.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001000
            //FTANH.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001001
            //FATAN.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001010
            //FASIN.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001100
            //FATANH.W <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001101
            //FSIN.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001110
            //FTAN.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001111
            //FETOX.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010000
            //FTWOTOX.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010001
            //FTENTOX.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010010
            //FLOGN.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010100
            //FLOG10.W <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010101
            //FLOG2.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010110
            //FABS.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011000
            //FCOSH.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011001
            //FNEG.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011010
            //FACOS.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011100
            //FCOS.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011101
            //FGETEXP.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011110
            //FGETMAN.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011111
            //FDIV.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100000
            //FMOD.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100001
            //FADD.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100010
            //FMUL.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100011
            //FSGLDIV.W <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100100
            //FREM.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100101
            //FSCALE.W <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100110
            //FSGLMUL.W <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100111
            //FSUB.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0101000
            //FCMP.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0111000
            //FSMOVE.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000000
            //FSSQRT.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000001
            //FDMOVE.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000100
            //FDSQRT.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000101
            //FSABS.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011000
            //FSNEG.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011010
            //FDABS.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011100
            //FDNEG.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011110
            //FSDIV.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100000
            //FSADD.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100010
            //FSMUL.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100011
            //FDDIV.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100100
            //FDADD.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100110
            //FDMUL.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100111
            //FSSUB.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1101000
            //FDSUB.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1101100
            //FSINCOS.W <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100sss0110ccc
            //FTST.B <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0101100000111010
            //FMOVE.B <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000000
            //FINT.B <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000001
            //FSINH.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000010
            //FINTRZ.B <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000011
            //FSQRT.B <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000100
            //FLOGNP1.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000110
            //FETOXM1.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001000
            //FTANH.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001001
            //FATAN.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001010
            //FASIN.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001100
            //FATANH.B <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001101
            //FSIN.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001110
            //FTAN.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001111
            //FETOX.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010000
            //FTWOTOX.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010001
            //FTENTOX.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010010
            //FLOGN.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010100
            //FLOG10.B <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010101
            //FLOG2.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010110
            //FABS.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011000
            //FCOSH.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011001
            //FNEG.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011010
            //FACOS.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011100
            //FCOS.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011101
            //FGETEXP.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011110
            //FGETMAN.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011111
            //FDIV.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100000
            //FMOD.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100001
            //FADD.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100010
            //FMUL.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100011
            //FSGLDIV.B <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100100
            //FREM.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100101
            //FSCALE.B <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100110
            //FSGLMUL.B <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100111
            //FSUB.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0101000
            //FCMP.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0111000
            //FSMOVE.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000000
            //FSSQRT.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000001
            //FDMOVE.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000100
            //FDSQRT.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000101
            //FSABS.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011000
            //FSNEG.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011010
            //FDABS.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011100
            //FDNEG.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011110
            //FSDIV.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100000
            //FSADD.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100010
            //FSMUL.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100011
            //FDDIV.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100100
            //FDADD.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100110
            //FDMUL.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100111
            //FSSUB.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1101000
            //FDSUB.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1101100
            //FSINCOS.B <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110sss0110ccc
            //FMOVE.L <ea>,FPIAR                              |-|--CC46|-|-----|-----|DAM+-WXZPI|1111_001_000_mmm_rrr-1000010000000000
            //FMOVEM.L <ea>,FPIAR                             |-|--CC46|-|-----|-----|DAM+-WXZPI|1111_001_000_mmm_rrr-1000010000000000
            //FMOVE.L <ea>,FPSR                               |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1000100000000000
            //FMOVEM.L <ea>,FPSR                              |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1000100000000000
            //FMOVE.L <ea>,FPCR                               |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1001000000000000
            //FMOVEM.L <ea>,FPCR                              |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1001000000000000
            //FMOVE.X FPn,<ea>                                |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011010nnn0000000
            //FMOVE.P FPn,<ea>{#k}                            |-|--CCSS|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011011nnnkkkkkkk
            //FMOVE.D FPn,<ea>                                |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011101nnn0000000
            //FMOVE.P FPn,<ea>{Dk}                            |-|--CCSS|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011111nnnkkk0000
            //FMOVEM.L FPSR/FPIAR,<ea>                        |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1010110000000000
            //FMOVEM.L FPCR/FPIAR,<ea>                        |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1011010000000000
            //FMOVEM.L FPCR/FPSR,<ea>                         |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1011100000000000
            //FMOVEM.L FPCR/FPSR/FPIAR,<ea>                   |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1011110000000000
            //FMOVEM.X #<data>,<ea>                           |-|--CC46|-|-----|-----|  M  WXZ  |1111_001_000_mmm_rrr-11110000dddddddd
            //FMOVEM.X <list>,<ea>                            |-|--CC46|-|-----|-----|  M  WXZ  |1111_001_000_mmm_rrr-11110000llllllll
            //FMOVEM.X Dl,<ea>                                |-|--CC4S|-|-----|-----|  M  WXZ  |1111_001_000_mmm_rrr-111110000lll0000
            //FMOVEM.L <ea>,FPSR/FPIAR                        |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1000110000000000
            //FMOVEM.L <ea>,FPCR/FPIAR                        |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1001010000000000
            //FMOVEM.L <ea>,FPCR/FPSR                         |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1001100000000000
            //FMOVEM.L <ea>,FPCR/FPSR/FPIAR                   |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1001110000000000
            //FMOVEM.X <ea>,#<data>                           |-|--CC46|-|-----|-----|  M+ WXZP |1111_001_000_mmm_rrr-11010000dddddddd
            //FMOVEM.X <ea>,<list>                            |-|--CC46|-|-----|-----|  M+ WXZP |1111_001_000_mmm_rrr-11010000llllllll
            //FMOVEM.X <ea>,Dl                                |-|--CC4S|-|-----|-----|  M+ WXZP |1111_001_000_mmm_rrr-110110000lll0000
            //FTST.X <ea>                                     |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-0100100000111010
            //FMOVE.X <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000000
            //FINT.X <ea>,FPn                                 |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000001
            //FSINH.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000010
            //FINTRZ.X <ea>,FPn                               |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000011
            //FSQRT.X <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000100
            //FLOGNP1.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000110
            //FETOXM1.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001000
            //FTANH.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001001
            //FATAN.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001010
            //FASIN.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001100
            //FATANH.X <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001101
            //FSIN.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001110
            //FTAN.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001111
            //FETOX.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010000
            //FTWOTOX.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010001
            //FTENTOX.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010010
            //FLOGN.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010100
            //FLOG10.X <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010101
            //FLOG2.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010110
            //FABS.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011000
            //FCOSH.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011001
            //FNEG.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011010
            //FACOS.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011100
            //FCOS.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011101
            //FGETEXP.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011110
            //FGETMAN.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011111
            //FDIV.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100000
            //FMOD.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100001
            //FADD.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100010
            //FMUL.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100011
            //FSGLDIV.X <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100100
            //FREM.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100101
            //FSCALE.X <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100110
            //FSGLMUL.X <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100111
            //FSUB.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0101000
            //FCMP.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0111000
            //FSMOVE.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000000
            //FSSQRT.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000001
            //FDMOVE.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000100
            //FDSQRT.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000101
            //FSABS.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011000
            //FSNEG.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011010
            //FDABS.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011100
            //FDNEG.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011110
            //FSDIV.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100000
            //FSADD.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100010
            //FSMUL.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100011
            //FDDIV.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100100
            //FDADD.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100110
            //FDMUL.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100111
            //FSSUB.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1101000
            //FDSUB.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1101100
            //FSINCOS.X <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010sss0110ccc
            //FTST.P <ea>                                     |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-0100110000111010
            //FMOVE.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000000
            //FINT.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000001
            //FSINH.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000010
            //FINTRZ.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000011
            //FSQRT.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000100
            //FLOGNP1.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000110
            //FETOXM1.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001000
            //FTANH.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001001
            //FATAN.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001010
            //FASIN.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001100
            //FATANH.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001101
            //FSIN.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001110
            //FTAN.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001111
            //FETOX.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010000
            //FTWOTOX.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010001
            //FTENTOX.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010010
            //FLOGN.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010100
            //FLOG10.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010101
            //FLOG2.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010110
            //FABS.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011000
            //FCOSH.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011001
            //FNEG.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011010
            //FACOS.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011100
            //FCOS.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011101
            //FGETEXP.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011110
            //FGETMAN.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011111
            //FDIV.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100000
            //FMOD.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100001
            //FADD.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100010
            //FMUL.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100011
            //FSGLDIV.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100100
            //FREM.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100101
            //FSCALE.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100110
            //FSGLMUL.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100111
            //FSUB.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0101000
            //FCMP.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0111000
            //FSMOVE.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000000
            //FSSQRT.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000001
            //FDMOVE.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000100
            //FDSQRT.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000101
            //FSABS.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011000
            //FSNEG.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011010
            //FDABS.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011100
            //FDNEG.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011110
            //FSDIV.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100000
            //FSADD.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100010
            //FSMUL.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100011
            //FDDIV.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100100
            //FDADD.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100110
            //FDMUL.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100111
            //FSSUB.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1101000
            //FDSUB.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1101100
            //FSINCOS.P <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011sss0110ccc
            //FTST.D <ea>                                     |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-0101010000111010
            //FMOVE.D <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000000
            //FINT.D <ea>,FPn                                 |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000001
            //FSINH.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000010
            //FINTRZ.D <ea>,FPn                               |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000011
            //FSQRT.D <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000100
            //FLOGNP1.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000110
            //FETOXM1.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001000
            //FTANH.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001001
            //FATAN.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001010
            //FASIN.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001100
            //FATANH.D <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001101
            //FSIN.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001110
            //FTAN.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001111
            //FETOX.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010000
            //FTWOTOX.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010001
            //FTENTOX.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010010
            //FLOGN.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010100
            //FLOG10.D <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010101
            //FLOG2.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010110
            //FABS.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011000
            //FCOSH.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011001
            //FNEG.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011010
            //FACOS.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011100
            //FCOS.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011101
            //FGETEXP.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011110
            //FGETMAN.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011111
            //FDIV.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100000
            //FMOD.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100001
            //FADD.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100010
            //FMUL.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100011
            //FSGLDIV.D <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100100
            //FREM.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100101
            //FSCALE.D <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100110
            //FSGLMUL.D <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100111
            //FSUB.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0101000
            //FCMP.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0111000
            //FSMOVE.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000000
            //FSSQRT.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000001
            //FDMOVE.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000100
            //FDSQRT.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000101
            //FSABS.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011000
            //FSNEG.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011010
            //FDABS.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011100
            //FDNEG.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011110
            //FSDIV.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100000
            //FSADD.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100010
            //FSMUL.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100011
            //FDDIV.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100100
            //FDADD.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100110
            //FDMUL.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100111
            //FSSUB.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1101000
            //FDSUB.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1101100
            //FSINCOS.D <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101sss0110ccc
            //FMOVEM.X #<data>,-(Ar)                          |-|--CC46|-|-----|-----|    -     |1111_001_000_100_rrr-11100000dddddddd
            //FMOVEM.X <list>,-(Ar)                           |-|--CC46|-|-----|-----|    -     |1111_001_000_100_rrr-11100000llllllll
            //FMOVEM.X Dl,-(Ar)                               |-|--CC4S|-|-----|-----|    -     |1111_001_000_100_rrr-111010000lll0000
            //FMOVEM.L #<data>,#<data>,FPSR/FPIAR             |-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1000110000000000-{data}
            //FMOVEM.L #<data>,#<data>,FPCR/FPIAR             |-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1001010000000000-{data}
            //FMOVEM.L #<data>,#<data>,FPCR/FPSR              |-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1001100000000000-{data}
            //FMOVEM.L #<data>,#<data>,#<data>,FPCR/FPSR/FPIAR|-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1001110000000000-{data}
          case 0b1111_001_000:
            irpFgen ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FSF.B <ea>                                      |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000000
            //FSEQ.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000001
            //FSOGT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000010
            //FSOGE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000011
            //FSOLT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000100
            //FSOLE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000101
            //FSOGL.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000110
            //FSOR.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000111
            //FSUN.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001000
            //FSUEQ.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001001
            //FSUGT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001010
            //FSUGE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001011
            //FSULT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001100
            //FSULE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001101
            //FSNE.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001110
            //FST.B <ea>                                      |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001111
            //FSSF.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010000
            //FSSEQ.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010001
            //FSGT.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010010
            //FSGE.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010011
            //FSLT.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010100
            //FSLE.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010101
            //FSGL.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010110
            //FSGLE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010111
            //FSNGLE.B <ea>                                   |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011000
            //FSNGL.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011001
            //FSNLE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011010
            //FSNLT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011011
            //FSNGE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011100
            //FSNGT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011101
            //FSSNE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011110
            //FSST.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011111
            //FDBF Dr,<label>                                 |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000000-{offset}
            //FDBRA Dr,<label>                                |A|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000000-{offset}       [FDBF Dr,<label>]
            //FDBEQ Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000001-{offset}
            //FDBOGT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000010-{offset}
            //FDBOGE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000011-{offset}
            //FDBOLT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000100-{offset}
            //FDBOLE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000101-{offset}
            //FDBOGL Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000110-{offset}
            //FDBOR Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000111-{offset}
            //FDBUN Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001000-{offset}
            //FDBUEQ Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001001-{offset}
            //FDBUGT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001010-{offset}
            //FDBUGE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001011-{offset}
            //FDBULT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001100-{offset}
            //FDBULE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001101-{offset}
            //FDBNE Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001110-{offset}
            //FDBT Dr,<label>                                 |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001111-{offset}
            //FDBSF Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010000-{offset}
            //FDBSEQ Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010001-{offset}
            //FDBGT Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010010-{offset}
            //FDBGE Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010011-{offset}
            //FDBLT Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010100-{offset}
            //FDBLE Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010101-{offset}
            //FDBGL Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010110-{offset}
            //FDBGLE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010111-{offset}
            //FDBNGLE Dr,<label>                              |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011000-{offset}
            //FDBNGL Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011001-{offset}
            //FDBNLE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011010-{offset}
            //FDBNLT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011011-{offset}
            //FDBNGE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011100-{offset}
            //FDBNGT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011101-{offset}
            //FDBSNE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011110-{offset}
            //FDBST Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011111-{offset}
            //FTRAPF.W #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000000-{data}
            //FTRAPEQ.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000001-{data}
            //FTRAPOGT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000010-{data}
            //FTRAPOGE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000011-{data}
            //FTRAPOLT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000100-{data}
            //FTRAPOLE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000101-{data}
            //FTRAPOGL.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000110-{data}
            //FTRAPOR.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000111-{data}
            //FTRAPUN.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001000-{data}
            //FTRAPUEQ.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001001-{data}
            //FTRAPUGT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001010-{data}
            //FTRAPUGE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001011-{data}
            //FTRAPULT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001100-{data}
            //FTRAPULE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001101-{data}
            //FTRAPNE.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001110-{data}
            //FTRAPT.W #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001111-{data}
            //FTRAPSF.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010000-{data}
            //FTRAPSEQ.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010001-{data}
            //FTRAPGT.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010010-{data}
            //FTRAPGE.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010011-{data}
            //FTRAPLT.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010100-{data}
            //FTRAPLE.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010101-{data}
            //FTRAPGL.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010110-{data}
            //FTRAPGLE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010111-{data}
            //FTRAPNGLE.W #<data>                             |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011000-{data}
            //FTRAPNGL.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011001-{data}
            //FTRAPNLE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011010-{data}
            //FTRAPNLT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011011-{data}
            //FTRAPNGE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011100-{data}
            //FTRAPNGT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011101-{data}
            //FTRAPSNE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011110-{data}
            //FTRAPST.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011111-{data}
            //FTRAPF.L #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000000-{data}
            //FTRAPEQ.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000001-{data}
            //FTRAPOGT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000010-{data}
            //FTRAPOGE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000011-{data}
            //FTRAPOLT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000100-{data}
            //FTRAPOLE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000101-{data}
            //FTRAPOGL.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000110-{data}
            //FTRAPOR.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000111-{data}
            //FTRAPUN.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001000-{data}
            //FTRAPUEQ.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001001-{data}
            //FTRAPUGT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001010-{data}
            //FTRAPUGE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001011-{data}
            //FTRAPULT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001100-{data}
            //FTRAPULE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001101-{data}
            //FTRAPNE.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001110-{data}
            //FTRAPT.L #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001111-{data}
            //FTRAPSF.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010000-{data}
            //FTRAPSEQ.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010001-{data}
            //FTRAPGT.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010010-{data}
            //FTRAPGE.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010011-{data}
            //FTRAPLT.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010100-{data}
            //FTRAPLE.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010101-{data}
            //FTRAPGL.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010110-{data}
            //FTRAPGLE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010111-{data}
            //FTRAPNGLE.L #<data>                             |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011000-{data}
            //FTRAPNGL.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011001-{data}
            //FTRAPNLE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011010-{data}
            //FTRAPNLT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011011-{data}
            //FTRAPNGE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011100-{data}
            //FTRAPNGT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011101-{data}
            //FTRAPSNE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011110-{data}
            //FTRAPST.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011111-{data}
            //FTRAPF                                          |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000000
            //FTRAPEQ                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000001
            //FTRAPOGT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000010
            //FTRAPOGE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000011
            //FTRAPOLT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000100
            //FTRAPOLE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000101
            //FTRAPOGL                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000110
            //FTRAPOR                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000111
            //FTRAPUN                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001000
            //FTRAPUEQ                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001001
            //FTRAPUGT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001010
            //FTRAPUGE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001011
            //FTRAPULT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001100
            //FTRAPULE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001101
            //FTRAPNE                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001110
            //FTRAPT                                          |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001111
            //FTRAPSF                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010000
            //FTRAPSEQ                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010001
            //FTRAPGT                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010010
            //FTRAPGE                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010011
            //FTRAPLT                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010100
            //FTRAPLE                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010101
            //FTRAPGL                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010110
            //FTRAPGLE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010111
            //FTRAPNGLE                                       |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011000
            //FTRAPNGL                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011001
            //FTRAPNLE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011010
            //FTRAPNLT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011011
            //FTRAPNGE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011100
            //FTRAPNGT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011101
            //FTRAPSNE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011110
            //FTRAPST                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011111
          case 0b1111_001_001:
            irpFscc ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FNOP                                            |A|--CC46|-|-----|-----|          |1111_001_010_000_000-0000000000000000        [FBF.W (*)+2]
            //FBF.W <label>                                   |-|--CC46|-|-----|-----|          |1111_001_010_000_000-{offset}
            //FBEQ.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_000_001-{offset}
            //FBOGT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_010-{offset}
            //FBOGE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_011-{offset}
            //FBOLT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_100-{offset}
            //FBOLE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_101-{offset}
            //FBOGL.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_110-{offset}
            //FBOR.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_000_111-{offset}
            //FBUN.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_001_000-{offset}
            //FBUEQ.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_001-{offset}
            //FBUGT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_010-{offset}
            //FBUGE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_011-{offset}
            //FBULT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_100-{offset}
            //FBULE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_101-{offset}
            //FBNE.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_001_110-{offset}
            //FBT.W <label>                                   |-|--CC46|-|-----|-----|          |1111_001_010_001_111-{offset}
            //FBRA.W <label>                                  |A|--CC46|-|-----|-----|          |1111_001_010_001_111-{offset}        [FBT.W <label>]
            //FBSF.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_000-{offset}
            //FBSEQ.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_010_001-{offset}
            //FBGT.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_010-{offset}
            //FBGE.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_011-{offset}
            //FBLT.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_100-{offset}
            //FBLE.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_101-{offset}
            //FBGL.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_110-{offset}
            //FBGLE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_010_111-{offset}
            //FBNGLE.W <label>                                |-|--CC46|-|-----|-----|          |1111_001_010_011_000-{offset}
            //FBNGL.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_001-{offset}
            //FBNLE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_010-{offset}
            //FBNLT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_011-{offset}
            //FBNGE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_100-{offset}
            //FBNGT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_101-{offset}
            //FBSNE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_110-{offset}
            //FBST.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_011_111-{offset}
          case 0b1111_001_010:
            irpFbccWord ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FBF.L <label>                                   |-|--CC46|-|-----|-----|          |1111_001_011_000_000-{offset}
            //FBEQ.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_000_001-{offset}
            //FBOGT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_010-{offset}
            //FBOGE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_011-{offset}
            //FBOLT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_100-{offset}
            //FBOLE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_101-{offset}
            //FBOGL.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_110-{offset}
            //FBOR.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_000_111-{offset}
            //FBUN.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_001_000-{offset}
            //FBUEQ.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_001-{offset}
            //FBUGT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_010-{offset}
            //FBUGE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_011-{offset}
            //FBULT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_100-{offset}
            //FBULE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_101-{offset}
            //FBNE.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_001_110-{offset}
            //FBT.L <label>                                   |-|--CC46|-|-----|-----|          |1111_001_011_001_111-{offset}
            //FBRA.L <label>                                  |A|--CC46|-|-----|-----|          |1111_001_011_001_111-{offset}        [FBT.L <label>]
            //FBSF.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_000-{offset}
            //FBSEQ.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_010_001-{offset}
            //FBGT.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_010-{offset}
            //FBGE.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_011-{offset}
            //FBLT.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_100-{offset}
            //FBLE.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_101-{offset}
            //FBGL.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_110-{offset}
            //FBGLE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_010_111-{offset}
            //FBNGLE.L <label>                                |-|--CC46|-|-----|-----|          |1111_001_011_011_000-{offset}
            //FBNGL.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_001-{offset}
            //FBNLE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_010-{offset}
            //FBNLT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_011-{offset}
            //FBNGE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_100-{offset}
            //FBNGT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_101-{offset}
            //FBSNE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_110-{offset}
            //FBST.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_011_111-{offset}
          case 0b1111_001_011:
            irpFbccLong ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FSAVE <ea>                                      |-|--CC46|P|-----|-----|  M -WXZ  |1111_001_100_mmm_rrr
          case 0b1111_001_100:
            irpFsave ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FRESTORE <ea>                                   |-|--CC46|P|-----|-----|  M+ WXZP |1111_001_101_mmm_rrr
          case 0b1111_001_101:
            irpFrestore ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CINVL NC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_000_001_rrr
            //CINVP NC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_000_010_rrr
            //CINVA NC                                        |-|----46|P|-----|-----|          |1111_010_000_011_000
            //CPUSHL NC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_000_101_rrr
            //CPUSHP NC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_000_110_rrr
            //CPUSHA NC                                       |-|----46|P|-----|-----|          |1111_010_000_111_000
          case 0b1111_010_000:
            irpCinvCpushNC ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CINVL DC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_001_001_rrr
            //CINVP DC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_001_010_rrr
            //CINVA DC                                        |-|----46|P|-----|-----|          |1111_010_001_011_000
            //CPUSHL DC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_001_101_rrr
            //CPUSHP DC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_001_110_rrr
            //CPUSHA DC                                       |-|----46|P|-----|-----|          |1111_010_001_111_000
          case 0b1111_010_001:
            irpCinvCpushDC ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CINVL IC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_010_001_rrr
            //CINVP IC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_010_010_rrr
            //CINVA IC                                        |-|----46|P|-----|-----|          |1111_010_010_011_000
            //CPUSHL IC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_010_101_rrr
            //CPUSHP IC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_010_110_rrr
            //CPUSHA IC                                       |-|----46|P|-----|-----|          |1111_010_010_111_000
          case 0b1111_010_010:
            irpCinvCpushIC ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //CINVL BC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_011_001_rrr
            //CINVP BC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_011_010_rrr
            //CINVA BC                                        |-|----46|P|-----|-----|          |1111_010_011_011_000
            //CPUSHL BC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_011_101_rrr
            //CPUSHP BC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_011_110_rrr
            //CPUSHA BC                                       |-|----46|P|-----|-----|          |1111_010_011_111_000
          case 0b1111_010_011:
            irpCinvCpushBC ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //PFLUSHN (Ar)                                    |-|----46|P|-----|-----|          |1111_010_100_000_rrr
            //PFLUSH (Ar)                                     |-|----46|P|-----|-----|          |1111_010_100_001_rrr
            //PFLUSHAN                                        |-|----46|P|-----|-----|          |1111_010_100_010_000
            //PFLUSHA                                         |-|----46|P|-----|-----|          |1111_010_100_011_000
          case 0b1111_010_100:
            irpPflush ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //PLPAW (Ar)                                      |-|-----6|P|-----|-----|          |1111_010_110_001_rrr
          case 0b1111_010_110:
            irpPlpaw ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //PLPAR (Ar)                                      |-|-----6|P|-----|-----|          |1111_010_111_001_rrr
          case 0b1111_010_111:
            irpPlpar ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //MOVE16 (Ar)+,xxx.L                              |-|----46|-|-----|-----|          |1111_011_000_000_rrr-{address}
            //MOVE16 xxx.L,(Ar)+                              |-|----46|-|-----|-----|          |1111_011_000_001_rrr-{address}
            //MOVE16 (Ar),xxx.L                               |-|----46|-|-----|-----|          |1111_011_000_010_rrr-{address}
            //MOVE16 xxx.L,(Ar)                               |-|----46|-|-----|-----|          |1111_011_000_011_rrr-{address}
            //MOVE16 (Ar)+,(An)+                              |-|----46|-|-----|-----|          |1111_011_000_100_rrr-1nnn000000000000
          case 0b1111_011_000:
            irpMove16 ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //LPSTOP.W #<data>                                |-|-----6|P|-----|-----|          |1111_100_000_000_000-0000000111000000-{data}
          case 0b1111_100_000:
            irpLpstop ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FPACK <data>                                    |A|012346|-|UUUUU|*****|          |1111_111_0dd_ddd_ddd [FLINE #<data>]
          case 0b1111_111_000:
          case 0b1111_111_001:
          case 0b1111_111_010:
          case 0b1111_111_011:
            irpFpack ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //DOS <data>                                      |A|012346|-|UUUUU|UUUUU|          |1111_111_1dd_ddd_ddd [FLINE #<data>]
          case 0b1111_111_100:
          case 0b1111_111_101:
          case 0b1111_111_110:
          case 0b1111_111_111:
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //FLINE #<data>                                   |-|012346|-|UUUUU|UUUUU|          |1111_ddd_ddd_ddd_ddd (line 1111 emulator)
          case 0b1111_000_000:
          case 0b1111_000_001:
          case 0b1111_000_010:
          case 0b1111_000_011:
          case 0b1111_000_100:
          case 0b1111_000_101:
          case 0b1111_000_110:
          case 0b1111_000_111:
          case 0b1111_001_110:
          case 0b1111_001_111:
          case 0b1111_010_101:
          case 0b1111_011_001:
          case 0b1111_011_010:
          case 0b1111_011_011:
          case 0b1111_011_100:
          case 0b1111_011_101:
          case 0b1111_011_110:
          case 0b1111_011_111:
          case 0b1111_100_001:
          case 0b1111_100_010:
          case 0b1111_100_011:
          case 0b1111_100_100:
          case 0b1111_100_101:
          case 0b1111_100_110:
          case 0b1111_100_111:
          case 0b1111_101_000:
          case 0b1111_101_001:
          case 0b1111_101_010:
          case 0b1111_101_011:
          case 0b1111_101_100:
          case 0b1111_101_101:
          case 0b1111_101_110:
          case 0b1111_101_111:
          case 0b1111_110_000:
          case 0b1111_110_001:
          case 0b1111_110_010:
          case 0b1111_110_011:
          case 0b1111_110_100:
          case 0b1111_110_101:
          case 0b1111_110_110:
          case 0b1111_110_111:
            irpFline ();
            break irpSwitch;

            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
            //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
            //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
            //HFSBOOT                                         |-|012346|-|-----|-----|          |0100_111_000_000_000
            //HFSINST                                         |-|012346|-|-----|-----|          |0100_111_000_000_001
            //HFSSTR                                          |-|012346|-|-----|-----|          |0100_111_000_000_010
            //HFSINT                                          |-|012346|-|-----|-----|          |0100_111_000_000_011
            //EMXNOP                                          |-|012346|-|-----|-----|          |0100_111_000_000_100
          case 0b0100_111_000:
            irpEmx ();
            break;

          default:
            irpIllegal ();

          }  //switch XEiJ.regOC >>> 6

          //トレース例外
          //  命令実行前にsrのTビットがセットされていたとき命令実行後にトレース例外が発生する
          //  トレース例外の発動は命令の機能拡張であり、他の例外処理で命令が中断されたときはトレース例外は発生しない
          //  命令例外はトレース例外の前に、割り込み例外はトレース例外の後に処理される
          //  未実装命令のエミュレーションルーチンはrteの直前にsrのTビットを復元することで未実装命令が1個の命令としてトレースされたように見せる
          //    ;DOSコールの終了
          //    ~008616:
          //            btst.b  #$07,(sp)
          //            bne.s   ~00861E
          //            rte
          //    ~00861E:
          //            ori.w   #$8000,sr
          //            rte
          if (XEiJ.mpuTraceFlag != 0) {  //命令実行前にsrのTビットがセットされていた
            irpExceptionFormat2 (M68kException.M6E_TRACE << 2, XEiJ.regPC, XEiJ.regPC0);  //pcは次の命令
          }
          //クロックをカウントアップする
          //  オペランドをアクセスした時点ではまだXEiJ.mpuClockTimeが更新されていないのでXEiJ.mpuClockTime<xxxClock
          //  xxxTickを呼び出すときはXEiJ.mpuClockTime>=xxxClock
          XEiJ.mpuClockTime += XEiJ.mpuModifiedUnit * XEiJ.mpuCycleCount;
          //デバイスを呼び出す
          TickerQueue.tkqRun (XEiJ.mpuClockTime);
          //割り込みを受け付ける
          if ((t = XEiJ.mpuIMR & XEiJ.mpuIRR) != 0) {  //マスクされているレベルよりも高くて受け付けていない割り込みがあるとき
            if (XEiJ.MPU_INTERRUPT_SWITCH) {
              switch (t) {
              case 0b00000001:
              case 0b00000011:
              case 0b00000101:
              case 0b00000111:
              case 0b00001001:
              case 0b00001011:
              case 0b00001101:
              case 0b00001111:
              case 0b00010001:
              case 0b00010011:
              case 0b00010101:
              case 0b00010111:
              case 0b00011001:
              case 0b00011011:
              case 0b00011101:
              case 0b00011111:
              case 0b00100001:
              case 0b00100011:
              case 0b00100101:
              case 0b00100111:
              case 0b00101001:
              case 0b00101011:
              case 0b00101101:
              case 0b00101111:
              case 0b00110001:
              case 0b00110011:
              case 0b00110101:
              case 0b00110111:
              case 0b00111001:
              case 0b00111011:
              case 0b00111101:
              case 0b00111111:
              case 0b01000001:
              case 0b01000011:
              case 0b01000101:
              case 0b01000111:
              case 0b01001001:
              case 0b01001011:
              case 0b01001101:
              case 0b01001111:
              case 0b01010001:
              case 0b01010011:
              case 0b01010101:
              case 0b01010111:
              case 0b01011001:
              case 0b01011011:
              case 0b01011101:
              case 0b01011111:
              case 0b01100001:
              case 0b01100011:
              case 0b01100101:
              case 0b01100111:
              case 0b01101001:
              case 0b01101011:
              case 0b01101101:
              case 0b01101111:
              case 0b01110001:
              case 0b01110011:
              case 0b01110101:
              case 0b01110111:
              case 0b01111001:
              case 0b01111011:
              case 0b01111101:
              case 0b01111111:
              case 0b10000001:
              case 0b10000011:
              case 0b10000101:
              case 0b10000111:
              case 0b10001001:
              case 0b10001011:
              case 0b10001101:
              case 0b10001111:
              case 0b10010001:
              case 0b10010011:
              case 0b10010101:
              case 0b10010111:
              case 0b10011001:
              case 0b10011011:
              case 0b10011101:
              case 0b10011111:
              case 0b10100001:
              case 0b10100011:
              case 0b10100101:
              case 0b10100111:
              case 0b10101001:
              case 0b10101011:
              case 0b10101101:
              case 0b10101111:
              case 0b10110001:
              case 0b10110011:
              case 0b10110101:
              case 0b10110111:
              case 0b10111001:
              case 0b10111011:
              case 0b10111101:
              case 0b10111111:
              case 0b11000001:
              case 0b11000011:
              case 0b11000101:
              case 0b11000111:
              case 0b11001001:
              case 0b11001011:
              case 0b11001101:
              case 0b11001111:
              case 0b11010001:
              case 0b11010011:
              case 0b11010101:
              case 0b11010111:
              case 0b11011001:
              case 0b11011011:
              case 0b11011101:
              case 0b11011111:
              case 0b11100001:
              case 0b11100011:
              case 0b11100101:
              case 0b11100111:
              case 0b11101001:
              case 0b11101011:
              case 0b11101101:
              case 0b11101111:
              case 0b11110001:
              case 0b11110011:
              case 0b11110101:
              case 0b11110111:
              case 0b11111001:
              case 0b11111011:
              case 0b11111101:
              case 0b11111111:
                //レベル7
                XEiJ.mpuIRR &= ~XEiJ.MPU_SYS_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = XEiJ.sysAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_SYS_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
                break;
              case 0b00000010:
              case 0b00000110:
              case 0b00001010:
              case 0b00001110:
              case 0b00010010:
              case 0b00010110:
              case 0b00011010:
              case 0b00011110:
              case 0b00100010:
              case 0b00100110:
              case 0b00101010:
              case 0b00101110:
              case 0b00110010:
              case 0b00110110:
              case 0b00111010:
              case 0b00111110:
              case 0b01000010:
              case 0b01000110:
              case 0b01001010:
              case 0b01001110:
              case 0b01010010:
              case 0b01010110:
              case 0b01011010:
              case 0b01011110:
              case 0b01100010:
              case 0b01100110:
              case 0b01101010:
              case 0b01101110:
              case 0b01110010:
              case 0b01110110:
              case 0b01111010:
              case 0b01111110:
              case 0b10000010:
              case 0b10000110:
              case 0b10001010:
              case 0b10001110:
              case 0b10010010:
              case 0b10010110:
              case 0b10011010:
              case 0b10011110:
              case 0b10100010:
              case 0b10100110:
              case 0b10101010:
              case 0b10101110:
              case 0b10110010:
              case 0b10110110:
              case 0b10111010:
              case 0b10111110:
              case 0b11000010:
              case 0b11000110:
              case 0b11001010:
              case 0b11001110:
              case 0b11010010:
              case 0b11010110:
              case 0b11011010:
              case 0b11011110:
              case 0b11100010:
              case 0b11100110:
              case 0b11101010:
              case 0b11101110:
              case 0b11110010:
              case 0b11110110:
              case 0b11111010:
              case 0b11111110:
                //レベル6
                XEiJ.mpuIRR &= ~XEiJ.MPU_MFP_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = MC68901.mfpAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_MFP_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
                break;
              case 0b00000100:
              case 0b00001100:
              case 0b00010100:
              case 0b00011100:
              case 0b00100100:
              case 0b00101100:
              case 0b00110100:
              case 0b00111100:
              case 0b01000100:
              case 0b01001100:
              case 0b01010100:
              case 0b01011100:
              case 0b01100100:
              case 0b01101100:
              case 0b01110100:
              case 0b01111100:
              case 0b10000100:
              case 0b10001100:
              case 0b10010100:
              case 0b10011100:
              case 0b10100100:
              case 0b10101100:
              case 0b10110100:
              case 0b10111100:
              case 0b11000100:
              case 0b11001100:
              case 0b11010100:
              case 0b11011100:
              case 0b11100100:
              case 0b11101100:
              case 0b11110100:
              case 0b11111100:
                //レベル5
                XEiJ.mpuIRR &= ~XEiJ.MPU_SCC_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = Z8530.sccAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_SCC_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
                break;
              case 0b00010000:
              case 0b00110000:
              case 0b01010000:
              case 0b01110000:
              case 0b10010000:
              case 0b10110000:
              case 0b11010000:
              case 0b11110000:
                //レベル3
                XEiJ.mpuIRR &= ~XEiJ.MPU_DMA_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = HD63450.dmaAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_DMA_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
                break;
              case 0b00100000:
              case 0b01100000:
              case 0b10100000:
              case 0b11100000:
                //レベル2
                XEiJ.mpuIRR &= ~XEiJ.MPU_EB2_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = XEiJ.eb2Acknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_EB2_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
                break;
              case 0b01000000:
              case 0b11000000:
                //レベル1
                XEiJ.mpuIRR &= ~XEiJ.MPU_IOI_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = IOInterrupt.ioiAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_IOI_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
                break;
              }
            } else {
              t &= -t;
              //  x&=-xはxの最下位の1のビットだけを残す演算
              //  すなわちマスクされているレベルよりも高くて受け付けていない割り込みの中で最高レベルの割り込みのビットだけが残る
              //  最高レベルの割り込みのビットしか残っていないので、割り込みの有無をレベルの高い順ではなく使用頻度の高い順に調べられる
              //  MFPやDMAの割り込みがかかる度にそれより優先度の高いインタラプトスイッチが押されていないかどうかを確かめる必要がない
              if (t == XEiJ.MPU_MFP_INTERRUPT_MASK) {
                XEiJ.mpuIRR &= ~XEiJ.MPU_MFP_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = MC68901.mfpAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_MFP_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
              } else if (t == XEiJ.MPU_DMA_INTERRUPT_MASK) {
                XEiJ.mpuIRR &= ~XEiJ.MPU_DMA_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = HD63450.dmaAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_DMA_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
              } else if (t == XEiJ.MPU_SCC_INTERRUPT_MASK) {
                XEiJ.mpuIRR &= ~XEiJ.MPU_SCC_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = Z8530.sccAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_SCC_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
              } else if (t == XEiJ.MPU_IOI_INTERRUPT_MASK) {
                XEiJ.mpuIRR &= ~XEiJ.MPU_IOI_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = IOInterrupt.ioiAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_IOI_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
              } else if (t == XEiJ.MPU_EB2_INTERRUPT_MASK) {
                XEiJ.mpuIRR &= ~XEiJ.MPU_EB2_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = XEiJ.eb2Acknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_EB2_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
              } else if (t == XEiJ.MPU_SYS_INTERRUPT_MASK) {
                XEiJ.mpuIRR &= ~XEiJ.MPU_SYS_INTERRUPT_MASK;  //割り込みを受け付ける
                if ((t = XEiJ.sysAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
                  irpInterrupt (t << 2, XEiJ.MPU_SYS_INTERRUPT_LEVEL);  //割り込み処理を開始する
                }
              }
            }
          }  //if t!=0
          if (MC68901.MFP_DELAYED_INTERRUPT) {
            XEiJ.mpuIRR |= XEiJ.mpuDIRR;  //遅延割り込み要求
            XEiJ.mpuDIRR = 0;
          }
        }  //命令ループ
      } catch (M68kException e) {
        if (M68kException.m6eNumber == M68kException.M6E_WAIT_EXCEPTION) {  //待機例外
          if (irpWaitException ()) {
            continue;
          } else {
            break errorLoop;
          }
        }
        if (M68kException.m6eNumber == M68kException.M6E_INSTRUCTION_BREAK_POINT) {  //命令ブレークポイントによる停止
          XEiJ.regPC = XEiJ.regPC0;
          XEiJ.mpuStop1 (null);  //"Instruction Break Point"
          break errorLoop;
        }
        //例外処理
        //  ここで処理するのはベクタ番号が2～63の例外に限る
        //  例外処理のサイクル数はACCESS_FAULTとADDRESS_ERROR以外は19になっているので必要ならば補正してからthrowする
        //  使用頻度が高いと思われる例外はインライン展開するのでここには来ない
        //  セーブされるpcは以下の例外は命令の先頭、これ以外は次の命令
        //     2  ACCESS_FAULT
        //     3  ADDRESS_ERROR
        //     4  ILLEGAL_INSTRUCTION
        //     8  PRIVILEGE_VIOLATION
        //    10  LINE_1010_EMULATOR
        //    11  LINE_1111_EMULATOR
        //    14  FORMAT_ERROR
        //    48  FP_BRANCH_SET_UNORDERED
        //    60  UNIMPLEMENTED_EFFECTIVE
        //    61  UNIMPLEMENTED_INSTRUCTION
        //              111111111122222222223333333333444444444455555555556666
        //    0123456789012345678901234567890123456789012345678901234567890123
        if (0b0011100010110010000000000000000000000000000000001000000000001100L << M68kException.m6eNumber < 0L) {
          XEiJ.regPC = XEiJ.regPC0;  //セーブされるpcは命令の先頭
          //アドレスレジスタを巻き戻す
          //  A7を含むのでユーザモードのときはスーパーバイザモードに移行する前に巻き戻すこと
          for (int arr = 8; M68kException.m6eIncremented != 0L; arr++) {
            XEiJ.regRn[arr] -= (byte) M68kException.m6eIncremented;
            M68kException.m6eIncremented = M68kException.m6eIncremented + 0x80L >> 8;
          }
        }
        //FSLWのTTRを設定する
        //  透過変換でアドレス変換キャッシュがヒットしてバスエラーが発生したときFSLWのTTRが設定されていない
        if ((M68kException.m6eFSLW & (M68kException.M6E_FSLW_BUS_ERROR_ON_READ | M68kException.M6E_FSLW_BUS_ERROR_ON_WRITE)) != 0) {  //バスエラーのとき
          if (((M68kException.m6eFSLW & M68kException.M6E_FSLW_TM_SUPERVISOR) != 0 ?
               (M68kException.m6eFSLW & M68kException.M6E_FSLW_TM_CODE) != 0 ? mmuSuperCodeTransparent : mmuSuperDataTransparent :
               (M68kException.m6eFSLW & M68kException.M6E_FSLW_TM_CODE) != 0 ? mmuUserCodeTransparent : mmuUserDataTransparent)[M68kException.m6eAddress >>> 24] != 0) {  //透過変換
            M68kException.m6eFSLW |= M68kException.M6E_FSLW_TRANSPARENT;
          }
        }
        if (M68kException.M6E_DEBUG_ERROR) {
          System.out.println (M68kException.m6eToString6 ());  //srを表示するのでsrを更新する前に呼び出すこと
        }
        try {
          int save_sr = XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR;
          XEiJ.regSRT1 = XEiJ.regSRT0 = 0;  //srのTビットを消す
          int sp;
          if (XEiJ.regSRS != 0) {  //スーパーバイザモード
            sp = XEiJ.regRn[15];
          } else {  //ユーザモード
            XEiJ.regSRS = XEiJ.REG_SR_S;  //スーパーバイザモードへ移行する
            XEiJ.mpuUSP = XEiJ.regRn[15];  //USPを保存
            sp = XEiJ.mpuISP;  //SSPを復元
            if (DataBreakPoint.DBP_ON) {
              DataBreakPoint.dbpMemoryMap = DataBreakPoint.dbpSuperMap;  //スーパーバイザメモリマップに切り替える
            } else {
              XEiJ.busMemoryMap = XEiJ.busSuperMap;  //スーパーバイザメモリマップに切り替える
            }
            if (InstructionBreakPoint.IBP_ON) {
              InstructionBreakPoint.ibpOp1MemoryMap = InstructionBreakPoint.ibpOp1SuperMap;
            }
          }
          //以下はスーパーバイザモード
          XEiJ.mpuClockTime += XEiJ.mpuModifiedUnit * 19;
          //  同じオフセットで異なるフォーマットになるものはここでは処理できない
          if (M68kException.m6eNumber == M68kException.M6E_ACCESS_FAULT) {
            //ホストファイルシステムのデバイスコマンドを強制終了させる
            HFS.hfsState = HFS.HFS_STATE_IDLE;
            //FORMAT $4の例外スタックフレームを作る
            XEiJ.regRn[15] = sp -= 16;
            mmuWriteLongData (sp + 12, M68kException.m6eFSLW, 1);  //15-12:フォルトステータスロングワード(FSLW)
            mmuWriteLongData (sp + 8, M68kException.m6eAddress, 1);  //11-8:フォルトアドレス
            mmuWriteWordData (sp + 6, 0x4000 | M68kException.M6E_ACCESS_FAULT << 2, 1);  //7-6:フォーマットとベクタオフセット
            //                   111111111122222222223333333333444444444455555555556666
            //         0123456789012345678901234567890123456789012345678901234567890123
          } else if (0b0001011101000000000000000000000000000000000000000000000000000000L << M68kException.m6eNumber < 0L) {
            //FORMAT $2の例外スタックフレームを作る
            XEiJ.regRn[15] = sp -= 12;
            mmuWriteLongData (sp + 8, M68kException.m6eAddress, 1);  //11-8:命令アドレス
            mmuWriteWordData (sp + 6, 0x2000 | M68kException.m6eNumber << 2, 1);  //7-6:フォーマットとベクタオフセット
          } else {
            //FORMAT $0の例外スタックフレームを作る
            XEiJ.regRn[15] = sp -= 8;
            mmuWriteWordData (sp + 6, M68kException.m6eNumber << 2, 1);  //7-6:フォーマットとベクタオフセット
          }
          mmuWriteLongData (sp + 2, XEiJ.regPC, 1);  //5-2:プログラムカウンタ
          mmuWriteWordData (sp, save_sr, 1);  //1-0:ステータスレジスタ
          irpSetPC (mmuReadLongFour (XEiJ.mpuVBR + (M68kException.m6eNumber << 2), 1));  //例外ベクタを取り出してジャンプする
          if (XEiJ.dbgStopOnError) {  //エラーで停止する場合
            if (XEiJ.dbgDoStopOnError ()) {
              break errorLoop;
            }
          }
        } catch (M68kException ee) {  //ダブルバスフォルト
          XEiJ.dbgDoubleBusFault ();
          break errorLoop;
        }
      }  //catch M68kException
    }  //例外ループ

    //  通常
    //    pc0  最後に実行した命令
    //    pc  次に実行する命令
    //  バスエラー、アドレスエラー、不当命令、特権違反で停止したとき
    //    pc0  エラーを発生させた命令
    //    pc  例外処理ルーチンの先頭
    //  ダブルバスフォルトで停止したとき
    //    pc0  エラーを発生させた命令
    //    pc  エラーを発生させた命令
    //  命令ブレークポイントで停止したとき
    //    pc0  命令ブレークポイントが設定された、次に実行する命令
    //    pc  命令ブレークポイントが設定された、次に実行する命令
    //  データブレークポイントで停止したとき
    //    pc0  データを書き換えた、最後に実行した命令
    //    pc  次に実行する命令

    //分岐ログに停止レコードを記録する
    if (BranchLog.BLG_ON) {
      //BranchLog.blgStop ();
      int i = (char) BranchLog.blgNewestRecord << BranchLog.BLG_RECORD_SHIFT;
      BranchLog.blgArray[i] = BranchLog.blgHead | BranchLog.blgSuper;
      BranchLog.blgArray[i + 1] = XEiJ.regPC;  //次に実行する命令
    }

  }  //mpuCore()



  //cont = irpWaitException ()
  //  待機例外をキャッチしたとき
  public static boolean irpWaitException () {
    XEiJ.regPC = XEiJ.regPC0;  //PCを巻き戻す
    XEiJ.regRn[8 + (XEiJ.regOC & 7)] += WaitInstruction.REWIND_AR[XEiJ.regOC >> 3];  //(Ar)+|-(Ar)で変化したArを巻き戻す
    try {
      //トレース例外を処理する
      if (XEiJ.mpuTraceFlag != 0) {  //命令実行前にsrのTビットがセットされていた
        irpExceptionFormat2 (M68kException.M6E_TRACE << 2, XEiJ.regPC, XEiJ.regPC0);  //pcは次の命令
      }
      //デバイスを呼び出す
      TickerQueue.tkqRun (XEiJ.mpuClockTime);
      //割り込みを受け付ける
      int t;
      if ((t = XEiJ.mpuIMR & XEiJ.mpuIRR) != 0) {  //マスクされているレベルよりも高くて受け付けていない割り込みがあるとき
        t &= -t;
        //  x&=-xはxの最下位の1のビットだけを残す演算
        //  すなわちマスクされているレベルよりも高くて受け付けていない割り込みの中で最高レベルの割り込みのビットだけが残る
        //  最高レベルの割り込みのビットしか残っていないので、割り込みの有無をレベルの高い順ではなく使用頻度の高い順に調べられる
        //  MFPやDMAの割り込みがかかる度にそれより優先度の高いインタラプトスイッチが押されていないかどうかを確かめる必要がない
        if (t == XEiJ.MPU_MFP_INTERRUPT_MASK) {
          XEiJ.mpuIRR &= ~XEiJ.MPU_MFP_INTERRUPT_MASK;  //割り込みを受け付ける
          if ((t = MC68901.mfpAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
            irpInterrupt (t << 2, XEiJ.MPU_MFP_INTERRUPT_LEVEL);  //割り込み処理を開始する
          }
        } else if (t == XEiJ.MPU_DMA_INTERRUPT_MASK) {
          XEiJ.mpuIRR &= ~XEiJ.MPU_DMA_INTERRUPT_MASK;  //割り込みを受け付ける
          if ((t = HD63450.dmaAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
            irpInterrupt (t << 2, XEiJ.MPU_DMA_INTERRUPT_LEVEL);  //割り込み処理を開始する
          }
        } else if (t == XEiJ.MPU_SCC_INTERRUPT_MASK) {
          XEiJ.mpuIRR &= ~XEiJ.MPU_SCC_INTERRUPT_MASK;  //割り込みを受け付ける
          if ((t = Z8530.sccAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
            irpInterrupt (t << 2, XEiJ.MPU_SCC_INTERRUPT_LEVEL);  //割り込み処理を開始する
          }
        } else if (t == XEiJ.MPU_IOI_INTERRUPT_MASK) {
          XEiJ.mpuIRR &= ~XEiJ.MPU_IOI_INTERRUPT_MASK;  //割り込みを受け付ける
          if ((t = IOInterrupt.ioiAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
            irpInterrupt (t << 2, XEiJ.MPU_IOI_INTERRUPT_LEVEL);  //割り込み処理を開始する
          }
        } else if (t == XEiJ.MPU_EB2_INTERRUPT_MASK) {
          XEiJ.mpuIRR &= ~XEiJ.MPU_EB2_INTERRUPT_MASK;  //割り込みを受け付ける
          if ((t = XEiJ.eb2Acknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
            irpInterrupt (t << 2, XEiJ.MPU_EB2_INTERRUPT_LEVEL);  //割り込み処理を開始する
          }
        } else if (t == XEiJ.MPU_SYS_INTERRUPT_MASK) {
          XEiJ.mpuIRR &= ~XEiJ.MPU_SYS_INTERRUPT_MASK;  //割り込みを受け付ける
          if ((t = XEiJ.sysAcknowledge ()) != 0) {  //デバイスにベクタ番号を要求して割り込み処理中の状態になったとき
            irpInterrupt (t << 2, XEiJ.MPU_SYS_INTERRUPT_LEVEL);  //割り込み処理を開始する
          }
        }
      }  //if t!=0
      if (MC68901.MFP_DELAYED_INTERRUPT) {
        XEiJ.mpuIRR |= XEiJ.mpuDIRR;  //遅延割り込み要求
        XEiJ.mpuDIRR = 0;
      }
    } catch (M68kException e) {
      //!!! 待機例外処理中のバスエラーの処理は省略
      XEiJ.dbgDoubleBusFault ();
      return false;
    }  //catch M68kException
    return true;
  }  //irpWaitException



  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ORI.B #<data>,<ea>                              |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_000_000_mmm_rrr-{data}
  //OR.B #<data>,<ea>                               |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_000_000_mmm_rrr-{data}  [ORI.B #<data>,<ea>]
  //ORI.B #<data>,CCR                               |-|012346|-|*****|*****|          |0000_000_000_111_100-{data}
  public static void irpOriByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //ORI.B #<data>,Dr
      if (XEiJ.DBG_ORI_BYTE_ZERO_D0) {
        if (z == 0 && ea == 0 && XEiJ.dbgOriByteZeroD0) {  //ORI.B #$00,D0
          M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
          throw M68kException.m6eSignal;
        }
      }
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] |= 255 & z;  //0拡張してからOR
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    } else if (ea == XEiJ.EA_IM) {  //ORI.B #<data>,CCR
      XEiJ.mpuCycleCount++;
      XEiJ.regCCR |= XEiJ.REG_CCR_MASK & z;
    } else {  //ORI.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z |= mmuModifyByteSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    }
  }  //irpOriByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ORI.W #<data>,<ea>                              |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_000_001_mmm_rrr-{data}
  //OR.W #<data>,<ea>                               |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_000_001_mmm_rrr-{data}  [ORI.W #<data>,<ea>]
  //ORI.W #<data>,SR                                |-|012346|P|*****|*****|          |0000_000_001_111_100-{data}
  public static void irpOriWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //ORI.W #<data>,Dr
      int z = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] |= (char) z;  //0拡張してからOR
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    } else if (ea == XEiJ.EA_IM) {  //ORI.W #<data>,SR
      if (XEiJ.regSRS == 0) {  //ユーザモードのとき
        M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
        throw M68kException.m6eSignal;
      }
      //以下はスーパーバイザモード
      XEiJ.mpuCycleCount += 5;
      irpSetSR (XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR | mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, 1));  //pcws。特権違反チェックが先
    } else {  //ORI.W #<data>,<mem>
      int z = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z |= mmuModifyWordSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    }
  }  //irpOriWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ORI.L #<data>,<ea>                              |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_000_010_mmm_rrr-{data}
  //OR.L #<data>,<ea>                               |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_000_010_mmm_rrr-{data}  [ORI.L #<data>,<ea>]
  public static void irpOriLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    int z;
    if (ea < XEiJ.EA_AR) {  //ORI.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] |= y;
    } else {  //ORI.L #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = mmuModifyLongData (a, XEiJ.regSRS) | y, XEiJ.regSRS);
    }
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpOriLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BITREV.L Dr                                     |-|------|-|-----|-----|D         |0000_000_011_000_rrr (ISA_C)
  //CMP2.B <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_000_011_mmm_rrr-rnnn000000000000
  //CHK2.B <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_000_011_mmm_rrr-rnnn100000000000
  //
  //BITREV.L Dr
  //  Drのビットの並びを逆順にする。CCRは変化しない
  //
  //CHK2.B <ea>,Rn
  //  <ea>から下限と上限をリードしてRnが範囲内か調べる
  //  CHK2.B <ea>,Anは下限と上限をそれぞれロングに符号拡張してロングで比較する
  //  Rnが下限または上限と等しいときZをセットする
  //  Rnが範囲外のときCをセットする。このときCHK instruction例外が発生する
  //  060ISPのソースは注釈に誤りが多いので注釈ではなくコードを参考にする
  //  CCR
  //    X  変化しない
  //    N  変化しない(M68000PRMでは未定義)
  //    Z  Rn-LB==0||Rn-LB==UB-LB
  //    V  変化しない(M68000PRMでは未定義)
  //    C  Rn-LB>UB-LB(符号なし比較)
  //
  //CMP2.B <ea>,Rn
  //  <ea>から下限と上限をリードしてRnが範囲内か調べる
  //  CMP2.B <ea>,Anは下限と上限をそれぞれロングに符号拡張してロングで比較する
  //  Rnが下限または上限と等しいときZをセットする
  //  Rnが範囲外のときCをセットする
  //  060ISPのソースは注釈に誤りが多いので注釈ではなくコードを参考にする
  //  CCR
  //    X  変化しない
  //    N  変化しない(M68000PRMでは未定義)
  //    Z  Rn-LB==0||Rn-LB==UB-LB
  //    V  変化しない(M68000PRMでは未定義)
  //    C  Rn-LB>UB-LB(符号なし比較)
  public static void irpCmp2Chk2Byte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //BITREV.L Dr
      XEiJ.mpuCycleCount++;
      int x = XEiJ.regRn[ea];
      XEiJ.regRn[ea] = XEiJ.MPU_BITREV_TABLE_0[x & 2047] | XEiJ.MPU_BITREV_TABLE_1[x << 10 >>> 21] | XEiJ.MPU_BITREV_TABLE_2[x >>> 22];
    } else {  //CMP2/CHK2.B <ea>,Rn
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpCmp2Chk2Byte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BTST.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_100_000_rrr
  //MOVEP.W (d16,Ar),Dq                             |-|01234S|-|-----|-----|          |0000_qqq_100_001_rrr-{data}
  //BTST.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZPI|0000_qqq_100_mmm_rrr
  public static void irpBtstReg () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9;  //qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //MOVEP.W (d16,Ar),Dq
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //BTST.L Dq,Dr/<ea>
      int y = XEiJ.regRn[qqq];
      if (ea < XEiJ.EA_AR) {  //BTST.L Dq,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (~XEiJ.regRn[ea] >>> y & 1) << 2;  //ccr_btst。intのシフトは5bitでマスクされるので&31を省略
      } else {  //BTST.B Dq,<ea>
        XEiJ.mpuCycleCount++;
        XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (~(ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS)) >>> (y & 7) & 1) << 2;  //ccr_btst。pcbs。イミディエイトを分離
      }
    }
  }  //irpBtstReg

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCHG.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_101_000_rrr
  //MOVEP.L (d16,Ar),Dq                             |-|01234S|-|-----|-----|          |0000_qqq_101_001_rrr-{data}
  //BCHG.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZ  |0000_qqq_101_mmm_rrr
  public static void irpBchgReg () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9;  //qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //MOVEP.L (d16,Ar),Dq
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //BCHG.L Dq,Dr/<ea>
      int x;
      int y = XEiJ.regRn[qqq];
      if (ea < XEiJ.EA_AR) {  //BCHG.L Dq,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] = (x = XEiJ.regRn[ea]) ^ (y = 1 << y);  //intのシフトは5bitでマスクされるので1<<(y&0x1f)の&0x1fを省略
      } else {  //BCHG.B Dq,<ea>
        XEiJ.mpuCycleCount++;
        int a = efaMltByte (ea);
        mmuWriteByteData (a, (x = mmuModifyByteSignData (a, XEiJ.regSRS)) ^ (y = 1 << (y & 7)), XEiJ.regSRS);
      }
      XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (x & y) - 1 >>> 31 << 2;  //ccr_btst
    }
  }  //irpBchgReg

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCLR.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_110_000_rrr
  //MOVEP.W Dq,(d16,Ar)                             |-|01234S|-|-----|-----|          |0000_qqq_110_001_rrr-{data}
  //BCLR.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZ  |0000_qqq_110_mmm_rrr
  public static void irpBclrReg () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = XEiJ.regRn[XEiJ.regOC >> 9];  //qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //MOVEP.W Dq,(d16,Ar)
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //BCLR.L Dq,Dr/<ea>
      int x;
      if (ea < XEiJ.EA_AR) {  //BCLR.L Dq,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] = (x = XEiJ.regRn[ea]) & ~(y = 1 << y);  //intのシフトは5bitでマスクされるので1<<(y&0x1f)の&0x1fを省略
      } else {  //BCLR.B Dq,<ea>
        XEiJ.mpuCycleCount++;
        int a = efaMltByte (ea);
        mmuWriteByteData (a, (x = mmuModifyByteSignData (a, XEiJ.regSRS)) & ~(y = 1 << (y & 7)), XEiJ.regSRS);
      }
      XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (x & y) - 1 >>> 31 << 2;  //ccr_btst
    }
  }  //irpBclrReg

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BSET.L Dq,Dr                                    |-|012346|-|--U--|--*--|D         |0000_qqq_111_000_rrr
  //MOVEP.L Dq,(d16,Ar)                             |-|01234S|-|-----|-----|          |0000_qqq_111_001_rrr-{data}
  //BSET.B Dq,<ea>                                  |-|012346|-|--U--|--*--|  M+-WXZ  |0000_qqq_111_mmm_rrr
  public static void irpBsetReg () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = XEiJ.regRn[XEiJ.regOC >> 9];  //qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //MOVEP.L Dq,(d16,Ar)
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //BSET.L Dq,Dr/<ea>
      int x;
      if (ea < XEiJ.EA_AR) {  //BSET.L Dq,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] = (x = XEiJ.regRn[ea]) | (y = 1 << y);  //intのシフトは5bitでマスクされるので1<<(y&0x1f)の&0x1fを省略
      } else {  //BSET.B Dq,<ea>
        XEiJ.mpuCycleCount++;
        int a = efaMltByte (ea);
        mmuWriteByteData (a, (x = mmuModifyByteSignData (a, XEiJ.regSRS)) | (y = 1 << (y & 7)), XEiJ.regSRS);
      }
      XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (x & y) - 1 >>> 31 << 2;  //ccr_btst
    }
  }  //irpBsetReg

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ANDI.B #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_001_000_mmm_rrr-{data}
  //AND.B #<data>,<ea>                              |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_001_000_mmm_rrr-{data}  [ANDI.B #<data>,<ea>]
  //ANDI.B #<data>,CCR                              |-|012346|-|*****|*****|          |0000_001_000_111_100-{data}
  public static void irpAndiByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //ANDI.B #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] &= ~255 | z;  //1拡張してからAND
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    } else if (ea == XEiJ.EA_IM) {  //ANDI.B #<data>,CCR
      XEiJ.mpuCycleCount++;
      XEiJ.regCCR &= z;
    } else {  //ANDI.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z &= mmuModifyByteSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    }
  }  //irpAndiByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ANDI.W #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_001_001_mmm_rrr-{data}
  //AND.W #<data>,<ea>                              |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_001_001_mmm_rrr-{data}  [ANDI.W #<data>,<ea>]
  //ANDI.W #<data>,SR                               |-|012346|P|*****|*****|          |0000_001_001_111_100-{data}
  public static void irpAndiWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //ANDI.W #<data>,Dr
      int z = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] &= ~65535 | z;  //1拡張してからAND
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    } else if (ea == XEiJ.EA_IM) {  //ANDI.W #<data>,SR
      if (XEiJ.regSRS == 0) {  //ユーザモードのとき
        M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
        throw M68kException.m6eSignal;
      }
      //以下はスーパーバイザモード
      XEiJ.mpuCycleCount += 12;
      irpSetSR ((XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR) & mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, 1));  //pcws。特権違反チェックが先
    } else {  //ANDI.W #<data>,<mem>
      int z = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z &= mmuModifyWordSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    }
  }  //irpAndiWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ANDI.L #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_001_010_mmm_rrr-{data}
  //AND.L #<data>,<ea>                              |A|012346|-|-UUUU|-**00|  M+-WXZ  |0000_001_010_mmm_rrr-{data}  [ANDI.L #<data>,<ea>]
  public static void irpAndiLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    int z;
    if (ea < XEiJ.EA_AR) {  //ANDI.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] &= y;
    } else {  //ANDI.L #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = mmuModifyLongData (a, XEiJ.regSRS) & y, XEiJ.regSRS);
    }
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpAndiLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BYTEREV.L Dr                                    |-|------|-|-----|-----|D         |0000_001_011_000_rrr (ISA_C)
  //CMP2.W <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_001_011_mmm_rrr-rnnn000000000000
  //CHK2.W <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_001_011_mmm_rrr-rnnn100000000000
  //
  //BYTEREV.L Dr
  //  Drのバイトの並びを逆順にする。CCRは変化しない
  //
  //CHK2.W <ea>,Rn
  //  <ea>から下限と上限をリードしてRnが範囲内か調べる
  //  CHK2.W <ea>,Anは下限と上限をそれぞれロングに符号拡張してロングで比較する
  //  Rnが下限または上限と等しいときZをセットする
  //  Rnが範囲外のときCをセットする。このときCHK instruction例外が発生する
  //  060ISPのソースは注釈に誤りが多いので注釈ではなくコードを参考にする
  //  CCR
  //    X  変化しない
  //    N  変化しない(M68000PRMでは未定義)
  //    Z  Rn-LB==0||Rn-LB==UB-LB
  //    V  変化しない(M68000PRMでは未定義)
  //    C  Rn-LB>UB-LB(符号なし比較)
  //
  //CMP2.W <ea>,Rn
  //  <ea>から下限と上限をリードしてRnが範囲内か調べる
  //  CMP2.W <ea>,Anは下限と上限をそれぞれロングに符号拡張してロングで比較する
  //  Rnが下限または上限と等しいときZをセットする
  //  Rnが範囲外のときCをセットする
  //  060ISPのソースは注釈に誤りが多いので注釈ではなくコードを参考にする
  //  CCR
  //    X  変化しない
  //    N  変化しない(M68000PRMでは未定義)
  //    Z  Rn-LB==0||Rn-LB==UB-LB
  //    V  変化しない(M68000PRMでは未定義)
  //    C  Rn-LB>UB-LB(符号なし比較)
  public static void irpCmp2Chk2Word () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //BYTEREV.L Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = Integer.reverseBytes (XEiJ.regRn[ea]);
    } else {  //CMP2/CHK2.W <ea>,Rn
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpCmp2Chk2Word

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBI.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_010_000_mmm_rrr-{data}
  //SUB.B #<data>,<ea>                              |A|012346|-|UUUUU|*****|  M+-WXZ  |0000_010_000_mmm_rrr-{data}  [SUBI.B #<data>,<ea>]
  public static void irpSubiByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    int z;
    if (ea < XEiJ.EA_AR) {  //SUBI.B #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (byte) (XEiJ.regRn[ea] = ~0xff & (x = XEiJ.regRn[ea]) | 0xff & (x = (byte) x) - y);
    } else {  //SUBI.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = (byte) ((x = mmuModifyByteSignData (a, XEiJ.regSRS)) - y), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub
  }  //irpSubiByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBI.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_010_001_mmm_rrr-{data}
  //SUB.W #<data>,<ea>                              |A|012346|-|UUUUU|*****|  M+-WXZ  |0000_010_001_mmm_rrr-{data}  [SUBI.W #<data>,<ea>]
  public static void irpSubiWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    int z;
    if (ea < XEiJ.EA_AR) {  //SUBI.W #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (short) (XEiJ.regRn[ea] = ~0xffff & (x = XEiJ.regRn[ea]) | (char) ((x = (short) x) - y));
    } else {  //SUBI.W #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z = (short) ((x = mmuModifyWordSignData (a, XEiJ.regSRS)) - y), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub
  }  //irpSubiWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBI.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_010_010_mmm_rrr-{data}
  //SUB.L #<data>,<ea>                              |A|012346|-|UUUUU|*****|  M+-WXZ  |0000_010_010_mmm_rrr-{data}  [SUBI.L #<data>,<ea>]
  public static void irpSubiLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    int z;
    if (ea < XEiJ.EA_AR) {  //SUBI.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = z = (x = XEiJ.regRn[ea]) - y;
    } else {  //SUBI.L #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) - y, XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub
  }  //irpSubiLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FF1.L Dr                                        |-|------|-|-UUUU|-**00|D         |0000_010_011_000_rrr (ISA_C)
  //CMP2.L <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_010_011_mmm_rrr-rnnn000000000000
  //CHK2.L <ea>,Rn                                  |-|--234S|-|-UUUU|-U*U*|  M  WXZP |0000_010_011_mmm_rrr-rnnn100000000000
  //
  //CHK2.L <ea>,Rn
  //  <ea>から下限と上限をリードしてRnが範囲内か調べる
  //  Rnが下限または上限と等しいときZをセットする
  //  Rnが範囲外のときCをセットする。このときCHK instruction例外が発生する
  //  060ISPのソースは注釈に誤りが多いので注釈ではなくコードを参考にする
  //  CCR
  //    X  変化しない
  //    N  変化しない(M68000PRMでは未定義)
  //    Z  Rn-LB==0||Rn-LB==UB-LB
  //    V  変化しない(M68000PRMでは未定義)
  //    C  Rn-LB>UB-LB(符号なし比較)
  //
  //CMP2.L <ea>,Rn
  //  <ea>から下限と上限をリードしてRnが範囲内か調べる
  //  Rnが下限または上限と等しいときZをセットする
  //  Rnが範囲外のときCをセットする
  //  060ISPのソースは注釈に誤りが多いので注釈ではなくコードを参考にする
  //  CCR
  //    X  変化しない
  //    N  変化しない(M68000PRMでは未定義)
  //    Z  Rn-LB==0||Rn-LB==UB-LB
  //    V  変化しない(M68000PRMでは未定義)
  //    C  Rn-LB>UB-LB(符号なし比較)
  //
  //FF1.L Dr
  //  Drの最上位の1のbit31からのオフセットをDrに格納する
  //  Drが0のときは32になる
  public static void irpCmp2Chk2Long () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //FF1.L Dr
      XEiJ.mpuCycleCount++;
      int z = XEiJ.regRn[ea];
      XEiJ.regRn[ea] = Integer.numberOfLeadingZeros (z);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else {  //CMP2/CHK2.L <ea>,Rn
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpCmp2Chk2Long

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDI.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_011_000_mmm_rrr-{data}
  public static void irpAddiByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    int z;
    if (ea < XEiJ.EA_AR) {  //ADDI.B #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (byte) (XEiJ.regRn[ea] = ~0xff & (x = XEiJ.regRn[ea]) | 0xff & (x = (byte) x) + y);
    } else {  //ADDI.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = (byte) ((x = mmuModifyByteSignData (a, XEiJ.regSRS)) + y), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ z) & (y ^ z)) >>> 31 << 1 |
           ((x | y) ^ (x ^ y) & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add
  }  //irpAddiByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDI.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_011_001_mmm_rrr-{data}
  public static void irpAddiWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    int z;
    if (ea < XEiJ.EA_AR) {  //ADDI.W #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (short) (XEiJ.regRn[ea] = ~0xffff & (x = XEiJ.regRn[ea]) | (char) ((x = (short) x) + y));
    } else {  //ADDI.W #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z = (short) ((x = mmuModifyWordSignData (a, XEiJ.regSRS)) + y), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ z) & (y ^ z)) >>> 31 << 1 |
           ((x | y) ^ (x ^ y) & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add
  }  //irpAddiWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDI.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0000_011_010_mmm_rrr-{data}
  public static void irpAddiLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    int z;
    if (ea < XEiJ.EA_AR) {  //ADDI.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = z = (x = XEiJ.regRn[ea]) + y;
    } else {  //ADDI.L #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) + y, XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ z) & (y ^ z)) >>> 31 << 1 |
           ((x | y) ^ (x ^ y) & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add
  }  //irpAddiLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BTST.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_000_000_rrr-{data}
  //BTST.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZP |0000_100_000_mmm_rrr-{data}
  public static void irpBtstImm () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //BTST.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (~XEiJ.regRn[ea] >>> y & 1) << 2;  //ccr_btst。intのシフトは5bitでマスクされるので&31を省略
    } else {  //BTST.B #<data>,<ea>
      XEiJ.mpuCycleCount++;
      XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (~mmuReadByteSignData (efaMemByte (ea), XEiJ.regSRS) >>> (y & 7) & 1) << 2;  //ccr_btst
    }
  }  //irpBtstImm

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCHG.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_001_000_rrr-{data}
  //BCHG.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZ  |0000_100_001_mmm_rrr-{data}
  public static void irpBchgImm () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //BCHG.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = (x = XEiJ.regRn[ea]) ^ (y = 1 << y);  //intのシフトは5bitでマスクされるので1<<(y&0x1f)の&0x1fを省略
    } else {  //BCHG.B #<data>,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, (x = mmuModifyByteSignData (a, XEiJ.regSRS)) ^ (y = 1 << (y & 7)), XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (x & y) - 1 >>> 31 << 2;  //ccr_btst
  }  //irpBchgImm

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCLR.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_010_000_rrr-{data}
  //BCLR.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZ  |0000_100_010_mmm_rrr-{data}
  public static void irpBclrImm () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //BCLR.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = (x = XEiJ.regRn[ea]) & ~(y = 1 << y);  //intのシフトは5bitでマスクされるので1<<(y&0x1f)の&0x1fを省略
    } else {  //BCLR.B #<data>,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, (x = mmuModifyByteSignData (a, XEiJ.regSRS)) & ~(y = 1 << (y & 7)), XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (x & y) - 1 >>> 31 << 2;  //ccr_btst
  }  //irpBclrImm

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BSET.L #<data>,Dr                               |-|012346|-|--U--|--*--|D         |0000_100_011_000_rrr-{data}
  //BSET.B #<data>,<ea>                             |-|012346|-|--U--|--*--|  M+-WXZ  |0000_100_011_mmm_rrr-{data}
  public static void irpBsetImm () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //BSET.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = (x = XEiJ.regRn[ea]) | (y = 1 << y);  //intのシフトは5bitでマスクされるので1<<(y&0x1f)の&0x1fを省略
    } else {  //BSET.B #<data>,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, (x = mmuModifyByteSignData (a, XEiJ.regSRS)) | (y = 1 << (y & 7)), XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) | (x & y) - 1 >>> 31 << 2;  //ccr_btst
  }  //irpBsetImm

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EORI.B #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_000_mmm_rrr-{data}
  //EOR.B #<data>,<ea>                              |A|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_000_mmm_rrr-{data}  [EORI.B #<data>,<ea>]
  //EORI.B #<data>,CCR                              |-|012346|-|*****|*****|          |0000_101_000_111_100-{data}
  public static void irpEoriByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    if (ea < XEiJ.EA_AR) {  //EORI.B #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] ^= 255 & z;  //0拡張してからEOR
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    } else if (ea == XEiJ.EA_IM) {  //EORI.B #<data>,CCR
      XEiJ.mpuCycleCount++;
      XEiJ.regCCR ^= XEiJ.REG_CCR_MASK & z;
    } else {  //EORI.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z ^= mmuModifyByteSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    }
  }  //irpEoriByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EORI.W #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_001_mmm_rrr-{data}
  //EOR.W #<data>,<ea>                              |A|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_001_mmm_rrr-{data}  [EORI.W #<data>,<ea>]
  //EORI.W #<data>,SR                               |-|012346|P|*****|*****|          |0000_101_001_111_100-{data}
  public static void irpEoriWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //EORI.W #<data>,Dr
      int z = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] ^= (char) z;  //0拡張してからEOR
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    } else if (ea == XEiJ.EA_IM) {  //EORI.W #<data>,SR
      if (XEiJ.regSRS == 0) {  //ユーザモードのとき
        M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
        throw M68kException.m6eSignal;
      }
      //以下はスーパーバイザモード
      XEiJ.mpuCycleCount += 12;
      irpSetSR ((XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR) ^ mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, 1));  //pcws。特権違反チェックが先
    } else {  //EORI.W #<data>,<mem>
      int z = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z ^= mmuModifyWordSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    }
  }  //irpEoriWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EORI.L #<data>,<ea>                             |-|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_010_mmm_rrr-{data}
  //EOR.L #<data>,<ea>                              |A|012346|-|-UUUU|-**00|D M+-WXZ  |0000_101_010_mmm_rrr-{data}  [EORI.L #<data>,<ea>]
  public static void irpEoriLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    int z;
    if (ea < XEiJ.EA_AR) {  //EORI.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] ^= y;
    } else {  //EORI.L #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = mmuModifyLongData (a, XEiJ.regSRS) ^ y, XEiJ.regSRS);
    }
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpEoriLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CAS.B Dc,Du,<ea>                                |-|--2346|-|-UUUU|-****|  M+-WXZ  |0000_101_011_mmm_rrr-0000000uuu000ccc
  public static void irpCasByte () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0000_000_111_000_111) != 0) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int c = w & 7;
    int y = (byte) XEiJ.regRn[c];  //y=Dc
    int a = efaMltByte (XEiJ.regOC & 63);
    int x = mmuReadByteSignData (a, XEiJ.regSRS);  //x=<ea>
    int z = (byte) (x - y);  //z=<ea>-Dc
    XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |
                   (z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   ((x ^ y) & (x ^ z)) >>> 31 << 1 |
                   (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
    if (z == 0) {  //<ea>==Dc
      XEiJ.mpuCycleCount += 19;
      mmuWriteByteData (a, XEiJ.regRn[w >> 6], XEiJ.regSRS);  //Du→<ea>
    } else {  //<ea>!=Dc
      XEiJ.mpuCycleCount += 19;
      XEiJ.regRn[c] = ~0xff & XEiJ.regRn[c] | 0xff & x;  //<ea>→Dc
    }
  }  //irpCasByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMPI.B #<data>,<ea>                             |-|--2346|-|-UUUU|-****|D M+-WXZP |0000_110_000_mmm_rrr-{data}
  //CMP.B #<data>,<ea>                              |A|--2346|-|-UUUU|-****|  M+-WXZP |0000_110_000_mmm_rrr-{data}  [CMPI.B #<data>,<ea>]
  public static void irpCmpiByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS);  //pcbs
    int z = (byte) ((x = ea < XEiJ.EA_AR ? (byte) XEiJ.regRn[ea] : mmuReadByteSignData (efaMemByte (ea), XEiJ.regSRS)) - y);  //アドレッシングモードに注意
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpiByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMPI.W #<data>,<ea>                             |-|--2346|-|-UUUU|-****|D M+-WXZP |0000_110_001_mmm_rrr-{data}
  //CMP.W #<data>,<ea>                              |A|--2346|-|-UUUU|-****|  M+-WXZP |0000_110_001_mmm_rrr-{data}  [CMPI.W #<data>,<ea>]
  public static void irpCmpiWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    int z = (short) ((x = ea < XEiJ.EA_AR ? (short) XEiJ.regRn[ea] : mmuReadWordSignData (efaMemWord (ea), XEiJ.regSRS)) - y);  //アドレッシングモードに注意
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpiWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMPI.L #<data>,<ea>                             |-|--2346|-|-UUUU|-****|D M+-WXZP |0000_110_010_mmm_rrr-{data}
  //CMP.L #<data>,<ea>                              |A|--2346|-|-UUUU|-****|  M+-WXZP |0000_110_010_mmm_rrr-{data}  [CMPI.L #<data>,<ea>]
  public static void irpCmpiLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    int z;
    if (ea < XEiJ.EA_AR) {  //CMPI.L #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (x = XEiJ.regRn[ea]) - y;
    } else {  //CMPI.L #<data>,<mem>
      XEiJ.mpuCycleCount++;
      z = (x = mmuReadLongData (efaMemLong (ea), XEiJ.regSRS)) - y;  //アドレッシングモードに注意
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpiLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CAS.W Dc,Du,<ea>                                |-|--2346|-|-UUUU|-****|  M+-WXZ  |0000_110_011_mmm_rrr-0000000uuu000ccc        (68060 software emulate misaligned <ea>)
  //CAS2.W Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)              |-|--234S|-|-UUUU|-****|          |0000_110_011_111_100-rnnn000uuu000ccc(1)-rnnn_000_uuu_000_ccc(2)
  public static void irpCasWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea == XEiJ.EA_IM) {  //CAS2.W Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //CAS.W Dc,Du,<ea>
      int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz
      if ((w & ~0b0000_000_111_000_111) != 0) {
        M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
        throw M68kException.m6eSignal;
      }
      int a = efaMltWord (ea);  //a=ea
      if ((a & 1) != 0) {  //misaligned <ea>
        M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
        throw M68kException.m6eSignal;
      }
      int c = w & 7;
      int y = (short) XEiJ.regRn[c];  //y=Dc
      int x = mmuReadWordSignData (a, XEiJ.regSRS);  //x=<ea>
      int z = (short) (x - y);  //z=<ea>-Dc
      XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |
                     (z < 0 ? XEiJ.REG_CCR_N : 0) |
                     (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                     ((x ^ y) & (x ^ z)) >>> 31 << 1 |
                     (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
      if (z == 0) {  //<ea>==Dc
        XEiJ.mpuCycleCount += 19;
        mmuWriteWordData (a, XEiJ.regRn[w >> 6], XEiJ.regSRS);  //Du→<ea>
      } else {  //<ea>!=Dc
        XEiJ.mpuCycleCount += 19;
        XEiJ.regRn[c] = ~0xffff & XEiJ.regRn[c] | (char) x;  //<ea>→Dc
      }
    }
  }  //irpCasWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVES.B <ea>,Rn                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_000_mmm_rrr-rnnn000000000000
  //MOVES.B Rn,<ea>                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_000_mmm_rrr-rnnn100000000000
  //
  //MOVES.B <ea>,Rn
  //  MOVES.B <ea>,DnはDnの最下位バイトだけ更新する
  //  MOVES.B <ea>,Anはバイトデータをロングに符号拡張してAnの全体を更新する
  //  SFC=1,2,5,6はアドレス変換あり、SFC=0,3,4はアドレス変換なし、
  //  SFC=7はCPU空間なのでコプロセッサが割り当てられている領域以外はバスエラーになる
  //
  //MOVES.B Rn,<ea>
  //  DFC=1,2,5,6はアドレス変換あり、DFC=0,3,4はアドレス変換なし、
  //  DFC=7はCPU空間なのでコプロセッサが割り当てられている領域以外はバスエラーになる
  public static void irpMovesByte () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz
    if (w << -11 != 0) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
    int a = efaMltByte (XEiJ.regOC & 63);
    int n = w >>> 12;  //n
    if (w << 31 - 11 >= 0) {  //MOVES.B <ea>,Rn。リード
      boolean supervisor = (0b10011111 << 24 << XEiJ.mpuSFC) < 0;
      boolean instruction = (0b00101010 << 24 << XEiJ.mpuSFC) < 0;
      MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                                 supervisor ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                                 supervisor ? XEiJ.busSuperMap : XEiJ.busUserMap);
      int z;
      //    01234567
      if (0b01100110 << 24 << XEiJ.mpuSFC < 0) {  //SFC=1,2,5,6。アドレス変換あり
        M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuSFC << 16;
        int pa = (supervisor ?
                  instruction ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
                  instruction ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
        //z = XEiJ.busRbz (pa);
        z = mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRbz (pa);
      } else if (XEiJ.mpuSFC != 7) {  //SFC=0,3,4。アドレス変換なし
        M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuSFC << 16;
        //z = XEiJ.busRbz (a);
        z = mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a);
      } else {  //SFC=7。CPU空間
        if (0x00022000 <= a && a <= 0x0002201f) {  //コプロセッサID=1
          z = XEiJ.fpuMotherboardCoprocessor.cirReadByteZero (a);
        } else {
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuSFC << 16 | M68kException.M6E_FSLW_BUS_ERROR_ON_READ;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          M68kException.m6eDirection = XEiJ.MPU_WR_READ;
          M68kException.m6eSize = XEiJ.MPU_SS_BYTE;
          throw M68kException.m6eSignal;
        }
      }
      if (n < 8) {  //MOVES.B <ea>,Dn
        XEiJ.regRn[n] = XEiJ.regRn[n] & ~255 | z;
      } else {  //MOVES.B <ea>,An
        XEiJ.regRn[n] = (byte) z;
      }
      if (MMU_DEBUG_COMMAND) {
        System.out.printf ("%08x movesReadByte(%d,0x%08x)=0x%02x\n", XEiJ.regPC0, XEiJ.mpuSFC, a, XEiJ.regRn[n] & 255);
      }
    } else {  //MOVES.B Rn,<ea>。ライト
      if (MMU_DEBUG_COMMAND) {
        System.out.printf ("%08x movesWriteByte(%d,0x%08x,0x%02x)\n", XEiJ.regPC0, XEiJ.mpuDFC, a, XEiJ.regRn[n] & 255);
      }
      boolean supervisor = (0b10011111 << 24 << XEiJ.mpuDFC) < 0;
      boolean instruction = (0b00101010 << 24 << XEiJ.mpuDFC) < 0;
      MemoryMappedDevice mm[] = (DataBreakPoint.DBP_ON ?
                                 supervisor ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                                 supervisor ? XEiJ.busSuperMap : XEiJ.busUserMap);
      int z = XEiJ.regRn[n];
      //    01234567
      if (0b01100110 << 24 << XEiJ.mpuDFC < 0) {  //DFC=1,2,5,6。アドレス変換あり
        M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuDFC << 16;
        int pa = (supervisor ?
                  instruction ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
                  instruction ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
        //XEiJ.busWb (pa, z);
        mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWb (pa, z);
      } else if (XEiJ.mpuDFC != 7) {  //DFC=0,3,4。アドレス変換なし
        M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuDFC << 16;
        //XEiJ.busWb (a, z);
        mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWb (a, z);
      } else {  //DFC=7。CPU空間
        if (0x00022000 <= a && a <= 0x0002201f) {  //コプロセッサID=1
          XEiJ.fpuMotherboardCoprocessor.cirWriteByte (a, z);
        } else {
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuDFC << 16 | M68kException.M6E_FSLW_BUS_ERROR_ON_WRITE;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          M68kException.m6eDirection = XEiJ.MPU_WR_WRITE;
          M68kException.m6eSize = XEiJ.MPU_SS_BYTE;
          throw M68kException.m6eSignal;
        }
      }
    }
  }  //irpMovesByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVES.W <ea>,Rn                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_001_mmm_rrr-rnnn000000000000
  //MOVES.W Rn,<ea>                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_001_mmm_rrr-rnnn100000000000
  //
  //MOVES.W <ea>,Rn
  //  MOVES.W <ea>,DnはDnの下位ワードだけ更新する
  //  MOVES.W <ea>,Anはワードデータをロングに符号拡張してAnの全体を更新する
  //  SFC=1,2,5,6はアドレス変換あり、SFC=0,3,4はアドレス変換なし、
  //  SFC=7はCPU空間なのでコプロセッサが割り当てられている領域以外はバスエラーになる
  //
  //MOVES.W Rn,<ea>
  //  DFC=1,2,5,6はアドレス変換あり、DFC=0,3,4はアドレス変換なし、
  //  DFC=7はCPU空間なのでコプロセッサが割り当てられている領域以外はバスエラーになる
  public static void irpMovesWord () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz
    if (w << -11 != 0) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
    int a = efaMltWord (XEiJ.regOC & 63);
    int n = w >>> 12;  //n
    if (w << 31 - 11 >= 0) {  //MOVES.W <ea>,Rn。リード
      boolean supervisor = (0b10011111 << 24 << XEiJ.mpuSFC) < 0;
      boolean instruction = (0b00101010 << 24 << XEiJ.mpuSFC) < 0;
      MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                                 supervisor ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                                 supervisor ? XEiJ.busSuperMap : XEiJ.busUserMap);
      int z;
      //    01234567
      if (0b01100110 << 24 << XEiJ.mpuSFC < 0) {  //SFC=1,2,5,6。アドレス変換あり
        if ((a & 1) == 0) {  //偶数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuSFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
                    instruction ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
          //z = XEiJ.busRwze (pa);
          z = mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRwz (pa);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuSFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
                    instruction ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
          //z = XEiJ.busRbz (pa) << 8;
          z = mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRbz (pa) << 8;
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          pa = (supervisor ?
                instruction ? mmuTranslateReadSuperCode (a + 1) : mmuTranslateReadSuperData (a + 1) :
                instruction ? mmuTranslateReadUserCode (a + 1) : mmuTranslateReadUserData (a + 1));
          //z |= XEiJ.busRbz (pa);
          z |= mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRbz (pa);
        }
      } else if (XEiJ.mpuSFC != 7) {  //SFC=0,3,4。アドレス変換なし
        if ((a & 1) == 0) {  //偶数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuSFC << 16;
          //z = XEiJ.busRwze (a);
          z = mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuSFC << 16;
          //z = XEiJ.busRbz (a) << 8;
          z = mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a) << 8;
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          a++;
          //z |= XEiJ.busRbz (a);
          z |= mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a);
        }
      } else {  //SFC=7。CPU空間
        if (0x00022000 <= a && a <= 0x0002201f) {  //コプロセッサID=1
          z = XEiJ.fpuMotherboardCoprocessor.cirReadWordZero (a);
        } else {
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuSFC << 16 | M68kException.M6E_FSLW_BUS_ERROR_ON_READ;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          M68kException.m6eDirection = XEiJ.MPU_WR_READ;
          M68kException.m6eSize = XEiJ.MPU_SS_WORD;
          throw M68kException.m6eSignal;
        }
      }
      if (n < 8) {  //MOVES.W <ea>,Dn
        XEiJ.regRn[n] = XEiJ.regRn[n] & ~65535 | z;
      } else {  //MOVES.W <ea>,An
        XEiJ.regRn[n] = (short) z;
      }
      if (MMU_DEBUG_COMMAND) {
        System.out.printf ("%08x movesReadWord(%d,0x%08x)=0x%04x\n", XEiJ.regPC0, XEiJ.mpuSFC, a, XEiJ.regRn[n] & 65535);
      }
    } else {  //MOVES.W Rn,<ea>。ライト
      if (MMU_DEBUG_COMMAND) {
        System.out.printf ("%08x movesWriteWord(%d,0x%08x,0x%04x)\n", XEiJ.regPC0, XEiJ.mpuDFC, a, XEiJ.regRn[n] & 65535);
      }
      boolean supervisor = (0b10011111 << 24 << XEiJ.mpuDFC) < 0;
      boolean instruction = (0b00101010 << 24 << XEiJ.mpuDFC) < 0;
      MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                                 supervisor ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                                 supervisor ? XEiJ.busSuperMap : XEiJ.busUserMap);
      int z = XEiJ.regRn[n];
      //    01234567
      if (0b01100110 << 24 << XEiJ.mpuDFC < 0) {  //DFC=1,2,5,6。アドレス変換あり
        if ((a & 1) == 0) {  //偶数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuDFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
                    instruction ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
          //XEiJ.busWwe (pa, z);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWw (pa, z);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuDFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
                    instruction ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
          //XEiJ.busWb (pa, z >> 8);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWb (pa, z >> 8);
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          pa = (supervisor ?
                instruction ? mmuTranslateWriteSuperCode (a + 1) : mmuTranslateWriteSuperData (a + 1) :
                instruction ? mmuTranslateWriteUserCode (a + 1) : mmuTranslateWriteUserData (a + 1));
          //XEiJ.busWb (pa, z);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWb (pa, z);
        }
      } else if (XEiJ.mpuDFC != 7) {  //DFC=0,3,4。アドレス変換なし
        if ((a & 1) == 0) {  //偶数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuDFC << 16;
          //XEiJ.busWwe (a, z);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWw (a, z);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuDFC << 16;
          //XEiJ.busWb (a, z >> 8);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWb (a, z >> 8);
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          a++;
          //XEiJ.busWb (a, z);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWb (a, z);
        }
      } else {  //DFC=7。CPU空間
        if (0x00022000 <= a && a <= 0x0002201f) {  //コプロセッサID=1
          XEiJ.fpuMotherboardCoprocessor.cirWriteWord (a, z);
        } else {
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | XEiJ.mpuDFC << 16 | M68kException.M6E_FSLW_BUS_ERROR_ON_WRITE;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          M68kException.m6eDirection = XEiJ.MPU_WR_WRITE;
          M68kException.m6eSize = XEiJ.MPU_SS_WORD;
          throw M68kException.m6eSignal;
        }
      }
    }
  }  //irpMovesWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVES.L <ea>,Rn                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_010_mmm_rrr-rnnn000000000000
  //MOVES.L Rn,<ea>                                 |-|-12346|P|-----|-----|  M+-WXZ  |0000_111_010_mmm_rrr-rnnn100000000000
  //
  //MOVES.L <ea>,Rn
  //  SFC=1,2,5,6はアドレス変換あり、SFC=0,3,4はアドレス変換なし、
  //  SFC=7はCPU空間なのでコプロセッサが割り当てられている領域以外はバスエラーになる
  //
  //MOVES.L Rn,<ea>
  //  DFC=1,2,5,6はアドレス変換あり、DFC=0,3,4はアドレス変換なし、
  //  DFC=7はCPU空間なのでコプロセッサが割り当てられている領域以外はバスエラーになる
  public static void irpMovesLong () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz
    if (w << -11 != 0) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
    int a = efaMltLong (XEiJ.regOC & 63);
    int n = w >>> 12;  //n
    if (w << 31 - 11 >= 0) {  //MOVES.L <ea>,Rn。リード
      boolean supervisor = (0b10011111 << 24 << XEiJ.mpuSFC) < 0;
      boolean instruction = (0b00101010 << 24 << XEiJ.mpuSFC) < 0;
      MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                                 supervisor ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                                 supervisor ? XEiJ.busSuperMap : XEiJ.busUserMap);
      int z;
      //    01234567
      if (0b01100110 << 24 << XEiJ.mpuSFC < 0) {  //SFC=1,2,5,6。アドレス変換あり
        if ((a & 3) == 0) {  //4の倍数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
                    instruction ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
          //z = XEiJ.busRlsf (pa);
          z = mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRls (pa);
        } else if ((a & 1) == 0) {  //4の倍数+2
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
                    instruction ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
          //z = XEiJ.busRwse (pa) << 16;
          z = mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRws (pa) << 16;
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          pa = (supervisor ?
                instruction ? mmuTranslateReadSuperCode (a + 2) : mmuTranslateReadSuperData (a + 2) :
                instruction ? mmuTranslateReadUserCode (a + 2) : mmuTranslateReadUserData (a + 2));
          //z |= XEiJ.busRwze (pa);
          z |= mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRwz (pa);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
                    instruction ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
          //z = XEiJ.busRbs (pa) << 24;
          z = mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRbs (pa) << 24;
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          pa = (supervisor ?
                instruction ? mmuTranslateReadSuperCode (a + 1) : mmuTranslateReadSuperData (a + 1) :
                instruction ? mmuTranslateReadUserCode (a + 1) : mmuTranslateReadUserData (a + 1));
          //z |= XEiJ.busRwze (pa) << 8;
          z |= mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRwz (pa) << 8;
          pa = (supervisor ?
                instruction ? mmuTranslateReadSuperCode (a + 3) : mmuTranslateReadSuperData (a + 3) :
                instruction ? mmuTranslateReadUserCode (a + 3) : mmuTranslateReadUserData (a + 3));
          //z |= XEiJ.busRbz (pa);
          z |= mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdRbz (pa);
        }
      } else if (XEiJ.mpuSFC != 7) {  //SFC=0,3,4。アドレス変換なし
        if ((a & 3) == 0) {  //4の倍数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16;
          //z = XEiJ.busRlsf (a);
          z = mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRls (a);
        } else if ((a & 1) == 0) {  //4の倍数+2
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16;
          //z = XEiJ.busRwse (a) << 16;
          z = mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a) << 16;
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          a += 2;
          //z |= XEiJ.busRwze (a);
          z |= mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16;
          //z = XEiJ.busRbs (a) << 24;
          z = mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a) << 24;
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          a++;
          //z |= XEiJ.busRwze (a) << 8;
          z |= mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a) << 8;
          a += 2;
          //z |= XEiJ.busRbz (a);
          z |= mm[a >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a);
        }
      } else {  //SFC=7。CPU空間
        if (0x00022000 <= a && a <= 0x0002201f) {  //コプロセッサID=1
          z = XEiJ.fpuMotherboardCoprocessor.cirReadLong (a);
        } else {
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuSFC << 16 | M68kException.M6E_FSLW_BUS_ERROR_ON_READ;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          M68kException.m6eDirection = XEiJ.MPU_WR_READ;
          M68kException.m6eSize = XEiJ.MPU_SS_LONG;
          throw M68kException.m6eSignal;
        }
      }
      XEiJ.regRn[n] = z;
      if (MMU_DEBUG_COMMAND) {
        System.out.printf ("%08x movesReadLong(%d,0x%08x)=0x%08x\n", XEiJ.regPC0, XEiJ.mpuSFC, a, XEiJ.regRn[n]);
      }
    } else {  //MOVES.L Rn,<ea>。ライト
      if (MMU_DEBUG_COMMAND) {
        System.out.printf ("%08x movesWriteLong(%d,0x%08x,0x%08x)\n", XEiJ.regPC0, XEiJ.mpuDFC, a, XEiJ.regRn[n]);
      }
      boolean supervisor = (0b10011111 << 24 << XEiJ.mpuDFC) < 0;
      boolean instruction = (0b00101010 << 24 << XEiJ.mpuDFC) < 0;
      MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                                 supervisor ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                                 supervisor ? XEiJ.busSuperMap : XEiJ.busUserMap);
      int z = XEiJ.regRn[n];
      //    01234567
      if (0b01100110 << 24 << XEiJ.mpuDFC < 0) {  //DFC=1,2,5,6。アドレス変換あり
        if ((a & 3) == 0) {  //4の倍数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
                    instruction ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
          //XEiJ.busWlf (pa, z);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWl (pa, z);
        } else if ((a & 1) == 0) {  //4の倍数+2
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
                    instruction ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
          //XEiJ.busWwe (pa, z >> 16);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWw (pa, z >> 16);
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          pa = (supervisor ?
                instruction ? mmuTranslateWriteSuperCode (a + 2) : mmuTranslateWriteSuperData (a + 2) :
                instruction ? mmuTranslateWriteUserCode (a + 2) : mmuTranslateWriteUserData (a + 2));
          //XEiJ.busWwe (pa, z);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWw (pa, z);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16;
          int pa = (supervisor ?
                    instruction ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
                    instruction ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
          //XEiJ.busWb (pa, z >> 24);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWb (pa, z >> 24);
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          pa = (supervisor ?
                instruction ? mmuTranslateWriteSuperCode (a + 1) : mmuTranslateWriteSuperData (a + 1) :
                instruction ? mmuTranslateWriteUserCode (a + 1) : mmuTranslateWriteUserData (a + 1));
          //XEiJ.busWwe (pa, z >> 8);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWw (pa, z >> 8);
          pa = (supervisor ?
                instruction ? mmuTranslateWriteSuperCode (a + 3) : mmuTranslateWriteSuperData (a + 3) :
                instruction ? mmuTranslateWriteUserCode (a + 3) : mmuTranslateWriteUserData (a + 3));
          //XEiJ.busWb (pa, z);
          mm[pa >>> XEiJ.BUS_PAGE_BITS].mmdWb (pa, z);
        }
      } else if (XEiJ.mpuDFC != 7) {  //DFC=0,3,4。アドレス変換なし
        if ((a & 3) == 0) {  //4の倍数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16;
          //XEiJ.busWlf (a, z);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWl (a, z);
        } else if ((a & 1) == 0) {  //4の倍数+2
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16;
          //XEiJ.busWwe (a, z >> 16);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWw (a, z >> 16);
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          a += 2;
          //XEiJ.busWwe (a, z);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWw (a, z);
        } else {  //奇数
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16;
          //XEiJ.busWb (a, z >> 24);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWb (a, z >> 24);
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
          a++;
          //XEiJ.busWwe (a, z >> 8);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWw (a, z >> 8);
          a += 2;
          //XEiJ.busWb (a, z);
          mm[a >>> XEiJ.BUS_PAGE_BITS].mmdWb (a, z);
        }
      } else {  //DFC=7。CPU空間
        if (0x00022000 <= a && a <= 0x0002201f) {  //コプロセッサID=1
          XEiJ.fpuMotherboardCoprocessor.cirWriteLong (a, z);
        } else {
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | XEiJ.mpuDFC << 16 | M68kException.M6E_FSLW_BUS_ERROR_ON_WRITE;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          M68kException.m6eDirection = XEiJ.MPU_WR_WRITE;
          M68kException.m6eSize = XEiJ.MPU_SS_LONG;
          throw M68kException.m6eSignal;
        }
      }
    }
  }  //irpMovesLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CAS.L Dc,Du,<ea>                                |-|--2346|-|-UUUU|-****|  M+-WXZ  |0000_111_011_mmm_rrr-0000000uuu000ccc        (68060 software emulate misaligned <ea>)
  //CAS2.L Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)              |-|--234S|-|-UUUU|-****|          |0000_111_011_111_100-rnnn000uuu000ccc(1)-rnnn_000_uuu_000_ccc(2)
  public static void irpCasLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea == XEiJ.EA_IM) {  //CAS2.L Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //CAS.L Dc,Du,<ea>
      int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz
      if ((w & ~0b0000_000_111_000_111) != 0) {
        M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
        throw M68kException.m6eSignal;
      }
      int a = efaMltLong (ea);  //a=ea
      if ((a & 1) != 0) {  //misaligned <ea>
        M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
        throw M68kException.m6eSignal;
      }
      int c = w & 7;
      int y = XEiJ.regRn[c];  //y=Dc
      int x = mmuReadLongData (a, XEiJ.regSRS);  //x=<ea>
      int z = x - y;  //z=<ea>-Dc
      XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |
                     (z < 0 ? XEiJ.REG_CCR_N : 0) |
                     (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                     ((x ^ y) & (x ^ z)) >>> 31 << 1 |
                     (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
      if (z == 0) {  //<ea>==Dc
        XEiJ.mpuCycleCount += 19;
        mmuWriteLongData (a, XEiJ.regRn[w >> 6], XEiJ.regSRS);  //Du→<ea>
      } else {  //<ea>!=Dc
        XEiJ.mpuCycleCount += 19;
        XEiJ.regRn[c] = x;  //<ea>→Dc
      }
    }
  }  //irpCasLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,Dq                                  |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_000_mmm_rrr
  public static void irpMoveToDRByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離
    XEiJ.regRn[qqq] = ~255 & XEiJ.regRn[qqq] | 255 & z;
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToDRByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,(Aq)                                |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_010_mmm_rrr
  public static void irpMoveToMMByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    mmuWriteByteData (XEiJ.regRn[XEiJ.regOC >> 9], z, XEiJ.regSRS);  //1qqq=aqq
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToMMByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,(Aq)+                               |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_011_mmm_rrr
  public static void irpMoveToMPByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = XEiJ.regOC >> 9;  //1qqq=aqq
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int a = XEiJ.regRn[aqq];
    if (aqq < 15) {
      M68kException.m6eIncremented += 1L << (aqq << 3);  //longのシフトカウントは6bitでマスクされる
      XEiJ.regRn[aqq] = a + 1;
    } else {
      M68kException.m6eIncremented += 2L << (7 << 3);
      XEiJ.regRn[15] = a + 2;
    }
    mmuWriteByteData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToMPByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,-(Aq)                               |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_100_mmm_rrr
  public static void irpMoveToMNByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = XEiJ.regOC >> 9;  //1qqq=aqq
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int a;
    if (aqq < 15) {
      M68kException.m6eIncremented -= 1L << (aqq << 3);  //longのシフトカウントは6bitでマスクされる
      a = --XEiJ.regRn[aqq];
    } else {
      M68kException.m6eIncremented -= 2L << (7 << 3);
      a = XEiJ.regRn[15] -= 2;
    }
    mmuWriteByteData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToMNByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,(d16,Aq)                            |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_101_mmm_rrr
  public static void irpMoveToMWByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = XEiJ.regOC >> 9;  //1qqq=aqq
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    mmuWriteByteData (XEiJ.regRn[aqq]  //ベースレジスタ
                      + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS),  //pcws。ワードディスプレースメント
                      z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToMWByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,(d8,Aq,Rn.wl)                       |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_qqq_110_mmm_rrr
  public static void irpMoveToMXByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = XEiJ.regOC >> 9;  //1qqq=aqq
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    int t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
              XEiJ.regRn[aqq])  //ベースレジスタ
             + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
                w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
                w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
                mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
    int x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
             (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
              XEiJ.regRn[w >> 12])  //ロングインデックス
             << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
    mmuWriteByteData ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
                      ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
                       mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
                      + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                         (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                         mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)),  //pcls。ロングアウタディスプレースメント
                      z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToMXByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,(xxx).W                             |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_000_111_mmm_rrr
  public static void irpMoveToZWByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離
    mmuWriteByteData (mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS),  //pcws
                      z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToZWByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.B <ea>,(xxx).L                             |-|012346|-|-UUUU|-**00|D M+-WXZPI|0001_001_111_mmm_rrr
  public static void irpMoveToZLByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離
    mmuWriteByteData (mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS),  //pcls
                      z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpMoveToZLByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,Dq                                  |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_000_mmm_rrr
  public static void irpMoveToDRLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z;
    XEiJ.regRn[XEiJ.regOC >> 9 & 7] = z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToDRLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVEA.L <ea>,Aq                                 |-|012346|-|-----|-----|DAM+-WXZPI|0010_qqq_001_mmm_rrr
  //MOVE.L <ea>,Aq                                  |A|012346|-|-----|-----|DAM+-WXZPI|0010_qqq_001_mmm_rrr [MOVEA.L <ea>,Aq]
  public static void irpMoveaLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    XEiJ.regRn[(XEiJ.regOC >> 9) - (16 - 8)] = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。右辺でAqが変化する可能性があることに注意
  }  //irpMoveaLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,(Aq)                                |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_010_mmm_rrr
  public static void irpMoveToMMLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。ここでAqが変化する可能性があることに注意
    mmuWriteLongData (XEiJ.regRn[(XEiJ.regOC >> 9) - (16 - 8)], z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToMMLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,(Aq)+                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_011_mmm_rrr
  public static void irpMoveToMPLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。ここでAqが変化する可能性があることに注意
    int aqq = (XEiJ.regOC >> 9) - (16 - 8);
    M68kException.m6eIncremented += 4L << (aqq << 3);  //longのシフトカウントは6bitでマスクされる
    mmuWriteLongData ((XEiJ.regRn[aqq] += 4) - 4, z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToMPLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,-(Aq)                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_100_mmm_rrr
  public static void irpMoveToMNLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。ここでAqが変化する可能性があることに注意
    int aqq = (XEiJ.regOC >> 9) - (16 - 8);
    M68kException.m6eIncremented -= 4L << (aqq << 3);  //longのシフトカウントは6bitでマスクされる
    mmuWriteLongData ((XEiJ.regRn[aqq] -= 4), z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToMNLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,(d16,Aq)                            |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_101_mmm_rrr
  public static void irpMoveToMWLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。ここでAqが変化する可能性があることに注意
    mmuWriteLongData (XEiJ.regRn[(XEiJ.regOC >> 9) - (16 - 8)]  //ベースレジスタ
           + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS),  //pcws。ワードディスプレースメント
           z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToMWLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,(d8,Aq,Rn.wl)                       |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_qqq_110_mmm_rrr
  public static void irpMoveToMXLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = (XEiJ.regOC >> 9) - (16 - 8);
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。ここでAqが変化する可能性があることに注意
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    int t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
              XEiJ.regRn[aqq])  //ベースレジスタ
             + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
                w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
                w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
                mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
    int x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
             (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
              XEiJ.regRn[w >> 12])  //ロングインデックス
             << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
    mmuWriteLongData ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
           ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
            mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
           + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
              (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)),  //pcls。ロングアウタディスプレースメント
           z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToMXLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,(xxx).W                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_000_111_mmm_rrr
  public static void irpMoveToZWLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ
    mmuWriteLongData (mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS),  //pcws
           z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToZWLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L <ea>,(xxx).L                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0010_001_111_mmm_rrr
  public static void irpMoveToZLLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ
    mmuWriteLongData (mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS),  //pcls
           z, XEiJ.regSRS);
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveToZLLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,Dq                                  |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_000_mmm_rrr
  public static void irpMoveToDRWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //pcws。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ
    XEiJ.regRn[qqq] = ~65535 & XEiJ.regRn[qqq] | (char) z;
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToDRWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVEA.W <ea>,Aq                                 |-|012346|-|-----|-----|DAM+-WXZPI|0011_qqq_001_mmm_rrr
  //MOVE.W <ea>,Aq                                  |A|012346|-|-----|-----|DAM+-WXZPI|0011_qqq_001_mmm_rrr [MOVEA.W <ea>,Aq]
  //
  //MOVEA.W <ea>,Aq
  //  ワードデータをロングに符号拡張してAqの全体を更新する
  public static void irpMoveaWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    XEiJ.regRn[XEiJ.regOC >> 9 & 15] = ea < XEiJ.EA_MM ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //符号拡張して32bit全部書き換える。pcws。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。右辺でAqが変化する可能性があることに注意
  }  //irpMoveaWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,(Aq)                                |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_010_mmm_rrr
  public static void irpMoveToMMWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //pcws。イミディエイトを分離。このr[ea]はデータレジスタまたはアドレスレジスタ。ここでAqが変化する可能性があることに注意
    mmuWriteWordData (XEiJ.regRn[XEiJ.regOC >> 9 & 15], z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToMMWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,(Aq)+                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_011_mmm_rrr
  public static void irpMoveToMPWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int aqq = XEiJ.regOC >> 9 & 15;
    M68kException.m6eIncremented += 2L << (aqq << 3);  //longのシフトカウントは6bitでマスクされる
    mmuWriteWordData ((XEiJ.regRn[aqq] += 2) - 2, z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToMPWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,-(Aq)                               |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_100_mmm_rrr
  public static void irpMoveToMNWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int aqq = XEiJ.regOC >> 9 & 15;
    M68kException.m6eIncremented -= 2L << (aqq << 3);  //longのシフトカウントは6bitでマスクされる
    mmuWriteWordData ((XEiJ.regRn[aqq] -= 2), z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToMNWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,(d16,Aq)                            |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_101_mmm_rrr
  public static void irpMoveToMWWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = XEiJ.regOC >> 9 & 15;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    mmuWriteWordData (XEiJ.regRn[aqq]  //ベースレジスタ
           + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS),  //pcws。ワードディスプレースメント
           z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToMWWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,(d8,Aq,Rn.wl)                       |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_qqq_110_mmm_rrr
  public static void irpMoveToMXWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int aqq = XEiJ.regOC >> 9 & 15;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    int t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
              XEiJ.regRn[aqq])  //ベースレジスタ
             + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
                w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
                w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
                mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
    int x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
             (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
              XEiJ.regRn[w >> 12])  //ロングインデックス
             << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
    mmuWriteWordData ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
           ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
            mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
           + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
              (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)),  //pcls。ロングアウタディスプレースメント
           z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToMXWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,(xxx).W                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_000_111_mmm_rrr
  public static void irpMoveToZWWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離
    mmuWriteWordData (mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS),  //pcws
           z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToZWWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,(xxx).L                             |-|012346|-|-UUUU|-**00|DAM+-WXZPI|0011_001_111_mmm_rrr
  public static void irpMoveToZLWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離
    mmuWriteWordData (mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS),  //pcls
           z, XEiJ.regSRS);
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpMoveToZLWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NEGX.B <ea>                                     |-|012346|-|*UUUU|*****|D M+-WXZ  |0100_000_000_mmm_rrr
  public static void irpNegxByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y;
    int z;
    if (ea < XEiJ.EA_AR) {  //NEGX.B Dr
      XEiJ.mpuCycleCount++;
      z = (byte) (XEiJ.regRn[ea] = ~0xff & (y = XEiJ.regRn[ea]) | 0xff & -(y = (byte) y) - (XEiJ.regCCR >> 4));  //Xの左側はすべて0なのでCCR_X&を省略
    } else {  //NEGX.B <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = (byte) (-(y = mmuModifyByteSignData (a, XEiJ.regSRS)) - (XEiJ.regCCR >> 4)), XEiJ.regSRS);  //Xの左側はすべて0なのでCCR_X&を省略
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_Z : 0) |
           (y & z) >>> 31 << 1 |
           (y | z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_negx
  }  //irpNegxByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NEGX.W <ea>                                     |-|012346|-|*UUUU|*****|D M+-WXZ  |0100_000_001_mmm_rrr
  public static void irpNegxWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y;
    int z;
    if (ea < XEiJ.EA_AR) {  //NEGX.W Dr
      XEiJ.mpuCycleCount++;
      z = (short) (XEiJ.regRn[ea] = ~0xffff & (y = XEiJ.regRn[ea]) | (char) (-(y = (short) y) - (XEiJ.regCCR >> 4)));  //Xの左側はすべて0なのでCCR_X&を省略
    } else {  //NEGX.W <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z = (short) (-(y = mmuModifyWordSignData (a, XEiJ.regSRS)) - (XEiJ.regCCR >> 4)), XEiJ.regSRS);  //Xの左側はすべて0なのでCCR_X&を省略
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_Z : 0) |
           (y & z) >>> 31 << 1 |
           (y | z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_negx
  }  //irpNegxWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NEGX.L <ea>                                     |-|012346|-|*UUUU|*****|D M+-WXZ  |0100_000_010_mmm_rrr
  public static void irpNegxLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y;
    int z;
    if (ea < XEiJ.EA_AR) {  //NEGX.L Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = z = -(y = XEiJ.regRn[ea]) - (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
    } else {  //NEGX.L <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = -(y = mmuModifyLongData (a, XEiJ.regSRS)) - (XEiJ.regCCR >> 4), XEiJ.regSRS);  //Xの左側はすべて0なのでCCR_X&を省略
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_Z : 0) |
           (y & z) >>> 31 << 1 |
           (y | z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_negx
  }  //irpNegxLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W SR,<ea>                                  |-|-12346|P|*****|-----|D M+-WXZ  |0100_000_011_mmm_rrr
  public static void irpMoveFromSR () throws M68kException {
    //MC68010以上では特権命令
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //MOVE.W SR,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = ~0xffff & XEiJ.regRn[ea] | XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR;
    } else {  //MOVE.W SR,<mem>
      XEiJ.mpuCycleCount++;
      mmuWriteWordData (efaMltWord (ea), XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR, 1);
    }
  }  //irpMoveFromSR

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CHK.L <ea>,Dq                                   |-|--2346|-|-UUUU|-*UUU|D M+-WXZPI|0100_qqq_100_mmm_rrr
  public static void irpChkLong () throws M68kException {
    XEiJ.mpuCycleCount += 2;
    int ea = XEiJ.regOC & 63;
    int x = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離
    int y = XEiJ.regRn[XEiJ.regOC >> 9 & 7];
    int z = x - y;
    XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) |
                   (y < 0 ? XEiJ.REG_CCR_N : 0));
    if (y < 0 || x < y) {
      XEiJ.mpuCycleCount += 20 - 19;
      M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
      M68kException.m6eNumber = M68kException.M6E_CHK_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpChkLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CHK.W <ea>,Dq                                   |-|012346|-|-UUUU|-*UUU|D M+-WXZPI|0100_qqq_110_mmm_rrr
  public static void irpChkWord () throws M68kException {
    XEiJ.mpuCycleCount += 2;
    int ea = XEiJ.regOC & 63;
    int x = ea < XEiJ.EA_AR ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //pcws。イミディエイトを分離
    int y = (short) XEiJ.regRn[XEiJ.regOC >> 9 & 7];
    int z = (short) (x - y);
    XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z | XEiJ.REG_CCR_V | XEiJ.REG_CCR_C) |
                   (y < 0 ? XEiJ.REG_CCR_N : 0));
    if (y < 0 || x < y) {
      XEiJ.mpuCycleCount += 20 - 19;
      M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
      M68kException.m6eNumber = M68kException.M6E_CHK_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpChkWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //LEA.L <ea>,Aq                                   |-|012346|-|-----|-----|  M  WXZP |0100_qqq_111_mmm_rrr
  //EXTB.L Dr                                       |-|--2346|-|-UUUU|-**00|D         |0100_100_111_000_rrr
  public static void irpLea () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //EXTB.L Dr
      XEiJ.mpuCycleCount++;
      int z;
      XEiJ.regRn[ea] = z = (byte) XEiJ.regRn[ea];
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else {  //LEA.L <ea>,Aq
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[(XEiJ.regOC >> 9) - (32 - 8)] = efaLeaPea (ea);
    }
  }  //irpLea

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CLR.B <ea>                                      |-|012346|-|-UUUU|-0100|D M+-WXZ  |0100_001_000_mmm_rrr (68000 and 68008 read before clear)
  public static void irpClrByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //CLR.B Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] &= ~0xff;
    } else {  //CLR.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), 0, XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z;  //ccr_clr
  }  //irpClrByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CLR.W <ea>                                      |-|012346|-|-UUUU|-0100|D M+-WXZ  |0100_001_001_mmm_rrr (68000 and 68008 read before clear)
  public static void irpClrWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //CLR.W Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] &= ~0xffff;
    } else {  //CLR.W <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteWordData (efaMltWord (ea), 0, XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z;  //ccr_clr
  }  //irpClrWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CLR.L <ea>                                      |-|012346|-|-UUUU|-0100|D M+-WXZ  |0100_001_010_mmm_rrr (68000 and 68008 read before clear)
  public static void irpClrLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //CLR.L Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = 0;
    } else {  //CLR.L <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteLongData (efaMltLong (ea), 0, XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z;  //ccr_clr
  }  //irpClrLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W CCR,<ea>                                 |-|-12346|-|*****|-----|D M+-WXZ  |0100_001_011_mmm_rrr
  public static void irpMoveFromCCR () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //MOVE.W CCR,Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = ~0xffff & XEiJ.regRn[ea] | XEiJ.regCCR;
    } else {  //MOVE.W CCR,<mem>
      XEiJ.mpuCycleCount++;
      mmuWriteWordData (efaMltWord (ea), XEiJ.regCCR, XEiJ.regSRS);
    }
  }  //irpMoveFromCCR

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NEG.B <ea>                                      |-|012346|-|UUUUU|*****|D M+-WXZ  |0100_010_000_mmm_rrr
  public static void irpNegByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y;
    int z;
    if (ea < XEiJ.EA_AR) {  //NEG.B Dr
      XEiJ.mpuCycleCount++;
      z = (byte) (XEiJ.regRn[ea] = ~0xff & (y = XEiJ.regRn[ea]) | 0xff & -(y = (byte) y));
    } else {  //NEG.B <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = (byte) -(y = mmuModifyByteSignData (a, XEiJ.regSRS)), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           (y & z) >>> 31 << 1 |
           (y | z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_neg
  }  //irpNegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NEG.W <ea>                                      |-|012346|-|UUUUU|*****|D M+-WXZ  |0100_010_001_mmm_rrr
  public static void irpNegWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y;
    int z;
    if (ea < XEiJ.EA_AR) {  //NEG.W Dr
      XEiJ.mpuCycleCount++;
      z = (short) (XEiJ.regRn[ea] = ~0xffff & (y = XEiJ.regRn[ea]) | (char) -(y = (short) y));
    } else {  //NEG.W <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z = (short) -(y = mmuModifyWordSignData (a, XEiJ.regSRS)), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           (y & z) >>> 31 << 1 |
           (y | z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_neg
  }  //irpNegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NEG.L <ea>                                      |-|012346|-|UUUUU|*****|D M+-WXZ  |0100_010_010_mmm_rrr
  public static void irpNegLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y;
    int z;
    if (ea < XEiJ.EA_AR) {  //NEG.L Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = z = -(y = XEiJ.regRn[ea]);
    } else {  //NEG.L <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = -(y = mmuModifyLongData (a, XEiJ.regSRS)), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           (y & z) >>> 31 << 1 |
           (y | z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_neg
  }  //irpNegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,CCR                                 |-|012346|-|UUUUU|*****|D M+-WXZPI|0100_010_011_mmm_rrr
  public static void irpMoveToCCR () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    XEiJ.regCCR = XEiJ.REG_CCR_MASK & (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS));  //pcws。イミディエイトを分離
  }  //irpMoveToCCR

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NOT.B <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_011_000_mmm_rrr
  public static void irpNotByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //NOT.B Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] ^= 255;  //0拡張してからEOR
    } else {  //NOT.B <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = ~mmuModifyByteSignData (a, XEiJ.regSRS), XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpNotByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NOT.W <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_011_001_mmm_rrr
  public static void irpNotWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //NOT.W Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] ^= 65535;  //0拡張してからEOR
    } else {  //NOT.W <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      mmuWriteWordData (a, z = ~mmuModifyWordSignData (a, XEiJ.regSRS), XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpNotWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NOT.L <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_011_010_mmm_rrr
  public static void irpNotLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //NOT.L Dr
      XEiJ.mpuCycleCount++;
      z = XEiJ.regRn[ea] ^= 0xffffffff;
    } else {  //NOT.L <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      mmuWriteLongData (a, z = ~mmuModifyLongData (a, XEiJ.regSRS), XEiJ.regSRS);
    }
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpNotLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.W <ea>,SR                                  |-|012346|P|UUUUU|*****|D M+-WXZPI|0100_011_011_mmm_rrr
  public static void irpMoveToSR () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 12;
    int ea = XEiJ.regOC & 63;
    irpSetSR (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, 1) : mmuReadWordZeroData (efaAnyWord (ea), 1));  //特権違反チェックが先。pcwz。イミディエイトを分離
  }  //irpMoveToSR

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NBCD.B <ea>                                     |-|012346|-|UUUUU|*U*U*|D M+-WXZ  |0100_100_000_mmm_rrr
  //LINK.L Ar,#<data>                               |-|--2346|-|-----|-----|          |0100_100_000_001_rrr-{data}
  //
  //LINK.L Ar,#<data>
  //  PEA.L (Ar);MOVEA.L A7,Ar;ADDA.L #<data>,A7と同じ
  //  LINK.L A7,#<data>はA7をデクリメントする前の値がプッシュされ、A7に#<data>が加算される
  public static void irpNbcd () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //NBCD.B Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = ~0xff & XEiJ.regRn[ea] | irpSbcd (0, XEiJ.regRn[ea]);
    } else if (ea < XEiJ.EA_MM) {  //LINK.L Ar,#<data>
      XEiJ.mpuCycleCount += 2;
      int o = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
      int arr = XEiJ.regOC - (0b0100_100_000_001_000 - 8);
      //評価順序に注意。LINK.L A7,#<data>のときプッシュするのはA7をデクリメントする前の値。wl(r[15]-=4,r[8+rrr])は不可
      int a = XEiJ.regRn[arr];
      M68kException.m6eIncremented -= 4L << (7 << 3);
      int sp = XEiJ.regRn[15] -= 4;
      mmuWriteLongData (sp, a, XEiJ.regSRS);  //pushl
      XEiJ.regRn[arr] = sp;
      XEiJ.regRn[15] = sp + o;
    } else {  //NBCD.B <mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, irpSbcd (0, mmuModifyByteSignData (a, XEiJ.regSRS)), XEiJ.regSRS);
    }
  }  //irpNbcd

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SWAP.W Dr                                       |-|012346|-|-UUUU|-**00|D         |0100_100_001_000_rrr
  //BKPT #<data>                                    |-|-12346|-|-----|-----|          |0100_100_001_001_ddd
  //PEA.L <ea>                                      |-|012346|-|-----|-----|  M  WXZP |0100_100_001_mmm_rrr
  public static void irpPea () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //SWAP.W Dr
      XEiJ.mpuCycleCount++;
      int x;
      int z;
      XEiJ.regRn[ea] = z = (x = XEiJ.regRn[ea]) << 16 | x >>> 16;
      //上位ワードと下位ワードを入れ替えた後のDrをロングでテストする
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else {  //PEA.L <ea>
      XEiJ.mpuCycleCount++;
      //評価順序に注意。実効アドレスを求めてからspをデクリメントすること
      int a = efaLeaPea (ea);  //BKPT #<data>はここでillegal instructionになる
      M68kException.m6eIncremented -= 4L << (7 << 3);
      mmuWriteLongData (XEiJ.regRn[15] -= 4, a, XEiJ.regSRS);
    }
  }  //irpPea

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EXT.W Dr                                        |-|012346|-|-UUUU|-**00|D         |0100_100_010_000_rrr
  //MOVEM.W <list>,<ea>                             |-|012346|-|-----|-----|  M -WXZ  |0100_100_010_mmm_rrr-llllllllllllllll
  public static void irpMovemToMemWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //EXT.W Dr
      XEiJ.mpuCycleCount++;
      int z;
      XEiJ.regRn[ea] = ~0xffff & (z = XEiJ.regRn[ea]) | (char) (z = (byte) z);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else {  //MOVEM.W <list>,<ea>
      int l = mmuReadWordZeroExword (XEiJ.regPC, XEiJ.regSRS);  //pcwze。レジスタリスト。ゼロ拡張
      XEiJ.regPC += 2;
      if (ea >> 3 == XEiJ.MMM_MN) {  //-(Ar)
        //MOVEM.wl <list>,-(Ar)で<list>にArが含まれているとき、000/010は命令開始時のArを、020/030/040/060は命令開始時のAr-オペレーションサイズをメモリに書き込む
        //転送するレジスタが0個のときArは変化しない
        int arr = ea - (XEiJ.EA_MN - 8);
        M68kException.m6eIncremented -= 2L << (arr << 3);  //longのシフトカウントは6bitでマスクされる
        int a = XEiJ.regRn[arr];
        XEiJ.regRn[arr] = a - 2;
        int t = a;
        if (XEiJ.IRP_MOVEM_EXPAND) {  //16回展開する
          if ((l & 0x0001) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[15], XEiJ.regSRS);
          }
          if ((l & 0x0002) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[14], XEiJ.regSRS);
          }
          if ((l & 0x0004) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[13], XEiJ.regSRS);
          }
          if ((l & 0x0008) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[12], XEiJ.regSRS);
          }
          if ((l & 0x0010) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[11], XEiJ.regSRS);
          }
          if ((l & 0x0020) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[10], XEiJ.regSRS);
          }
          if ((l & 0x0040) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 9], XEiJ.regSRS);
          }
          if ((byte) l < 0) {  //(l & 0x0080) != 0
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 8], XEiJ.regSRS);
          }
          if ((l & 0x0100) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 7], XEiJ.regSRS);
          }
          if ((l & 0x0200) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 6], XEiJ.regSRS);
          }
          if ((l & 0x0400) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 5], XEiJ.regSRS);
          }
          if ((l & 0x0800) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 4], XEiJ.regSRS);
          }
          if ((l & 0x1000) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 3], XEiJ.regSRS);
          }
          if ((l & 0x2000) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 2], XEiJ.regSRS);
          }
          if ((l & 0x4000) != 0) {
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 1], XEiJ.regSRS);
          }
          if ((short) l < 0) {  //(l & 0x8000) != 0
            mmuWriteWordData (a -= 2, XEiJ.regRn[ 0], XEiJ.regSRS);
          }
        } else if (XEiJ.IRP_MOVEM_LOOP) {  //16回ループする。コンパイラが展開する
          for (int i = 15; i >= 0; i--) {
            if ((l & 0x8000 >>> i) != 0) {
              mmuWriteWordData (a -= 2, XEiJ.regRn[i], XEiJ.regSRS);
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_LEFT) {  //0になるまで左にシフトする
          l = XEiJ.MPU_BITREV_TABLE_0[l & 2047] | XEiJ.MPU_BITREV_TABLE_1[l << 10 >>> 21];  //Integer.reverse(l)
          for (int i = 15; l != 0; i--, l <<= 1) {
            if (l < 0) {
              mmuWriteWordData (a -= 2, XEiJ.regRn[i], XEiJ.regSRS);
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_RIGHT) {  //0になるまで右にシフトする
          for (int i = 15; l != 0; i--, l >>>= 1) {
            if ((l & 1) != 0) {
              mmuWriteWordData (a -= 2, XEiJ.regRn[i], XEiJ.regSRS);
            }
          }
        } else if (XEiJ.IRP_MOVEM_ZEROS) {  //Integer.numberOfTrailingZerosを使う
          for (int i = 15; l != 0; ) {
            int k = Integer.numberOfTrailingZeros (l);
            mmuWriteWordData (a -= 2, XEiJ.regRn[i -= k], XEiJ.regSRS);
            l = l >>> k & ~1;
          }
        }
        M68kException.m6eIncremented += 2L << (arr << 3);  //元に戻しておく。longのシフトカウントは6bitでマスクされる
        XEiJ.regRn[arr] = a;
        XEiJ.mpuCycleCount += t - a >> 1;  //2バイト/個→1サイクル/個
      } else {  //-(Ar)以外
        int a = efaCltWord (ea);
        int t = a;
        if (XEiJ.IRP_MOVEM_EXPAND) {  //16回展開する
          if ((l & 0x0001) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 0], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0002) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 1], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0004) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 2], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0008) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 3], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0010) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 4], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0020) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 5], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0040) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 6], XEiJ.regSRS);
            a += 2;
          }
          if ((byte) l < 0) {  //(l & 0x0080) != 0
            mmuWriteWordData (a, XEiJ.regRn[ 7], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0100) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 8], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0200) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[ 9], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0400) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[10], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x0800) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[11], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x1000) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[12], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x2000) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[13], XEiJ.regSRS);
            a += 2;
          }
          if ((l & 0x4000) != 0) {
            mmuWriteWordData (a, XEiJ.regRn[14], XEiJ.regSRS);
            a += 2;
          }
          if ((short) l < 0) {  //(l & 0x8000) != 0
            mmuWriteWordData (a, XEiJ.regRn[15], XEiJ.regSRS);
            a += 2;
          }
        } else if (XEiJ.IRP_MOVEM_LOOP) {  //16回ループする。コンパイラが展開する
          for (int i = 0; i <= 15; i++) {
            if ((l & 0x0001 << i) != 0) {
              mmuWriteWordData (a, XEiJ.regRn[i], XEiJ.regSRS);
              a += 2;
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_LEFT) {  //0になるまで左にシフトする
          l = XEiJ.MPU_BITREV_TABLE_0[l & 2047] | XEiJ.MPU_BITREV_TABLE_1[l << 10 >>> 21];  //Integer.reverse(l)
          for (int i = 0; l != 0; i++, l <<= 1) {
            if (l < 0) {
              mmuWriteWordData (a, XEiJ.regRn[i], XEiJ.regSRS);
              a += 2;
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_RIGHT) {  //0になるまで右にシフトする
          for (int i = 0; l != 0; i++, l >>>= 1) {
            if ((l & 1) != 0) {
              mmuWriteWordData (a, XEiJ.regRn[i], XEiJ.regSRS);
              a += 2;
            }
          }
        } else if (XEiJ.IRP_MOVEM_ZEROS) {  //Integer.numberOfTrailingZerosを使う
          for (int i = 0; l != 0; ) {
            int k = Integer.numberOfTrailingZeros (l);
            mmuWriteWordData (a, XEiJ.regRn[i += k], XEiJ.regSRS);
            a += 2;
            l = l >>> k & ~1;
          }
        }
        XEiJ.mpuCycleCount += a - t >> 1;  //2バイト/個→1サイクル/個
      }
    }
  }  //irpMovemToMemWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EXT.L Dr                                        |-|012346|-|-UUUU|-**00|D         |0100_100_011_000_rrr
  //MOVEM.L <list>,<ea>                             |-|012346|-|-----|-----|  M -WXZ  |0100_100_011_mmm_rrr-llllllllllllllll
  public static void irpMovemToMemLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //EXT.L Dr
      XEiJ.mpuCycleCount++;
      int z;
      XEiJ.regRn[ea] = z = (short) XEiJ.regRn[ea];
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else {  //MOVEM.L <list>,<ea>
      int l = mmuReadWordZeroExword (XEiJ.regPC, XEiJ.regSRS);  //pcwze。レジスタリスト。ゼロ拡張
      XEiJ.regPC += 2;
      if (ea >> 3 == XEiJ.MMM_MN) {  //-(Ar)
        //MOVEM.wl <list>,-(Ar)で<list>にArが含まれているとき、000/010は命令開始時のArを、020/030/040/060は命令開始時のAr-オペレーションサイズをメモリに書き込む
        //転送するレジスタが0個のときArは変化しない
        int arr = ea - (XEiJ.EA_MN - 8);
        M68kException.m6eIncremented -= 4L << (arr << 3);  //longのシフトカウントは6bitでマスクされる
        int a = XEiJ.regRn[arr];
        XEiJ.regRn[arr] = a - 4;
        int t = a;
        if (XEiJ.IRP_MOVEM_EXPAND) {  //16回展開する
          if ((l & 0x0001) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[15], XEiJ.regSRS);
          }
          if ((l & 0x0002) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[14], XEiJ.regSRS);
          }
          if ((l & 0x0004) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[13], XEiJ.regSRS);
          }
          if ((l & 0x0008) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[12], XEiJ.regSRS);
          }
          if ((l & 0x0010) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[11], XEiJ.regSRS);
          }
          if ((l & 0x0020) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[10], XEiJ.regSRS);
          }
          if ((l & 0x0040) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 9], XEiJ.regSRS);
          }
          if ((byte) l < 0) {  //(l & 0x0080) != 0
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 8], XEiJ.regSRS);
          }
          if ((l & 0x0100) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 7], XEiJ.regSRS);
          }
          if ((l & 0x0200) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 6], XEiJ.regSRS);
          }
          if ((l & 0x0400) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 5], XEiJ.regSRS);
          }
          if ((l & 0x0800) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 4], XEiJ.regSRS);
          }
          if ((l & 0x1000) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 3], XEiJ.regSRS);
          }
          if ((l & 0x2000) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 2], XEiJ.regSRS);
          }
          if ((l & 0x4000) != 0) {
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 1], XEiJ.regSRS);
          }
          if ((short) l < 0) {  //(l & 0x8000) != 0
            mmuWriteLongData (a -= 4, XEiJ.regRn[ 0], XEiJ.regSRS);
          }
        } else if (XEiJ.IRP_MOVEM_LOOP) {  //16回ループする。コンパイラが展開する
          for (int i = 15; i >= 0; i--) {
            if ((l & 0x8000 >>> i) != 0) {
              mmuWriteLongData (a -= 4, XEiJ.regRn[i], XEiJ.regSRS);
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_LEFT) {  //0になるまで左にシフトする
          l = XEiJ.MPU_BITREV_TABLE_0[l & 2047] | XEiJ.MPU_BITREV_TABLE_1[l << 10 >>> 21];  //Integer.reverse(l)
          for (int i = 15; l != 0; i--, l <<= 1) {
            if (l < 0) {
              mmuWriteLongData (a -= 4, XEiJ.regRn[i], XEiJ.regSRS);
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_RIGHT) {  //0になるまで右にシフトする
          for (int i = 15; l != 0; i--, l >>>= 1) {
            if ((l & 1) != 0) {
              mmuWriteLongData (a -= 4, XEiJ.regRn[i], XEiJ.regSRS);
            }
          }
        } else if (XEiJ.IRP_MOVEM_ZEROS) {  //Integer.numberOfTrailingZerosを使う
          for (int i = 15; l != 0; ) {
            int k = Integer.numberOfTrailingZeros (l);
            mmuWriteLongData (a -= 4, XEiJ.regRn[i -= k], XEiJ.regSRS);
            l = l >>> k & ~1;
          }
        }
        M68kException.m6eIncremented += 4L << (arr << 3);  //元に戻しておく。longのシフトカウントは6bitでマスクされる
        XEiJ.regRn[arr] = a;
        XEiJ.mpuCycleCount += t - a >> 2;  //4バイト/個→1サイクル/個
      } else {  //-(Ar)以外
        int a = efaCltLong (ea);
        int t = a;
        if (XEiJ.IRP_MOVEM_EXPAND) {  //16回展開する
          if ((l & 0x0001) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 0], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0002) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 1], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0004) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 2], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0008) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 3], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0010) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 4], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0020) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 5], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0040) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 6], XEiJ.regSRS);
            a += 4;
          }
          if ((byte) l < 0) {  //(l & 0x0080) != 0
            mmuWriteLongData (a, XEiJ.regRn[ 7], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0100) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 8], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0200) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[ 9], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0400) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[10], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x0800) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[11], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x1000) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[12], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x2000) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[13], XEiJ.regSRS);
            a += 4;
          }
          if ((l & 0x4000) != 0) {
            mmuWriteLongData (a, XEiJ.regRn[14], XEiJ.regSRS);
            a += 4;
          }
          if ((short) l < 0) {  //(l & 0x8000) != 0
            mmuWriteLongData (a, XEiJ.regRn[15], XEiJ.regSRS);
            a += 4;
          }
        } else if (XEiJ.IRP_MOVEM_LOOP) {  //16回ループする。コンパイラが展開する
          for (int i = 0; i <= 15; i++) {
            if ((l & 0x0001 << i) != 0) {
              mmuWriteLongData (a, XEiJ.regRn[i], XEiJ.regSRS);
              a += 4;
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_LEFT) {  //0になるまで左にシフトする
          l = XEiJ.MPU_BITREV_TABLE_0[l & 2047] | XEiJ.MPU_BITREV_TABLE_1[l << 10 >>> 21];  //Integer.reverse(l)
          for (int i = 0; l != 0; i++, l <<= 1) {
            if (l < 0) {
              mmuWriteLongData (a, XEiJ.regRn[i], XEiJ.regSRS);
              a += 4;
            }
          }
        } else if (XEiJ.IRP_MOVEM_SHIFT_RIGHT) {  //0になるまで右にシフトする
          for (int i = 0; l != 0; i++, l >>>= 1) {
            if ((l & 1) != 0) {
              mmuWriteLongData (a, XEiJ.regRn[i], XEiJ.regSRS);
              a += 4;
            }
          }
        } else if (XEiJ.IRP_MOVEM_ZEROS) {  //Integer.numberOfTrailingZerosを使う
          for (int i = 0; l != 0; ) {
            int k = Integer.numberOfTrailingZeros (l);
            mmuWriteLongData (a, XEiJ.regRn[i += k], XEiJ.regSRS);
            a += 4;
            l = l >>> k & ~1;
          }
        }
        XEiJ.mpuCycleCount += a - t >> 2;  //4バイト/個→1サイクル/個
      }
    }
  }  //irpMovemToMemLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //TST.B <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_000_mmm_rrr
  //TST.B <ea>                                      |-|--2346|-|-UUUU|-**00|        PI|0100_101_000_mmm_rrr
  public static void irpTstByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS))];  //ccr_tst_byte。pcbs。イミディエイトを分離。アドレッシングモードに注意
  }  //irpTstByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //TST.W <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_001_mmm_rrr
  //TST.W <ea>                                      |-|--2346|-|-UUUU|-**00| A      PI|0100_101_001_mmm_rrr
  public static void irpTstWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //pcws。イミディエイトを分離。アドレッシングモードに注意。このr[ea]はデータレジスタまたはアドレスレジスタ
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpTstWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //TST.L <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_010_mmm_rrr
  //TST.L <ea>                                      |-|--2346|-|-UUUU|-**00| A      PI|0100_101_010_mmm_rrr
  public static void irpTstLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離。アドレッシングモードに注意。このr[ea]はデータレジスタまたはアドレスレジスタ
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpTstLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //TAS.B <ea>                                      |-|012346|-|-UUUU|-**00|D M+-WXZ  |0100_101_011_mmm_rrr
  //ILLEGAL                                         |-|012346|-|-----|-----|          |0100_101_011_111_100
  public static void irpTas () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //TAS.B Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] = 0x80 | (z = XEiJ.regRn[ea]);
    } else {  //TAS.B <mem>
      XEiJ.mpuCycleCount += 17;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, 0x80 | (z = mmuModifyByteSignData (a, XEiJ.regSRS)), XEiJ.regSRS);
    }
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
  }  //irpTas

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MULU.L <ea>,Dl                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll000000000hhh        (h is not used)
  //MULU.L <ea>,Dh:Dl                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll010000000hhh        (if h=l then result is not defined)
  //MULS.L <ea>,Dl                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll100000000hhh        (h is not used)
  //MULS.L <ea>,Dh:Dl                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_000_mmm_rrr-0lll110000000hhh        (if h=l then result is not defined)
  public static void irpMuluMulsLong () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0111_110_000_000_111) != 0) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    if ((w & 0b0000_010_000_000_000) != 0) {  //64bit積
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    //32bit積
    int s = w & 0b0000_100_000_000_000;  //0=MULU,1=MULS
    int l = w >> 12;  //被乗数,積
    XEiJ.mpuCycleCount += 2;
    int ea = XEiJ.regOC & 63;
    long yy = (long) (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS));  //pcls。イミディエイトを分離
    long xx = (long) XEiJ.regRn[l];
    if (s == 0) {  //MULU
      long zz = (0xffffffffL & xx) * (0xffffffffL & yy);
      int z = XEiJ.regRn[l] = (int) zz;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | (zz >>> 32 != 0L ? XEiJ.REG_CCR_V : 0);
    } else {  //MULS
      long zz = xx * yy;
      int z = XEiJ.regRn[l] = (int) zz;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | (z != zz ? XEiJ.REG_CCR_V : 0);
    }
  }  //irpMuluMulsLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //DIVU.L <ea>,Dq                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq000000000qqq
  //DIVUL.L <ea>,Dr:Dq                              |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq000000000rrr        (q is not equal to r)
  //DIVU.L <ea>,Dr:Dq                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq010000000rrr        (q is not equal to r)
  //DIVS.L <ea>,Dq                                  |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq100000000qqq
  //DIVSL.L <ea>,Dr:Dq                              |-|--2346|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq100000000rrr        (q is not equal to r)
  //DIVS.L <ea>,Dr:Dq                               |-|--234S|-|-UUUU|-***0|D M+-WXZPI|0100_110_001_mmm_rrr-0qqq110000000rrr        (q is not equal to r)
  //
  //DIVS.L <ea>,Dq
  //  32bit被除数Dq/32bit除数<ea>→32bit商Dq
  //
  //DIVS.L <ea>,Dr:Dq
  //  64bit被除数Dr:Dq/32bit除数<ea>→32bit余りDr:32bit商Dq
  //  M68000PRMでDIVS.Lのアドレッシングモードがデータ可変と書かれているのはデータの間違い
  //
  //DIVSL.L <ea>,Dr:Dq
  //  32bit被除数Dq/32bit除数<ea>→32bit余りDr:32bit商Dq
  //
  //DIVU.L <ea>,Dq
  //  32bit被除数Dq/32bit除数<ea>→32bit商Dq
  //
  //DIVU.L <ea>,Dr:Dq
  //  64bit被除数Dr:Dq/32bit除数<ea>→32bit余りDr:32bit商Dq
  //
  //DIVUL.L <ea>,Dr:Dq
  //  32bit被除数Dq/32bit除数<ea>→32bit余りDr:32bit商Dq
  public static void irpDivuDivsLong () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0111_110_000_000_111) != 0) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    if ((w & 0b0000_010_000_000_000) != 0) {  //64bit被除数
      M68kException.m6eNumber = M68kException.M6E_UNIMPLEMENTED_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    //32bit被除数
    int s = w & 0b0000_100_000_000_000;  //0=DIVU,1=DIVS
    int h = w & 7;  //余り
    int l = w >> 12;  //被除数,商
    int ea = XEiJ.regOC & 63;
    int y = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //除数。pcls。イミディエイトを分離
    if (s == 0) {  //符号なし。DIVU.L <ea>,*
      XEiJ.mpuCycleCount += 38;  //最大
      long yy = (long) y & 0xffffffffL;  //除数
      if (y == 0) {  //ゼロ除算
        XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z | XEiJ.REG_CCR_V)  //XとNとZとVは変化しない
                       );  //Cは常にクリア
        XEiJ.mpuCycleCount += 38 - 34;
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_DIVIDE_BY_ZERO;
        throw M68kException.m6eSignal;
      }  //if ゼロ除算
      long xx = (long) XEiJ.regRn[l] & 0xffffffffL;  //被除数
      long zz = (long) ((double) xx / (double) yy);  //double→intのキャストは飽和変換で0xffffffff/0x00000001が0x7fffffffになってしまうのでdouble→longとする
      int z = XEiJ.regRn[l] = (int) zz;  //商
      if (h != l) {
        XEiJ.regRn[h] = (int) (xx - yy * zz);  //余り
      }
      XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |  //Xは変化しない
                     (z < 0 ? XEiJ.REG_CCR_N : 0) |  //Nは商が負のときセット、さもなくばクリア
                     (z == 0 ? XEiJ.REG_CCR_Z : 0)  //Zは商が0のときセット、さもなくばクリア
                     );  //VとCは常にクリア
    } else {  //符号あり。DIVS.L <ea>,*
      XEiJ.mpuCycleCount += 38;  //最大
      long yy = (long) y;  //除数
      if (y == 0) {  //ゼロ除算
        XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z | XEiJ.REG_CCR_V)  //XとNとZとVは変化しない
                       );  //Cは常にクリア
        XEiJ.mpuCycleCount += 38 - 34;
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_DIVIDE_BY_ZERO;
        throw M68kException.m6eSignal;
      }  //if ゼロ除算
      long xx = (long) XEiJ.regRn[l];  //被除数
      long zz = xx / yy;  //商
      if ((int) zz != zz) {  //オーバーフローあり
        //Dqは変化しない
        XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z) |  //XとNとZは変化しない
                       XEiJ.REG_CCR_V  //Vは常にセット
                       );  //Cは常にクリア
      } else {  //オーバーフローなし
        int z = XEiJ.regRn[l] = (int) zz;  //商
        if (h != l) {  //DIVSL.L <ea>,Dr:Dq
          XEiJ.regRn[h] = (int) (xx - yy * zz);  //余り
        }
        XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |  //Xは変化しない
                       (z < 0 ? XEiJ.REG_CCR_N : 0) |  //Nは商が負のときセット、さもなくばクリア
                       (z == 0 ? XEiJ.REG_CCR_Z : 0)  //Zは商が0のときセット、さもなくばクリア
                       );  //VとCは常にクリア
      }  //if オーバーフローあり/オーバーフローなし
    }  //if 符号なし/符号あり
  }  //irpDivuDivsLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SATS.L Dr                                       |-|------|-|-UUUU|-**00|D         |0100_110_010_000_rrr (ISA_B)
  //MOVEM.W <ea>,<list>                             |-|012346|-|-----|-----|  M+ WXZP |0100_110_010_mmm_rrr-llllllllllllllll
  //
  //SATS.L Dr
  //  VがセットされていたらDrを符号が逆で絶対値が最大の値にする(直前のDrに対する演算を飽和演算にする)
  public static void irpMovemToRegWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //SATS.L Dr
      XEiJ.mpuCycleCount++;
      int z = XEiJ.regRn[ea];
      if (XEiJ.TEST_BIT_1_SHIFT ? XEiJ.regCCR << 31 - 1 < 0 : (XEiJ.regCCR & XEiJ.REG_CCR_V) != 0) {  //Vがセットされているとき
        XEiJ.regRn[ea] = z = z >> 31 ^ 0x80000000;  //符号が逆で絶対値が最大の値にする
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else {  //MOVEM.W <ea>,<list>
      int l = mmuReadWordZeroExword (XEiJ.regPC, XEiJ.regSRS);  //pcwze。レジスタリスト。ゼロ拡張
      XEiJ.regPC += 2;
      int arr, a;
      if (ea >> 3 == XEiJ.MMM_MP) {  //(Ar)+
        arr = ea - (XEiJ.EA_MP - 8);
        a = XEiJ.regRn[arr];
      } else {  //(Ar)+以外
        arr = 16;
        a = efaCntWord (ea);
      }
      int t = a;
      if (XEiJ.IRP_MOVEM_EXPAND) {  //16回展開する
        if ((l & 0x0001) != 0) {
          XEiJ.regRn[ 0] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0002) != 0) {
          XEiJ.regRn[ 1] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0004) != 0) {
          XEiJ.regRn[ 2] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0008) != 0) {
          XEiJ.regRn[ 3] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0010) != 0) {
          XEiJ.regRn[ 4] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0020) != 0) {
          XEiJ.regRn[ 5] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0040) != 0) {
          XEiJ.regRn[ 6] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((byte) l < 0) {  //(l & 0x0080) != 0
          XEiJ.regRn[ 7] = mmuReadWordSignData (a, XEiJ.regSRS);  //データレジスタも符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0100) != 0) {
          XEiJ.regRn[ 8] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0200) != 0) {
          XEiJ.regRn[ 9] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0400) != 0) {
          XEiJ.regRn[10] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x0800) != 0) {
          XEiJ.regRn[11] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x1000) != 0) {
          XEiJ.regRn[12] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x2000) != 0) {
          XEiJ.regRn[13] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((l & 0x4000) != 0) {
          XEiJ.regRn[14] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
        if ((short) l < 0) {  //(l & 0x8000) != 0
          XEiJ.regRn[15] = mmuReadWordSignData (a, XEiJ.regSRS);  //符号拡張して32bit全部書き換える
          a += 2;
        }
      } else if (XEiJ.IRP_MOVEM_LOOP) {  //16回ループする。コンパイラが展開する
        for (int i = 0; i <= 15; i++) {
          if ((l & 0x0001 << i) != 0) {
            XEiJ.regRn[i] = mmuReadWordSignData (a, XEiJ.regSRS);  //(データレジスタも)符号拡張して32bit全部書き換える
            a += 2;
          }
        }
      } else if (XEiJ.IRP_MOVEM_SHIFT_LEFT) {  //0になるまで左にシフトする
        l = XEiJ.MPU_BITREV_TABLE_0[l & 2047] | XEiJ.MPU_BITREV_TABLE_1[l << 10 >>> 21];  //Integer.reverse(l)
        for (int i = 0; l != 0; i++, l <<= 1) {
          if (l < 0) {
            XEiJ.regRn[i] = mmuReadWordSignData (a, XEiJ.regSRS);  //(データレジスタも)符号拡張して32bit全部書き換える
            a += 2;
          }
        }
      } else if (XEiJ.IRP_MOVEM_SHIFT_RIGHT) {  //0になるまで右にシフトする
        for (int i = 0; l != 0; i++, l >>>= 1) {
          if ((l & 1) != 0) {
            XEiJ.regRn[i] = mmuReadWordSignData (a, XEiJ.regSRS);  //(データレジスタも)符号拡張して32bit全部書き換える
            a += 2;
          }
        }
      } else if (XEiJ.IRP_MOVEM_ZEROS) {  //Integer.numberOfTrailingZerosを使う
        for (int i = 0; l != 0; ) {
          int k = Integer.numberOfTrailingZeros (l);
          XEiJ.regRn[i += k] = mmuReadWordSignData (a, XEiJ.regSRS);  //(データレジスタも)符号拡張して32bit全部書き換える
          a += 2;
          l = l >>> k & ~1;
        }
      }
      //MOVEM.W (Ar)+,<list>で<list>にArが含まれているとき、メモリから読み出したデータを捨ててArをインクリメントする
      XEiJ.regRn[arr] = a;
      XEiJ.mpuCycleCount += a - t >> 1;  //2バイト/個→1サイクル/個
    }
  }  //irpMovemToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVEM.L <ea>,<list>                             |-|012346|-|-----|-----|  M+ WXZP |0100_110_011_mmm_rrr-llllllllllllllll
  public static void irpMovemToRegLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    {
      int l = mmuReadWordZeroExword (XEiJ.regPC, XEiJ.regSRS);  //pcwze。レジスタリスト。ゼロ拡張
      XEiJ.regPC += 2;
      int arr, a;
      if (ea >> 3 == XEiJ.MMM_MP) {  //(Ar)+
        arr = ea - (XEiJ.EA_MP - 8);
        a = XEiJ.regRn[arr];
      } else {  //(Ar)+以外
        arr = 16;
        a = efaCntLong (ea);
      }
      int t = a;
      if (XEiJ.IRP_MOVEM_EXPAND) {  //16回展開する
        if ((l & 0x0001) != 0) {
          XEiJ.regRn[ 0] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0002) != 0) {
          XEiJ.regRn[ 1] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0004) != 0) {
          XEiJ.regRn[ 2] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0008) != 0) {
          XEiJ.regRn[ 3] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0010) != 0) {
          XEiJ.regRn[ 4] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0020) != 0) {
          XEiJ.regRn[ 5] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0040) != 0) {
          XEiJ.regRn[ 6] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((byte) l < 0) {  //(l & 0x0080) != 0
          XEiJ.regRn[ 7] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0100) != 0) {
          XEiJ.regRn[ 8] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0200) != 0) {
          XEiJ.regRn[ 9] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0400) != 0) {
          XEiJ.regRn[10] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x0800) != 0) {
          XEiJ.regRn[11] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x1000) != 0) {
          XEiJ.regRn[12] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x2000) != 0) {
          XEiJ.regRn[13] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((l & 0x4000) != 0) {
          XEiJ.regRn[14] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
        if ((short) l < 0) {  //(l & 0x8000) != 0
          XEiJ.regRn[15] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
        }
      } else if (XEiJ.IRP_MOVEM_LOOP) {  //16回ループする。コンパイラが展開する
        for (int i = 0; i <= 15; i++) {
          if ((l & 0x0001 << i) != 0) {
            XEiJ.regRn[i] = mmuReadLongData (a, XEiJ.regSRS);
            a += 4;
          }
        }
      } else if (XEiJ.IRP_MOVEM_SHIFT_LEFT) {  //0になるまで左にシフトする
        l = XEiJ.MPU_BITREV_TABLE_0[l & 2047] | XEiJ.MPU_BITREV_TABLE_1[l << 10 >>> 21];  //Integer.reverse(l)
        for (int i = 0; l != 0; i++, l <<= 1) {
          if (l < 0) {
            XEiJ.regRn[i] = mmuReadLongData (a, XEiJ.regSRS);
            a += 4;
          }
        }
      } else if (XEiJ.IRP_MOVEM_SHIFT_RIGHT) {  //0になるまで右にシフトする
        for (int i = 0; l != 0; i++, l >>>= 1) {
          if ((l & 1) != 0) {
            XEiJ.regRn[i] = mmuReadLongData (a, XEiJ.regSRS);
            a += 4;
          }
        }
      } else if (XEiJ.IRP_MOVEM_ZEROS) {  //Integer.numberOfTrailingZerosを使う
        for (int i = 0; l != 0; ) {
          int k = Integer.numberOfTrailingZeros (l);
          XEiJ.regRn[i += k] = mmuReadLongData (a, XEiJ.regSRS);
          a += 4;
          l = l >>> k & ~1;
        }
      }
      //MOVEM.L (Ar)+,<list>で<list>にArが含まれているとき、メモリから読み出したデータを捨ててArをインクリメントする
      XEiJ.regRn[arr] = a;
      XEiJ.mpuCycleCount += a - t >> 2;  //4バイト/個→1サイクル/個
    }
  }  //irpMovemToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //TRAP #<vector>                                  |-|012346|-|-----|-----|          |0100_111_001_00v_vvv
  public static void irpTrap () throws M68kException {
    irpExceptionFormat0 (XEiJ.regOC - (0b0100_111_001_000_000 - M68kException.M6E_TRAP_0_INSTRUCTION_VECTOR) << 2, XEiJ.regPC);  //pcは次の命令
  }  //irpTrap
  public static void irpTrap15 () throws M68kException {
    if ((XEiJ.regRn[0] & 255) == 0x8e) {  //IOCS _BOOTINF
      MainMemory.mmrCheckHuman ();
    }
    irpExceptionFormat0 (M68kException.M6E_TRAP_15_INSTRUCTION_VECTOR << 2, XEiJ.regPC);  //pcは次の命令
  }  //irpTrap15

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //LINK.W Ar,#<data>                               |-|012346|-|-----|-----|          |0100_111_001_010_rrr-{data}
  //
  //LINK.W Ar,#<data>
  //  PEA.L (Ar);MOVEA.L A7,Ar;ADDA.W #<data>,A7と同じ
  //  LINK.W A7,#<data>はA7をデクリメントする前の値がプッシュされ、A7に#<data>が加算される
  public static void irpLinkWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int o = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    int arr = XEiJ.regOC - (0b0100_111_001_010_000 - 8);
    //評価順序に注意。LINK.W A7,#<data>のときプッシュするのはA7をデクリメントする前の値。wl(r[15]-=4,r[8+rrr])は不可
    int a = XEiJ.regRn[arr];
    M68kException.m6eIncremented -= 4L << (7 << 3);
    int sp = XEiJ.regRn[15] -= 4;
    mmuWriteLongData (sp, a, XEiJ.regSRS);  //pushl
    XEiJ.regRn[arr] = sp;
    XEiJ.regRn[15] = sp + o;
  }  //irpLinkWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //UNLK Ar                                         |-|012346|-|-----|-----|          |0100_111_001_011_rrr
  //
  //UNLK Ar
  //  MOVEA.L Ar,A7;MOVEA.L (A7)+,Arと同じ
  //  UNLK A7はMOVEA.L A7,A7;MOVEA.L (A7)+,A7すなわちMOVEA.L (A7),A7と同じ
  //  ソースオペランドのポストインクリメントはデスティネーションオペランドが評価される前に完了しているとみなされる
  //    例えばMOVE.L (A0)+,(A0)+はMOVE.L (A0),(4,A0);ADDQ.L #8,A0と同じ
  //    MOVEA.L (A0)+,A0はポストインクリメントされたA0が(A0)から読み出された値で上書きされるのでMOVEA.L (A0),A0と同じ
  //  M68000PRMにUNLK Anの動作はAn→SP;(SP)→An;SP+4→SPだと書かれているがこれはn=7の場合に当てはまらない
  //  余談だが68040の初期のマスクセットはUNLK A7を実行すると固まるらしい
  public static void irpUnlk () throws M68kException {
    XEiJ.mpuCycleCount += 2;
    int arr = XEiJ.regOC - (0b0100_111_001_011_000 - 8);
    //評価順序に注意
    int sp = XEiJ.regRn[arr];
    //  UNLK ArはMOVEA.L Ar,A7;MOVEA.L (A7)+,Arと同じ
    //  (A7)+がページフォルトになってリトライするとき
    //    Arはまだ更新されておらず、リトライでMOVEA.L Ar,A7が再実行されるので、A7を巻き戻す必要はない
    M68kException.m6eIncremented += 4L << (7 << 3);  //UNLK A7でページフォルトが発生したときA7が増えすぎないようにする
    XEiJ.regRn[15] = sp + 4;
    XEiJ.regRn[arr] = mmuReadLongData (sp, XEiJ.regSRS);  //popls
  }  //irpUnlk

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L Ar,USP                                   |-|012346|P|-----|-----|          |0100_111_001_100_rrr
  public static void irpMoveToUsp () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 2;
    XEiJ.mpuUSP = XEiJ.regRn[XEiJ.regOC - (0b0100_111_001_100_000 - 8)];
  }  //irpMoveToUsp

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE.L USP,Ar                                   |-|012346|P|-----|-----|          |0100_111_001_101_rrr
  public static void irpMoveFromUsp () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
    XEiJ.regRn[XEiJ.regOC - (0b0100_111_001_101_000 - 8)] = XEiJ.mpuUSP;
  }  //irpMoveFromUsp

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //RESET                                           |-|012346|P|-----|-----|          |0100_111_001_110_000
  public static void irpReset () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 45;
    XEiJ.irpReset ();
  }  //irpReset

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //NOP                                             |-|012346|-|-----|-----|          |0100_111_001_110_001
  public static void irpNop () throws M68kException {
    XEiJ.mpuCycleCount += 9;
    //何もしない
  }  //irpNop

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //STOP #<data>                                    |-|012346|P|UUUUU|*****|          |0100_111_001_110_010-{data}
  //
  //STOP #<data>
  //    1. #<data>をsrに設定する
  //    2. pcを進める
  //    3. 以下のいずれかの条件が成立するまで停止する
  //      3a. トレース
  //      3b. マスクされているレベルよりも高い割り込み要求
  //      3c. リセット
  //  コアと一緒にデバイスを止めるわけにいかないので、ここでは条件が成立するまで同じ命令を繰り返すループ命令として実装する
  public static void irpStop () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
    irpSetSR (mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, 1));  //pcws。特権違反チェックが先
    if (XEiJ.mpuTraceFlag == 0) {  //トレースまたはマスクされているレベルよりも高い割り込み要求がない
      XEiJ.regPC = XEiJ.regPC0;  //ループ
      //任意の負荷率を100%に設定しているときSTOP命令が軽すぎると動作周波数が大きくなりすぎて割り込みがかかったとき次に進めなくなる
      //負荷率の計算にSTOP命令で止まっていた時間を含めないことにする
      XEiJ.mpuClockTime += XEiJ.TMR_FREQ * 4 / 1000000;  //4μs。50MHzのとき200clk
      XEiJ.mpuLastNano += 4000L;
    }
  }  //irpStop

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //RTE                                             |-|012346|P|UUUUU|*****|          |0100_111_001_110_011
  public static void irpRte () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 17;
    int sp = XEiJ.regRn[15];
    int newSR = mmuReadWordZeroData (sp, 1);  //popwz
    int newPC = mmuReadLongData (sp + 2, 1);  //popls
    int format = mmuReadWordZeroData (sp + 6, 1) >> 12;
    if (format == 0) {  //010,020,030,040,060
      XEiJ.regRn[15] = sp + 8;
    } else if (format == 2 ||  //020,030,040,060
               format == 3) {  //040,060
      XEiJ.regRn[15] = sp + 12;
    } else if (format == 4) {  //060
      XEiJ.regRn[15] = sp + 16;
    } else {
      M68kException.m6eNumber = M68kException.M6E_FORMAT_ERROR;
      throw M68kException.m6eSignal;
    }
    //irpSetSRでモードが切り替わる場合があるのでその前にr[15]を更新しておくこと
    irpSetSR (newSR);  //ここでユーザモードに戻る場合がある。特権違反チェックが先
    irpSetPC (newPC);  //分岐ログが新しいsrを使う。順序に注意。ここでアドレスエラーが発生する場合がある
  }  //irpRte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //RTD #<data>                                     |-|-12346|-|-----|-----|          |0100_111_001_110_100-{data}
  public static void irpRtd () throws M68kException {
    XEiJ.mpuCycleCount += 7;
    int sp = XEiJ.regRn[15];
    int o = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    irpSetPC (mmuReadLongData (sp, XEiJ.regSRS));  //popls
    XEiJ.regRn[15] = sp + 4 + o;
  }  //irpRtd

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //RTS                                             |-|012346|-|-----|-----|          |0100_111_001_110_101
  public static void irpRts () throws M68kException {
    XEiJ.mpuCycleCount += 7;
    int sp = XEiJ.regRn[15];
    irpSetPC (mmuReadLongData (sp, XEiJ.regSRS));  //popls
    XEiJ.regRn[15] = sp + 4;
  }  //irpRts

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //TRAPV                                           |-|012346|-|---*-|-----|          |0100_111_001_110_110
  public static void irpTrapv () throws M68kException {
    if (XEiJ.TEST_BIT_1_SHIFT ? XEiJ.regCCR << 31 - 1 >= 0 : (XEiJ.regCCR & XEiJ.REG_CCR_V) == 0) {  //通過
      XEiJ.mpuCycleCount++;
    } else {
      M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
      M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpTrapv

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //RTR                                             |-|012346|-|UUUUU|*****|          |0100_111_001_110_111
  public static void irpRtr () throws M68kException {
    XEiJ.mpuCycleCount += 8;
    int sp = XEiJ.regRn[15];
    int w = mmuReadWordZeroData (sp, XEiJ.regSRS);  //popwz
    irpSetPC (mmuReadLongData (sp + 2, XEiJ.regSRS));  //popls
    XEiJ.regCCR = XEiJ.REG_CCR_MASK & w;
    XEiJ.regRn[15] = sp + 6;
  }  //irpRtr

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVEC.L Rc,Rn                                   |-|-12346|P|-----|-----|          |0100_111_001_111_010-rnnncccccccccccc
  public static void irpMovecFromControl () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, 1);  //pcwz。拡張ワード
    switch (w & 0x0fff) {
    case 0x000:  //SFC
      XEiJ.mpuCycleCount += 12;
      XEiJ.regRn[w >> 12] = XEiJ.mpuSFC;
      break;
    case 0x001:  //DFC
      XEiJ.mpuCycleCount += 12;
      XEiJ.regRn[w >> 12] = XEiJ.mpuDFC;
      break;
    case 0x002:  //CACR
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = XEiJ.mpuCACR & 0xf880e000;  //CABCとCUBCのリードは常に0
      break;
    case 0x003:  //TCR
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetTCR ();
      break;
    case 0x004:  //ITT0
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetITT0 ();
      break;
    case 0x005:  //ITT1
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetITT1 ();
      break;
    case 0x006:  //DTT0
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetDTT0 ();
      break;
    case 0x007:  //DTT1
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetDTT1 ();
      break;
    case 0x008:  //BUSCR
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = XEiJ.mpuBUSCR;
      break;
    case 0x800:  //USP
      XEiJ.mpuCycleCount += 12;
      XEiJ.regRn[w >> 12] = XEiJ.mpuUSP;
      break;
    case 0x801:  //VBR
      XEiJ.mpuCycleCount += 12;
      XEiJ.regRn[w >> 12] = XEiJ.mpuVBR;
      break;
    case 0x806:  //URP
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetURP ();;
      break;
    case 0x807:  //SRP
      XEiJ.mpuCycleCount += 15;
      XEiJ.regRn[w >> 12] = mmuGetSRP ();;
      break;
    case 0x808:  //PCR
      XEiJ.mpuCycleCount += 12;
      XEiJ.regRn[w >> 12] = XEiJ.mpuPCR;
      break;
    default:
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpMovecFromControl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVEC.L Rn,Rc                                   |-|-12346|P|-----|-----|          |0100_111_001_111_011-rnnncccccccccccc
  public static void irpMovecToControl () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, 1);  //pcwz。拡張ワード
    int d = XEiJ.regRn[w >> 12];
    switch (w & 0x0fff) {
    case 0x000:  //SFC
      XEiJ.mpuCycleCount += 11;
      XEiJ.mpuSFC = d & 0x00000007;
      break;
    case 0x001:  //DFC
      XEiJ.mpuCycleCount += 11;
      XEiJ.mpuDFC = d & 0x00000007;
      break;
    case 0x002:  //CACR
      //  CACR
      //   31  30  29  28  27 26 25 24   23   22   21 20 19 18 17 16   15  14  13 12 11 10 9 8  7 6 5 4 3 2 1 0
      //  EDC NAD ESB DPI FOC  0  0  0  EBC CABC CUBC  0  0  0  0  0  EIC NAI FIC  0  0  0 0 0  0 0 0 0 0 0 0 0
      //    bit31  EDC   Enable Data Cache
      //                 データキャッシュ有効
      //                 4ウェイセットアソシアティブ。16バイト/ライン*128ライン/セット*4セット=8KB
      //    bit30  NAD   No Allocate Mode (Data Cache)
      //                 データキャッシュでミスしても新しいキャッシュラインをアロケートしない
      //    bit29  ESB   Enable Store Buffer
      //                 ストアバッファ有効
      //                 ライトスルーおよびキャッシュ禁止インプリサイスのページの書き込みを4エントリ(16バイト)のFIFOバッファで遅延させる
      //                 例えば4の倍数のアドレスから始まる4バイトに連続して書き込むと1回のロングの書き込みにまとめられる
      //    bit28  DPI   Disable CPUSH Invalidation
      //                 CPUSHでプッシュされたキャッシュラインを無効化しない
      //    bit27  FOC   1/2 Cache Operation Mode Enable (Data Cache)
      //                 データキャッシュを1/2キャッシュモードにする
      //    bit23  EBC   Enable Branch Cache
      //                 分岐キャッシュ有効
      //                 256エントリの分岐キャッシュを用いて分岐予測を行う
      //                 正しく予測された分岐は前後の命令に隠れて実質0サイクルで実行される
      //                   MC68060は最大3個の命令(1個の分岐命令と2個の整数命令)を1サイクルで実行できる
      //                   MC68000(10MHz)とMC68060(50MHz)の処理速度の比は局所的に100倍を超えることがある
      //    bit22  CABC  Clear All Entries in the Branch Cache
      //                 分岐キャッシュのすべてのエントリをクリアする
      //                 分岐命令以外の場所で分岐キャッシュがヒットしてしまったときに発生する分岐予測エラーから復帰するときに使う
      //                 CABCはライトオンリーでリードは常に0
      //    bit21  CUBC  Clear All User Entries in the Branch Cache
      //                 分岐キャッシュのすべてのユーザエントリをクリアする
      //                 CUBCはライトオンリーでリードは常に0
      //    bit15  EIC   Enable Instruction Cache
      //                 命令キャッシュ有効
      //                 4ウェイセットアソシアティブ。16バイト/ライン*128ライン/セット*4セット=8KB
      //    bit14  NAI   No Allocate Mode (Instruction Cache)
      //                 命令キャッシュでミスしても新しいキャッシュラインをアロケートしない
      //    bit13  FIC   1/2 Cache Operation Mode Enable (Instruction Cache)
      //                 命令キャッシュを1/2キャッシュモードにする
      //! 非対応
      XEiJ.mpuCycleCount += 14;
      XEiJ.mpuCACR = d & 0xf8e0e000;  //CABCとCUBCは保存しておいてリードするときにマスクする
      {
        boolean cacheOn = (XEiJ.mpuCACR & 0x80008000) != 0;
        if (XEiJ.mpuCacheOn != cacheOn) {
          XEiJ.mpuCacheOn = cacheOn;
          XEiJ.mpuSetWait ();
        }
      }
      break;
    case 0x003:  //TCR
      //  TCR
      //  31 30 29 28 27 26 25 24  23 22 21 20 19 18 17 16  15 14  13  12   11   10 9 8  7 6   5 4 3 2 1 0
      //   0  0  0  0  0  0  0  0   0  0  0  0  0  0  0  0   E  P NAD NAI FOTC FITC DCO  DUO DWO DCI DUI 0
      //  bit15   E     Enable
      //  bit14   P     Page Size
      //  bit13   NAD   No Allocate Mode (Data ATC)
      //  bit12   NAI   No Allocate Mode (Instruction ATC)
      //  bit11   FOTC  1/2-Cache Mode (Data ATC)
      //  bit10   FITC  1/2-Cache Mode (Instruction ATC)
      //  bit9-8  DCO   Default Cache Mode (Data Cache)
      //  bit7-6  DUO   Default UPA bits (Data Cache)
      //  bit5    DWO   Default Write Protect (Data Cache)
      //  bit4-3  DCI   Default Cache Mode (Instruction Cache)
      //  bit2-1  DUI   Default UPA bits (Instruction Cache)
      //MMUを参照
      XEiJ.mpuCycleCount += 14;
      mmuSetTCR (d);
      break;
    case 0x004:  //ITT0
      XEiJ.mpuCycleCount += 14;
      mmuSetITT0 (d);
      break;
    case 0x005:  //ITT1
      XEiJ.mpuCycleCount += 14;
      mmuSetITT1 (d);
      break;
    case 0x006:  //DTT0
      XEiJ.mpuCycleCount += 14;
      mmuSetDTT0 (d);
      break;
    case 0x007:  //DTT1
      XEiJ.mpuCycleCount += 14;
      mmuSetDTT1 (d);
      break;
    case 0x008:  //BUSCR
      XEiJ.mpuCycleCount += 14;
      XEiJ.mpuBUSCR = d & 0xf0000000;
      break;
    case 0x800:  //USP
      XEiJ.mpuCycleCount += 11;
      XEiJ.mpuUSP = d;
      break;
    case 0x801:  //VBR
      XEiJ.mpuCycleCount += 11;
      XEiJ.mpuVBR = d & -4;  //4の倍数でないと困る
      break;
    case 0x806:  //URP
      XEiJ.mpuCycleCount += 14;
      mmuSetURP (d);
      break;
    case 0x807:  //SRP
      XEiJ.mpuCycleCount += 14;
      mmuSetSRP (d);
      break;
    case 0x808:  //PCR
      //  PCR
      //  31 30 29 28 27 26 25 24  23 22 21 20 19 18 17 16  15 14 13 12 11 10 9 8       7 6 5 4 3 2   1   0
      //   0  0  0  0  0  1  0  0   0  0  1  1  0  0  0  0     Revision Number     EDEBUG  Reserved DFP ESS
      //  bit31-16  Identification   0x0430
      //  bit15-8   Revision Number  1=F43G,5=G65V,6=E41J。偽物もあるらしい
      //  bit7      EDEBUG           Enable Debug Features
      //  bit6-2    Reserved
      //  bit1      DFP              Disable Floating-Point Unit。浮動小数点ユニット無効
      //  bit0      ESS              Enable Superscalar Dispatch。スーパースカラ有効
      XEiJ.mpuCycleCount += 11;
      XEiJ.mpuPCR = 0x04300000 | XEiJ.MPU_060_REV << 8 | d & 0x00000083;
      break;
    default:
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpMovecToControl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //JSR <ea>                                        |-|012346|-|-----|-----|  M  WXZP |0100_111_010_mmm_rrr
  //JBSR.L <label>                                  |A|012346|-|-----|-----|          |0100_111_010_111_001-{address}       [JSR <label>]
  public static void irpJsr () throws M68kException {
    XEiJ.mpuCycleCount++;
    //評価順序に注意。実効アドレスを求めてからspをデクリメントすること
    int a = efaJmpJsr (XEiJ.regOC & 63);
    M68kException.m6eIncremented -= 4L << (7 << 3);
    mmuWriteLongData (XEiJ.regRn[15] -= 4, XEiJ.regPC, XEiJ.regSRS);  //pushl
    irpSetPC (a);
  }  //irpJsr

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //JMP <ea>                                        |-|012346|-|-----|-----|  M  WXZP |0100_111_011_mmm_rrr
  //JBRA.L <label>                                  |A|012346|-|-----|-----|          |0100_111_011_111_001-{address}       [JMP <label>]
  public static void irpJmp () throws M68kException {
    XEiJ.mpuCycleCount++;  //0clkにしない
    irpSetPC (efaJmpJsr (XEiJ.regOC & 63));
  }  //irpJmp

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDQ.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_000_mmm_rrr
  //INC.B <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_000_mmm_rrr [ADDQ.B #1,<ea>]
  public static void irpAddqByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = ((XEiJ.regOC >> 9) - 1 & 7) + 1;  //qqq==0?8:qqq
    int z;
    if (ea < XEiJ.EA_AR) {  //ADDQ.B #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (byte) (XEiJ.regRn[ea] = ~0xff & (x = XEiJ.regRn[ea]) | 0xff & (x = (byte) x) + y);
    } else {  //ADDQ.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = (byte) ((x = mmuModifyByteSignData (a, XEiJ.regSRS)) + y), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           (~x & z) >>> 31 << 1 |
           (x & ~z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_addq
  }  //irpAddqByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDQ.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_001_mmm_rrr
  //ADDQ.W #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_001_001_rrr
  //INC.W <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_001_mmm_rrr [ADDQ.W #1,<ea>]
  //INC.W Ar                                        |A|012346|-|-----|-----| A        |0101_001_001_001_rrr [ADDQ.W #1,Ar]
  //
  //ADDQ.W #<data>,Ar
  //  ソースを符号拡張してロングで加算する
  public static void irpAddqWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = ((XEiJ.regOC >> 9) - 1 & 7) + 1;  //qqq==0?8:qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //ADDQ.W #<data>,Ar
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] += y;  //ロングで計算する。このr[ea]はアドレスレジスタ
      //ccrは操作しない
    } else {
      int x;
      int z;
      if (ea < XEiJ.EA_AR) {  //ADDQ.W #<data>,Dr
        XEiJ.mpuCycleCount++;
        z = (short) (XEiJ.regRn[ea] = ~0xffff & (x = XEiJ.regRn[ea]) | (char) ((x = (short) x) + y));
      } else {  //ADDQ.W #<data>,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltWord (ea);
        mmuWriteWordData (a, z = (short) ((x = mmuModifyWordSignData (a, XEiJ.regSRS)) + y), XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
             (~x & z) >>> 31 << 1 |
             (x & ~z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_addq
    }
  }  //irpAddqWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDQ.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_010_mmm_rrr
  //ADDQ.L #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_010_001_rrr
  //INC.L <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_010_mmm_rrr [ADDQ.L #1,<ea>]
  //INC.L Ar                                        |A|012346|-|-----|-----| A        |0101_001_010_001_rrr [ADDQ.L #1,Ar]
  public static void irpAddqLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = ((XEiJ.regOC >> 9) - 1 & 7) + 1;  //qqq==0?8:qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //ADDQ.L #<data>,Ar
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] += y;  //このr[ea]はアドレスレジスタ
      //ccrは操作しない
    } else {
      int x;
      int z;
      if (ea < XEiJ.EA_AR) {  //ADDQ.L #<data>,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] = z = (x = XEiJ.regRn[ea]) + y;
      } else {  //ADDQ.L #<data>,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltLong (ea);
        mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) + y, XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
             (~x & z) >>> 31 << 1 |
             (x & ~z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_addq
    }
  }  //irpAddqLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ST.B <ea>                                       |-|012346|-|-----|-----|D M+-WXZ  |0101_000_011_mmm_rrr
  //SNF.B <ea>                                      |A|012346|-|-----|-----|D M+-WXZ  |0101_000_011_mmm_rrr [ST.B <ea>]
  //DBT.W Dr,<label>                                |-|012346|-|-----|-----|          |0101_000_011_001_rrr-{offset}
  //DBNF.W Dr,<label>                               |A|012346|-|-----|-----|          |0101_000_011_001_rrr-{offset}        [DBT.W Dr,<label>]
  //TRAPT.W #<data>                                 |-|--2346|-|-----|-----|          |0101_000_011_111_010-{data}
  //TPNF.W #<data>                                  |A|--2346|-|-----|-----|          |0101_000_011_111_010-{data}  [TRAPT.W #<data>]
  //TPT.W #<data>                                   |A|--2346|-|-----|-----|          |0101_000_011_111_010-{data}  [TRAPT.W #<data>]
  //TRAPNF.W #<data>                                |A|--2346|-|-----|-----|          |0101_000_011_111_010-{data}  [TRAPT.W #<data>]
  //TRAPT.L #<data>                                 |-|--2346|-|-----|-----|          |0101_000_011_111_011-{data}
  //TPNF.L #<data>                                  |A|--2346|-|-----|-----|          |0101_000_011_111_011-{data}  [TRAPT.L #<data>]
  //TPT.L #<data>                                   |A|--2346|-|-----|-----|          |0101_000_011_111_011-{data}  [TRAPT.L #<data>]
  //TRAPNF.L #<data>                                |A|--2346|-|-----|-----|          |0101_000_011_111_011-{data}  [TRAPT.L #<data>]
  //TRAPT                                           |-|--2346|-|-----|-----|          |0101_000_011_111_100
  //TPNF                                            |A|--2346|-|-----|-----|          |0101_000_011_111_100 [TRAPT]
  //TPT                                             |A|--2346|-|-----|-----|          |0101_000_011_111_100 [TRAPT]
  //TRAPNF                                          |A|--2346|-|-----|-----|          |0101_000_011_111_100 [TRAPT]
  public static void irpSt () throws M68kException {
    int ea = XEiJ.regOC & 63;
    //DBT.W Dr,<label>よりもST.B Drを優先する
    if (ea < XEiJ.EA_AR) {  //ST.B Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] |= 0xff;
    } else if (ea < XEiJ.EA_MM) {  //DBT.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      //条件が成立しているので通過
      XEiJ.mpuCycleCount += 2;
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPT.W/TRAPT.L/TRAPT
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      //条件が成立しているのでTRAPする
      M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
      M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
      throw M68kException.m6eSignal;
    } else {  //ST.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), 0xff, XEiJ.regSRS);
    }
  }  //irpSt

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBQ.B #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_100_mmm_rrr
  //DEC.B <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_100_mmm_rrr [SUBQ.B #1,<ea>]
  public static void irpSubqByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int x;
    int y = ((XEiJ.regOC >> 9) - 1 & 7) + 1;  //qqq==0?8:qqq
    int z;
    if (ea < XEiJ.EA_AR) {  //SUBQ.B #<data>,Dr
      XEiJ.mpuCycleCount++;
      z = (byte) (XEiJ.regRn[ea] = ~0xff & (x = XEiJ.regRn[ea]) | 0xff & (x = (byte) x) - y);
    } else {  //SUBQ.B #<data>,<mem>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      mmuWriteByteData (a, z = (byte) ((x = mmuModifyByteSignData (a, XEiJ.regSRS)) - y), XEiJ.regSRS);
    }
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           (x & ~z) >>> 31 << 1 |
           (~x & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_subq
  }  //irpSubqByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBQ.W #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_101_mmm_rrr
  //SUBQ.W #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_101_001_rrr
  //DEC.W <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_101_mmm_rrr [SUBQ.W #1,<ea>]
  //DEC.W Ar                                        |A|012346|-|-----|-----| A        |0101_001_101_001_rrr [SUBQ.W #1,Ar]
  //
  //SUBQ.W #<data>,Ar
  //  ソースを符号拡張してロングで減算する
  public static void irpSubqWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = ((XEiJ.regOC >> 9) - 1 & 7) + 1;  //qqq==0?8:qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //SUBQ.W #<data>,Ar
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] -= y;  //ロングで計算する。このr[ea]はアドレスレジスタ
      //ccrは操作しない
    } else {
      int x;
      int z;
      if (ea < XEiJ.EA_AR) {  //SUBQ.W #<data>,Dr
        XEiJ.mpuCycleCount++;
        z = (short) (XEiJ.regRn[ea] = ~0xffff & (x = XEiJ.regRn[ea]) | (char) ((x = (short) x) - y));
      } else {  //SUBQ.W #<data>,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltWord (ea);
        mmuWriteWordData (a, z = (short) ((x = mmuModifyWordSignData (a, XEiJ.regSRS)) - y), XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
             (x & ~z) >>> 31 << 1 |
             (~x & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_subq
    }
  }  //irpSubqWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBQ.L #<data>,<ea>                             |-|012346|-|UUUUU|*****|D M+-WXZ  |0101_qqq_110_mmm_rrr
  //SUBQ.L #<data>,Ar                               |-|012346|-|-----|-----| A        |0101_qqq_110_001_rrr
  //DEC.L <ea>                                      |A|012346|-|UUUUU|*****|D M+-WXZ  |0101_001_110_mmm_rrr [SUBQ.L #1,<ea>]
  //DEC.L Ar                                        |A|012346|-|-----|-----| A        |0101_001_110_001_rrr [SUBQ.L #1,Ar]
  public static void irpSubqLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int y = ((XEiJ.regOC >> 9) - 1 & 7) + 1;  //qqq==0?8:qqq
    if (ea >> 3 == XEiJ.MMM_AR) {  //SUBQ.L #<data>,Ar
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] -= y;  //このr[ea]はアドレスレジスタ
      //ccrは操作しない
    } else {
      int x;
      int z;
      if (ea < XEiJ.EA_AR) {  //SUBQ.L #<data>,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] = z = (x = XEiJ.regRn[ea]) - y;
      } else {  //SUBQ.L #<data>,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltLong (ea);
        mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) - y, XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
             (x & ~z) >>> 31 << 1 |
             (~x & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_subq
    }
  }  //irpSubqLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SF.B <ea>                                       |-|012346|-|-----|-----|D M+-WXZ  |0101_000_111_mmm_rrr
  //SNT.B <ea>                                      |A|012346|-|-----|-----|D M+-WXZ  |0101_000_111_mmm_rrr [SF.B <ea>]
  //DBF.W Dr,<label>                                |-|012346|-|-----|-----|          |0101_000_111_001_rrr-{offset}
  //DBNT.W Dr,<label>                               |A|012346|-|-----|-----|          |0101_000_111_001_rrr-{offset}        [DBF.W Dr,<label>]
  //DBRA.W Dr,<label>                               |A|012346|-|-----|-----|          |0101_000_111_001_rrr-{offset}        [DBF.W Dr,<label>]
  //TRAPF.W #<data>                                 |-|--2346|-|-----|-----|          |0101_000_111_111_010-{data}
  //TPF.W #<data>                                   |A|--2346|-|-----|-----|          |0101_000_111_111_010-{data}  [TRAPF.W #<data>]
  //TPNT.W #<data>                                  |A|--2346|-|-----|-----|          |0101_000_111_111_010-{data}  [TRAPF.W #<data>]
  //TRAPNT.W #<data>                                |A|--2346|-|-----|-----|          |0101_000_111_111_010-{data}  [TRAPF.W #<data>]
  //TRAPF.L #<data>                                 |-|--2346|-|-----|-----|          |0101_000_111_111_011-{data}
  //TPF.L #<data>                                   |A|--2346|-|-----|-----|          |0101_000_111_111_011-{data}  [TRAPF.L #<data>]
  //TPNT.L #<data>                                  |A|--2346|-|-----|-----|          |0101_000_111_111_011-{data}  [TRAPF.L #<data>]
  //TRAPNT.L #<data>                                |A|--2346|-|-----|-----|          |0101_000_111_111_011-{data}  [TRAPF.L #<data>]
  //TRAPF                                           |-|--2346|-|-----|-----|          |0101_000_111_111_100
  //TPF                                             |A|--2346|-|-----|-----|          |0101_000_111_111_100 [TRAPF]
  //TPNT                                            |A|--2346|-|-----|-----|          |0101_000_111_111_100 [TRAPF]
  //TRAPNT                                          |A|--2346|-|-----|-----|          |0101_000_111_111_100 [TRAPF]
  public static void irpSf () throws M68kException {
    int ea = XEiJ.regOC & 63;
    //DBRA.W Dr,<label>よりもSF.B Drを優先する
    if (ea < XEiJ.EA_AR) {  //SF.B Dr
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[ea] &= ~0xff;
    } else if (ea < XEiJ.EA_MM) {  //DBRA.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      //条件が成立していないのでデクリメント
      int rrr = XEiJ.regOC & 7;
      int s = XEiJ.regRn[rrr];
      if ((short) s == 0) {  //Drの下位16bitが0なので通過
        XEiJ.mpuCycleCount += 2;
        XEiJ.regRn[rrr] = s + 65535;
      } else {  //Drの下位16bitが0でないので分岐
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
        irpSetPC (t);
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPF.W/TRAPF.L/TRAPF
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      //条件が成立していないのでTRAPしない
      XEiJ.mpuCycleCount++;
    } else {  //SF.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), 0x00, XEiJ.regSRS);
    }
  }  //irpSf

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SHI.B <ea>                                      |-|012346|-|--*-*|-----|D M+-WXZ  |0101_001_011_mmm_rrr
  //SNLS.B <ea>                                     |A|012346|-|--*-*|-----|D M+-WXZ  |0101_001_011_mmm_rrr [SHI.B <ea>]
  //DBHI.W Dr,<label>                               |-|012346|-|--*-*|-----|          |0101_001_011_001_rrr-{offset}
  //DBNLS.W Dr,<label>                              |A|012346|-|--*-*|-----|          |0101_001_011_001_rrr-{offset}        [DBHI.W Dr,<label>]
  //TRAPHI.W #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}
  //TPHI.W #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}  [TRAPHI.W #<data>]
  //TPNLS.W #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}  [TRAPHI.W #<data>]
  //TRAPNLS.W #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_011_111_010-{data}  [TRAPHI.W #<data>]
  //TRAPHI.L #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}
  //TPHI.L #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}  [TRAPHI.L #<data>]
  //TPNLS.L #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}  [TRAPHI.L #<data>]
  //TRAPNLS.L #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_011_111_011-{data}  [TRAPHI.L #<data>]
  //TRAPHI                                          |-|--2346|-|--*-*|-----|          |0101_001_011_111_100
  //TPHI                                            |A|--2346|-|--*-*|-----|          |0101_001_011_111_100 [TRAPHI]
  //TPNLS                                           |A|--2346|-|--*-*|-----|          |0101_001_011_111_100 [TRAPHI]
  //TRAPNLS                                         |A|--2346|-|--*-*|-----|          |0101_001_011_111_100 [TRAPHI]
  public static void irpShi () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBHI.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_HI << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SHI.B Dr
      if (XEiJ.MPU_CC_HI << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPHI.W/TRAPHI.L/TRAPHI
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_HI << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SHI.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_HI << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpShi

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SLS.B <ea>                                      |-|012346|-|--*-*|-----|D M+-WXZ  |0101_001_111_mmm_rrr
  //SNHI.B <ea>                                     |A|012346|-|--*-*|-----|D M+-WXZ  |0101_001_111_mmm_rrr [SLS.B <ea>]
  //DBLS.W Dr,<label>                               |-|012346|-|--*-*|-----|          |0101_001_111_001_rrr-{offset}
  //DBNHI.W Dr,<label>                              |A|012346|-|--*-*|-----|          |0101_001_111_001_rrr-{offset}        [DBLS.W Dr,<label>]
  //TRAPLS.W #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}
  //TPLS.W #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}  [TRAPLS.W #<data>]
  //TPNHI.W #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}  [TRAPLS.W #<data>]
  //TRAPNHI.W #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_111_111_010-{data}  [TRAPLS.W #<data>]
  //TRAPLS.L #<data>                                |-|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}
  //TPLS.L #<data>                                  |A|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}  [TRAPLS.L #<data>]
  //TPNHI.L #<data>                                 |A|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}  [TRAPLS.L #<data>]
  //TRAPNHI.L #<data>                               |A|--2346|-|--*-*|-----|          |0101_001_111_111_011-{data}  [TRAPLS.L #<data>]
  //TRAPLS                                          |-|--2346|-|--*-*|-----|          |0101_001_111_111_100
  //TPLS                                            |A|--2346|-|--*-*|-----|          |0101_001_111_111_100 [TRAPLS]
  //TPNHI                                           |A|--2346|-|--*-*|-----|          |0101_001_111_111_100 [TRAPLS]
  //TRAPNHI                                         |A|--2346|-|--*-*|-----|          |0101_001_111_111_100 [TRAPLS]
  public static void irpSls () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBLS.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_LS << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SLS.B Dr
      if (XEiJ.MPU_CC_LS << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPLS.W/TRAPLS.L/TRAPLS
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_LS << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SLS.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_LS << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSls

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SCC.B <ea>                                      |-|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr
  //SHS.B <ea>                                      |A|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr [SCC.B <ea>]
  //SNCS.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr [SCC.B <ea>]
  //SNLO.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_011_mmm_rrr [SCC.B <ea>]
  //DBCC.W Dr,<label>                               |-|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}
  //DBHS.W Dr,<label>                               |A|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}        [DBCC.W Dr,<label>]
  //DBNCS.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}        [DBCC.W Dr,<label>]
  //DBNLO.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_011_001_rrr-{offset}        [DBCC.W Dr,<label>]
  //TRAPCC.W #<data>                                |-|--2346|-|----*|-----|          |0101_010_011_111_010-{data}
  //TPCC.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TPHS.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TPNCS.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TPNLO.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TRAPHS.W #<data>                                |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TRAPNCS.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TRAPNLO.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_010-{data}  [TRAPCC.W #<data>]
  //TRAPCC.L #<data>                                |-|--2346|-|----*|-----|          |0101_010_011_111_011-{data}
  //TPCC.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TPHS.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TPNCS.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TPNLO.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TRAPHS.L #<data>                                |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TRAPNCS.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TRAPNLO.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_011_111_011-{data}  [TRAPCC.L #<data>]
  //TRAPCC                                          |-|--2346|-|----*|-----|          |0101_010_011_111_100
  //TPCC                                            |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  //TPHS                                            |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  //TPNCS                                           |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  //TPNLO                                           |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  //TRAPHS                                          |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  //TRAPNCS                                         |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  //TRAPNLO                                         |A|--2346|-|----*|-----|          |0101_010_011_111_100 [TRAPCC]
  public static void irpShs () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBHS.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_HS << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SHS.B Dr
      if (XEiJ.MPU_CC_HS << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPHS.W/TRAPHS.L/TRAPHS
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_HS << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SHS.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_HS << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpShs

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SCS.B <ea>                                      |-|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr
  //SLO.B <ea>                                      |A|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr [SCS.B <ea>]
  //SNCC.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr [SCS.B <ea>]
  //SNHS.B <ea>                                     |A|012346|-|----*|-----|D M+-WXZ  |0101_010_111_mmm_rrr [SCS.B <ea>]
  //DBCS.W Dr,<label>                               |-|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}
  //DBLO.W Dr,<label>                               |A|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}        [DBCS.W Dr,<label>]
  //DBNCC.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}        [DBCS.W Dr,<label>]
  //DBNHS.W Dr,<label>                              |A|012346|-|----*|-----|          |0101_010_111_001_rrr-{offset}        [DBCS.W Dr,<label>]
  //TRAPCS.W #<data>                                |-|--2346|-|----*|-----|          |0101_010_111_111_010-{data}
  //TPCS.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TPLO.W #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TPNCC.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TPNHS.W #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TRAPLO.W #<data>                                |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TRAPNCC.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TRAPNHS.W #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_010-{data}  [TRAPCS.W #<data>]
  //TRAPCS.L #<data>                                |-|--2346|-|----*|-----|          |0101_010_111_111_011-{data}
  //TPCS.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TPLO.L #<data>                                  |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TPNCC.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TPNHS.L #<data>                                 |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TRAPLO.L #<data>                                |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TRAPNCC.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TRAPNHS.L #<data>                               |A|--2346|-|----*|-----|          |0101_010_111_111_011-{data}  [TRAPCS.L #<data>]
  //TRAPCS                                          |-|--2346|-|----*|-----|          |0101_010_111_111_100
  //TPCS                                            |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  //TPLO                                            |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  //TPNCC                                           |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  //TPNHS                                           |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  //TRAPLO                                          |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  //TRAPNCC                                         |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  //TRAPNHS                                         |A|--2346|-|----*|-----|          |0101_010_111_111_100 [TRAPCS]
  public static void irpSlo () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBLO.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_LO << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SLO.B Dr
      if (XEiJ.MPU_CC_LO << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPLO.W/TRAPLO.L/TRAPLO
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_LO << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SLO.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_LO << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSlo

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SNE.B <ea>                                      |-|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr
  //SNEQ.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr [SNE.B <ea>]
  //SNZ.B <ea>                                      |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr [SNE.B <ea>]
  //SNZE.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_011_mmm_rrr [SNE.B <ea>]
  //DBNE.W Dr,<label>                               |-|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}
  //DBNEQ.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}        [DBNE.W Dr,<label>]
  //DBNZ.W Dr,<label>                               |A|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}        [DBNE.W Dr,<label>]
  //DBNZE.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_011_001_rrr-{offset}        [DBNE.W Dr,<label>]
  //TRAPNE.W #<data>                                |-|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}
  //TPNE.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TPNEQ.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TPNZ.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TPNZE.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TRAPNEQ.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TRAPNZ.W #<data>                                |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TRAPNZE.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_010-{data}  [TRAPNE.W #<data>]
  //TRAPNE.L #<data>                                |-|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}
  //TPNE.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TPNEQ.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TPNZ.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TPNZE.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TRAPNEQ.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TRAPNZ.L #<data>                                |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TRAPNZE.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_011_111_011-{data}  [TRAPNE.L #<data>]
  //TRAPNE                                          |-|--2346|-|--*--|-----|          |0101_011_011_111_100
  //TPNE                                            |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  //TPNEQ                                           |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  //TPNZ                                            |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  //TPNZE                                           |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  //TRAPNEQ                                         |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  //TRAPNZ                                          |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  //TRAPNZE                                         |A|--2346|-|--*--|-----|          |0101_011_011_111_100 [TRAPNE]
  public static void irpSne () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBNE.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_NE << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SNE.B Dr
      if (XEiJ.MPU_CC_NE << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPNE.W/TRAPNE.L/TRAPNE
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_NE << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SNE.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_NE << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSne

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SEQ.B <ea>                                      |-|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr
  //SNNE.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr [SEQ.B <ea>]
  //SNNZ.B <ea>                                     |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr [SEQ.B <ea>]
  //SZE.B <ea>                                      |A|012346|-|--*--|-----|D M+-WXZ  |0101_011_111_mmm_rrr [SEQ.B <ea>]
  //DBEQ.W Dr,<label>                               |-|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}
  //DBNNE.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}        [DBEQ.W Dr,<label>]
  //DBNNZ.W Dr,<label>                              |A|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}        [DBEQ.W Dr,<label>]
  //DBZE.W Dr,<label>                               |A|012346|-|--*--|-----|          |0101_011_111_001_rrr-{offset}        [DBEQ.W Dr,<label>]
  //TRAPEQ.W #<data>                                |-|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}
  //TPEQ.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TPNNE.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TPNNZ.W #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TPZE.W #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TRAPNNE.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TRAPNNZ.W #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TRAPZE.W #<data>                                |A|--2346|-|--*--|-----|          |0101_011_111_111_010-{data}  [TRAPEQ.W #<data>]
  //TRAPEQ.L #<data>                                |-|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}
  //TPEQ.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TPNNE.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TPNNZ.L #<data>                                 |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TPZE.L #<data>                                  |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TRAPNNE.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TRAPNNZ.L #<data>                               |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TRAPZE.L #<data>                                |A|--2346|-|--*--|-----|          |0101_011_111_111_011-{data}  [TRAPEQ.L #<data>]
  //TRAPEQ                                          |-|--2346|-|--*--|-----|          |0101_011_111_111_100
  //TPEQ                                            |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  //TPNNE                                           |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  //TPNNZ                                           |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  //TPZE                                            |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  //TRAPNNE                                         |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  //TRAPNNZ                                         |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  //TRAPZE                                          |A|--2346|-|--*--|-----|          |0101_011_111_111_100 [TRAPEQ]
  public static void irpSeq () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBEQ.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_EQ << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SEQ.B Dr
      if (XEiJ.MPU_CC_EQ << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPEQ.W/TRAPEQ.L/TRAPEQ
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_EQ << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SEQ.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_EQ << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSeq

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SVC.B <ea>                                      |-|012346|-|---*-|-----|D M+-WXZ  |0101_100_011_mmm_rrr
  //SNVS.B <ea>                                     |A|012346|-|---*-|-----|D M+-WXZ  |0101_100_011_mmm_rrr [SVC.B <ea>]
  //DBVC.W Dr,<label>                               |-|012346|-|---*-|-----|          |0101_100_011_001_rrr-{offset}
  //DBNVS.W Dr,<label>                              |A|012346|-|---*-|-----|          |0101_100_011_001_rrr-{offset}        [DBVC.W Dr,<label>]
  //TRAPVC.W #<data>                                |-|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}
  //TPNVS.W #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}  [TRAPVC.W #<data>]
  //TPVC.W #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}  [TRAPVC.W #<data>]
  //TRAPNVS.W #<data>                               |A|--2346|-|---*-|-----|          |0101_100_011_111_010-{data}  [TRAPVC.W #<data>]
  //TRAPVC.L #<data>                                |-|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}
  //TPNVS.L #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}  [TRAPVC.L #<data>]
  //TPVC.L #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}  [TRAPVC.L #<data>]
  //TRAPNVS.L #<data>                               |A|--2346|-|---*-|-----|          |0101_100_011_111_011-{data}  [TRAPVC.L #<data>]
  //TRAPVC                                          |-|--2346|-|---*-|-----|          |0101_100_011_111_100
  //TPNVS                                           |A|--2346|-|---*-|-----|          |0101_100_011_111_100 [TRAPVC]
  //TPVC                                            |A|--2346|-|---*-|-----|          |0101_100_011_111_100 [TRAPVC]
  //TRAPNVS                                         |A|--2346|-|---*-|-----|          |0101_100_011_111_100 [TRAPVC]
  public static void irpSvc () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBVC.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_VC << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SVC.B Dr
      if (XEiJ.MPU_CC_VC << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPVC.W/TRAPVC.L/TRAPVC
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_VC << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SVC.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_VC << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSvc

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SVS.B <ea>                                      |-|012346|-|---*-|-----|D M+-WXZ  |0101_100_111_mmm_rrr
  //SNVC.B <ea>                                     |A|012346|-|---*-|-----|D M+-WXZ  |0101_100_111_mmm_rrr [SVS.B <ea>]
  //DBVS.W Dr,<label>                               |-|012346|-|---*-|-----|          |0101_100_111_001_rrr-{offset}
  //DBNVC.W Dr,<label>                              |A|012346|-|---*-|-----|          |0101_100_111_001_rrr-{offset}        [DBVS.W Dr,<label>]
  //TRAPVS.W #<data>                                |-|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}
  //TPNVC.W #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}  [TRAPVS.W #<data>]
  //TPVS.W #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}  [TRAPVS.W #<data>]
  //TRAPNVC.W #<data>                               |A|--2346|-|---*-|-----|          |0101_100_111_111_010-{data}  [TRAPVS.W #<data>]
  //TRAPVS.L #<data>                                |-|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}
  //TPNVC.L #<data>                                 |A|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}  [TRAPVS.L #<data>]
  //TPVS.L #<data>                                  |A|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}  [TRAPVS.L #<data>]
  //TRAPNVC.L #<data>                               |A|--2346|-|---*-|-----|          |0101_100_111_111_011-{data}  [TRAPVS.L #<data>]
  //TRAPVS                                          |-|--2346|-|---*-|-----|          |0101_100_111_111_100
  //TPNVC                                           |A|--2346|-|---*-|-----|          |0101_100_111_111_100 [TRAPVS]
  //TPVS                                            |A|--2346|-|---*-|-----|          |0101_100_111_111_100 [TRAPVS]
  //TRAPNVC                                         |A|--2346|-|---*-|-----|          |0101_100_111_111_100 [TRAPVS]
  public static void irpSvs () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBVS.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_VS << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SVS.B Dr
      if (XEiJ.MPU_CC_VS << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPVS.W/TRAPVS.L/TRAPVS
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_VS << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SVS.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_VS << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSvs

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SPL.B <ea>                                      |-|012346|-|-*---|-----|D M+-WXZ  |0101_101_011_mmm_rrr
  //SNMI.B <ea>                                     |A|012346|-|-*---|-----|D M+-WXZ  |0101_101_011_mmm_rrr [SPL.B <ea>]
  //DBPL.W Dr,<label>                               |-|012346|-|-*---|-----|          |0101_101_011_001_rrr-{offset}
  //DBNMI.W Dr,<label>                              |A|012346|-|-*---|-----|          |0101_101_011_001_rrr-{offset}        [DBPL.W Dr,<label>]
  //TRAPPL.W #<data>                                |-|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}
  //TPNMI.W #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}  [TRAPPL.W #<data>]
  //TPPL.W #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}  [TRAPPL.W #<data>]
  //TRAPNMI.W #<data>                               |A|--2346|-|-*---|-----|          |0101_101_011_111_010-{data}  [TRAPPL.W #<data>]
  //TRAPPL.L #<data>                                |-|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}
  //TPNMI.L #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}  [TRAPPL.L #<data>]
  //TPPL.L #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}  [TRAPPL.L #<data>]
  //TRAPNMI.L #<data>                               |A|--2346|-|-*---|-----|          |0101_101_011_111_011-{data}  [TRAPPL.L #<data>]
  //TRAPPL                                          |-|--2346|-|-*---|-----|          |0101_101_011_111_100
  //TPNMI                                           |A|--2346|-|-*---|-----|          |0101_101_011_111_100 [TRAPPL]
  //TPPL                                            |A|--2346|-|-*---|-----|          |0101_101_011_111_100 [TRAPPL]
  //TRAPNMI                                         |A|--2346|-|-*---|-----|          |0101_101_011_111_100 [TRAPPL]
  public static void irpSpl () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBPL.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_PL << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SPL.B Dr
      if (XEiJ.MPU_CC_PL << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPPL.W/TRAPPL.L/TRAPPL
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_PL << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SPL.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_PL << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSpl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SMI.B <ea>                                      |-|012346|-|-*---|-----|D M+-WXZ  |0101_101_111_mmm_rrr
  //SNPL.B <ea>                                     |A|012346|-|-*---|-----|D M+-WXZ  |0101_101_111_mmm_rrr [SMI.B <ea>]
  //DBMI.W Dr,<label>                               |-|012346|-|-*---|-----|          |0101_101_111_001_rrr-{offset}
  //DBNPL.W Dr,<label>                              |A|012346|-|-*---|-----|          |0101_101_111_001_rrr-{offset}        [DBMI.W Dr,<label>]
  //TRAPMI.W #<data>                                |-|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}
  //TPMI.W #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}  [TRAPMI.W #<data>]
  //TPNPL.W #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}  [TRAPMI.W #<data>]
  //TRAPNPL.W #<data>                               |A|--2346|-|-*---|-----|          |0101_101_111_111_010-{data}  [TRAPMI.W #<data>]
  //TRAPMI.L #<data>                                |-|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}
  //TPMI.L #<data>                                  |A|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}  [TRAPMI.L #<data>]
  //TPNPL.L #<data>                                 |A|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}  [TRAPMI.L #<data>]
  //TRAPNPL.L #<data>                               |A|--2346|-|-*---|-----|          |0101_101_111_111_011-{data}  [TRAPMI.L #<data>]
  //TRAPMI                                          |-|--2346|-|-*---|-----|          |0101_101_111_111_100
  //TPMI                                            |A|--2346|-|-*---|-----|          |0101_101_111_111_100 [TRAPMI]
  //TPNPL                                           |A|--2346|-|-*---|-----|          |0101_101_111_111_100 [TRAPMI]
  //TRAPNPL                                         |A|--2346|-|-*---|-----|          |0101_101_111_111_100 [TRAPMI]
  public static void irpSmi () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBMI.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_MI << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SMI.B Dr
      if (XEiJ.MPU_CC_MI << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPMI.W/TRAPMI.L/TRAPMI
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_MI << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SMI.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_MI << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSmi

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SGE.B <ea>                                      |-|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_011_mmm_rrr
  //SNLT.B <ea>                                     |A|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_011_mmm_rrr [SGE.B <ea>]
  //DBGE.W Dr,<label>                               |-|012346|-|-*-*-|-----|          |0101_110_011_001_rrr-{offset}
  //DBNLT.W Dr,<label>                              |A|012346|-|-*-*-|-----|          |0101_110_011_001_rrr-{offset}        [DBGE.W Dr,<label>]
  //TRAPGE.W #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}
  //TPGE.W #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}  [TRAPGE.W #<data>]
  //TPNLT.W #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}  [TRAPGE.W #<data>]
  //TRAPNLT.W #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_011_111_010-{data}  [TRAPGE.W #<data>]
  //TRAPGE.L #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}
  //TPGE.L #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}  [TRAPGE.L #<data>]
  //TPNLT.L #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}  [TRAPGE.L #<data>]
  //TRAPNLT.L #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_011_111_011-{data}  [TRAPGE.L #<data>]
  //TRAPGE                                          |-|--2346|-|-*-*-|-----|          |0101_110_011_111_100
  //TPGE                                            |A|--2346|-|-*-*-|-----|          |0101_110_011_111_100 [TRAPGE]
  //TPNLT                                           |A|--2346|-|-*-*-|-----|          |0101_110_011_111_100 [TRAPGE]
  //TRAPNLT                                         |A|--2346|-|-*-*-|-----|          |0101_110_011_111_100 [TRAPGE]
  public static void irpSge () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBGE.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_GE << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SGE.B Dr
      if (XEiJ.MPU_CC_GE << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPGE.W/TRAPGE.L/TRAPGE
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_GE << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SGE.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_GE << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSge

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SLT.B <ea>                                      |-|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_111_mmm_rrr
  //SNGE.B <ea>                                     |A|012346|-|-*-*-|-----|D M+-WXZ  |0101_110_111_mmm_rrr [SLT.B <ea>]
  //DBLT.W Dr,<label>                               |-|012346|-|-*-*-|-----|          |0101_110_111_001_rrr-{offset}
  //DBNGE.W Dr,<label>                              |A|012346|-|-*-*-|-----|          |0101_110_111_001_rrr-{offset}        [DBLT.W Dr,<label>]
  //TRAPLT.W #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}
  //TPLT.W #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}  [TRAPLT.W #<data>]
  //TPNGE.W #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}  [TRAPLT.W #<data>]
  //TRAPNGE.W #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_111_111_010-{data}  [TRAPLT.W #<data>]
  //TRAPLT.L #<data>                                |-|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}
  //TPLT.L #<data>                                  |A|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}  [TRAPLT.L #<data>]
  //TPNGE.L #<data>                                 |A|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}  [TRAPLT.L #<data>]
  //TRAPNGE.L #<data>                               |A|--2346|-|-*-*-|-----|          |0101_110_111_111_011-{data}  [TRAPLT.L #<data>]
  //TRAPLT                                          |-|--2346|-|-*-*-|-----|          |0101_110_111_111_100
  //TPLT                                            |A|--2346|-|-*-*-|-----|          |0101_110_111_111_100 [TRAPLT]
  //TPNGE                                           |A|--2346|-|-*-*-|-----|          |0101_110_111_111_100 [TRAPLT]
  //TRAPNGE                                         |A|--2346|-|-*-*-|-----|          |0101_110_111_111_100 [TRAPLT]
  public static void irpSlt () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBLT.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_LT << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SLT.B Dr
      if (XEiJ.MPU_CC_LT << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPLT.W/TRAPLT.L/TRAPLT
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_LT << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SLT.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_LT << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSlt

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SGT.B <ea>                                      |-|012346|-|-***-|-----|D M+-WXZ  |0101_111_011_mmm_rrr
  //SNLE.B <ea>                                     |A|012346|-|-***-|-----|D M+-WXZ  |0101_111_011_mmm_rrr [SGT.B <ea>]
  //DBGT.W Dr,<label>                               |-|012346|-|-***-|-----|          |0101_111_011_001_rrr-{offset}
  //DBNLE.W Dr,<label>                              |A|012346|-|-***-|-----|          |0101_111_011_001_rrr-{offset}        [DBGT.W Dr,<label>]
  //TRAPGT.W #<data>                                |-|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}
  //TPGT.W #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}  [TRAPGT.W #<data>]
  //TPNLE.W #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}  [TRAPGT.W #<data>]
  //TRAPNLE.W #<data>                               |A|--2346|-|-***-|-----|          |0101_111_011_111_010-{data}  [TRAPGT.W #<data>]
  //TRAPGT.L #<data>                                |-|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}
  //TPGT.L #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}  [TRAPGT.L #<data>]
  //TPNLE.L #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}  [TRAPGT.L #<data>]
  //TRAPNLE.L #<data>                               |A|--2346|-|-***-|-----|          |0101_111_011_111_011-{data}  [TRAPGT.L #<data>]
  //TRAPGT                                          |-|--2346|-|-***-|-----|          |0101_111_011_111_100
  //TPGT                                            |A|--2346|-|-***-|-----|          |0101_111_011_111_100 [TRAPGT]
  //TPNLE                                           |A|--2346|-|-***-|-----|          |0101_111_011_111_100 [TRAPGT]
  //TRAPNLE                                         |A|--2346|-|-***-|-----|          |0101_111_011_111_100 [TRAPGT]
  public static void irpSgt () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBGT.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_GT << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SGT.B Dr
      if (XEiJ.MPU_CC_GT << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPGT.W/TRAPGT.L/TRAPGT
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_GT << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SGT.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_GT << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSgt

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SLE.B <ea>                                      |-|012346|-|-***-|-----|D M+-WXZ  |0101_111_111_mmm_rrr
  //SNGT.B <ea>                                     |A|012346|-|-***-|-----|D M+-WXZ  |0101_111_111_mmm_rrr [SLE.B <ea>]
  //DBLE.W Dr,<label>                               |-|012346|-|-***-|-----|          |0101_111_111_001_rrr-{offset}
  //DBNGT.W Dr,<label>                              |A|012346|-|-***-|-----|          |0101_111_111_001_rrr-{offset}        [DBLE.W Dr,<label>]
  //TRAPLE.W #<data>                                |-|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}
  //TPLE.W #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}  [TRAPLE.W #<data>]
  //TPNGT.W #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}  [TRAPLE.W #<data>]
  //TRAPNGT.W #<data>                               |A|--2346|-|-***-|-----|          |0101_111_111_111_010-{data}  [TRAPLE.W #<data>]
  //TRAPLE.L #<data>                                |-|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}
  //TPLE.L #<data>                                  |A|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}  [TRAPLE.L #<data>]
  //TPNGT.L #<data>                                 |A|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}  [TRAPLE.L #<data>]
  //TRAPNGT.L #<data>                               |A|--2346|-|-***-|-----|          |0101_111_111_111_011-{data}  [TRAPLE.L #<data>]
  //TRAPLE                                          |-|--2346|-|-***-|-----|          |0101_111_111_111_100
  //TPLE                                            |A|--2346|-|-***-|-----|          |0101_111_111_111_100 [TRAPLE]
  //TPNGT                                           |A|--2346|-|-***-|-----|          |0101_111_111_111_100 [TRAPLE]
  //TRAPNGT                                         |A|--2346|-|-***-|-----|          |0101_111_111_111_100 [TRAPLE]
  public static void irpSle () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //DBLE.W Dr,<label>
      int t = XEiJ.regPC;  //pc0+2
      XEiJ.regPC = t + 2;  //pc0+4
      t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
      if ((t & 1) != 0) {  //分岐先のアドレスが奇数
        //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
        irpBccAddressError (t);
      }
      if (XEiJ.MPU_CC_LE << XEiJ.regCCR < 0) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
      } else {  //条件が成立していないのでデクリメント
        int rrr = XEiJ.regOC & 7;
        int s = XEiJ.regRn[rrr];
        if ((short) s == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = s + 65535;
        } else {  //Drの下位16bitが0でないので分岐
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = s - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (t);
        }
      }
    } else if (ea < XEiJ.EA_AR) {  //SLE.B Dr
      if (XEiJ.MPU_CC_LE << XEiJ.regCCR < 0) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if ((XEiJ.EAM_PW | XEiJ.EAM_PX | XEiJ.EAM_IM) << ea < 0L) {  //TRAPLE.W/TRAPLE.L/TRAPLE
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (XEiJ.MPU_CC_LE << XEiJ.regCCR < 0) {
        //条件が成立しているのでTRAPする
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      } else {
        //条件が成立していないのでTRAPしない
        XEiJ.mpuCycleCount++;
      }
    } else {  //SLE.B <mem>
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (efaMltByte (ea), XEiJ.MPU_CC_LE << XEiJ.regCCR >> 31, XEiJ.regSRS);
    }
  }  //irpSle

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BRA.W <label>                                   |-|012346|-|-----|-----|          |0110_000_000_000_000-{offset}
  //JBRA.W <label>                                  |A|012346|-|-----|-----|          |0110_000_000_000_000-{offset}        [BRA.W <label>]
  //BRA.S <label>                                   |-|012346|-|-----|-----|          |0110_000_000_sss_sss (s is not equal to 0)
  //JBRA.S <label>                                  |A|012346|-|-----|-----|          |0110_000_000_sss_sss (s is not equal to 0)   [BRA.S <label>]
  public static void irpBrasw () throws M68kException {
    XEiJ.mpuCycleCount++;  //0clkにしない
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //オフセット
    if (s == 0) {  //BRA.W
      XEiJ.regPC = t + 2;
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //pcws
    }
    irpSetPC (t + s);  //pc0+2+オフセット
  }  //irpBrasw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BRA.S <label>                                   |-|012346|-|-----|-----|          |0110_000_001_sss_sss
  //JBRA.S <label>                                  |A|012346|-|-----|-----|          |0110_000_001_sss_sss [BRA.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BRA.S <label>                                   |-|012346|-|-----|-----|          |0110_000_010_sss_sss
  //JBRA.S <label>                                  |A|012346|-|-----|-----|          |0110_000_010_sss_sss [BRA.S <label>]
  public static void irpBras () throws M68kException {
    XEiJ.mpuCycleCount++;  //0clkにしない
    irpSetPC (XEiJ.regPC + (byte) XEiJ.regOC);  //pc0+2+オフセット
  }  //irpBras

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BRA.S <label>                                   |-|--2346|-|-----|-----|          |0110_000_011_sss_sss (s is not equal to 63)
  //JBRA.S <label>                                  |A|--2346|-|-----|-----|          |0110_000_011_sss_sss (s is not equal to 63)  [BRA.S <label>]
  //BRA.L <label>                                   |-|--2346|-|-----|-----|          |0110_000_011_111_111-{offset}
  public static void irpBrasl () throws M68kException {
    XEiJ.mpuCycleCount++;  //0clkにしない
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //オフセット
    if (s == -1) {  //BRA.L
      XEiJ.regPC = t + 4;
      s = mmuReadLongExword (t, XEiJ.regSRS);  //pcls
    }
    irpSetPC (t + s);  //pc0+2+オフセット
  }  //irpBrasl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BSR.W <label>                                   |-|012346|-|-----|-----|          |0110_000_100_000_000-{offset}
  //JBSR.W <label>                                  |A|012346|-|-----|-----|          |0110_000_100_000_000-{offset}        [BSR.W <label>]
  //BSR.S <label>                                   |-|012346|-|-----|-----|          |0110_000_100_sss_sss (s is not equal to 0)
  //JBSR.S <label>                                  |A|012346|-|-----|-----|          |0110_000_100_sss_sss (s is not equal to 0)   [BSR.S <label>]
  public static void irpBsrsw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //オフセット
    if (s == 0) {  //BSR.W
      XEiJ.regPC = t + 2;
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //pcws
    }
    M68kException.m6eIncremented -= 4L << (7 << 3);
    mmuWriteLongData (XEiJ.regRn[15] -= 4, XEiJ.regPC, XEiJ.regSRS);  //pushl
    irpSetPC (t + s);  //pc0+2+オフセット
  }  //irpBsrsw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BSR.S <label>                                   |-|012346|-|-----|-----|          |0110_000_101_sss_sss
  //JBSR.S <label>                                  |A|012346|-|-----|-----|          |0110_000_101_sss_sss [BSR.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BSR.S <label>                                   |-|012346|-|-----|-----|          |0110_000_110_sss_sss
  //JBSR.S <label>                                  |A|012346|-|-----|-----|          |0110_000_110_sss_sss [BSR.S <label>]
  public static void irpBsrs () throws M68kException {
    XEiJ.mpuCycleCount++;
    M68kException.m6eIncremented -= 4L << (7 << 3);
    mmuWriteLongData (XEiJ.regRn[15] -= 4, XEiJ.regPC, XEiJ.regSRS);  //pushl
    irpSetPC (XEiJ.regPC + (byte) XEiJ.regOC);  //pc0+2+オフセット
  }  //irpBsrs

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BSR.S <label>                                   |-|--2346|-|-----|-----|          |0110_000_111_sss_sss (s is not equal to 63)
  //JBSR.S <label>                                  |A|--2346|-|-----|-----|          |0110_000_111_sss_sss (s is not equal to 63)  [BSR.S <label>]
  //BSR.L <label>                                   |-|--2346|-|-----|-----|          |0110_000_111_111_111-{offset}
  public static void irpBsrsl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //オフセット
    if (s == -1) {  //BSR.L
      XEiJ.regPC = t + 4;
      s = mmuReadLongExword (t, XEiJ.regSRS);  //pcls
    }
    M68kException.m6eIncremented -= 4L << (7 << 3);
    mmuWriteLongData (XEiJ.regRn[15] -= 4, XEiJ.regPC, XEiJ.regSRS);  //pushl
    irpSetPC (t + s);  //pc0+2+オフセット
  }  //irpBsrsl

  //irpBccAddressError (int t)
  public static void irpBccAddressError (int t) throws M68kException {
    M68kException.m6eNumber = M68kException.M6E_ADDRESS_ERROR;
    M68kException.m6eAddress = t & -2;  //偶数にする
    M68kException.m6eDirection = XEiJ.MPU_WR_READ;
    M68kException.m6eSize = XEiJ.MPU_SS_WORD;
    throw M68kException.m6eSignal;
  }

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BHI.W <label>                                   |-|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}
  //BNLS.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}        [BHI.W <label>]
  //JBHI.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}        [BHI.W <label>]
  //JBNLS.W <label>                                 |A|012346|-|--*-*|-----|          |0110_001_000_000_000-{offset}        [BHI.W <label>]
  //BHI.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)
  //BNLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)   [BHI.S <label>]
  //JBHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)   [BHI.S <label>]
  //JBNLS.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_000_sss_sss (s is not equal to 0)   [BHI.S <label>]
  //JBLS.L <label>                                  |A|012346|-|--*-*|-----|          |0110_001_000_000_110-0100111011111001-{address}      [BHI.S (*)+8;JMP <label>]
  //JBNHI.L <label>                                 |A|012346|-|--*-*|-----|          |0110_001_000_000_110-0100111011111001-{address}      [BHI.S (*)+8;JMP <label>]
  public static void irpBhisw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_HI << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBhisw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BHI.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_001_sss_sss
  //BNLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_001_sss_sss [BHI.S <label>]
  //JBHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_001_sss_sss [BHI.S <label>]
  //JBNLS.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_001_sss_sss [BHI.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BHI.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_010_sss_sss
  //BNLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_010_sss_sss [BHI.S <label>]
  //JBHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_010_sss_sss [BHI.S <label>]
  //JBNLS.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_010_sss_sss [BHI.S <label>]
  public static void irpBhis () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_HI << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBhis

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BHI.S <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)
  //BNLS.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)  [BHI.S <label>]
  //JBHI.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)  [BHI.S <label>]
  //JBNLS.S <label>                                 |A|--2346|-|--*-*|-----|          |0110_001_011_sss_sss (s is not equal to 63)  [BHI.S <label>]
  //BHI.L <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_011_111_111-{offset}
  //BNLS.L <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_011_111_111-{offset}        [BHI.L <label>]
  public static void irpBhisl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_HI << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBhisl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLS.W <label>                                   |-|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}
  //BNHI.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}        [BLS.W <label>]
  //JBLS.W <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}        [BLS.W <label>]
  //JBNHI.W <label>                                 |A|012346|-|--*-*|-----|          |0110_001_100_000_000-{offset}        [BLS.W <label>]
  //BLS.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)
  //BNHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)   [BLS.S <label>]
  //JBLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)   [BLS.S <label>]
  //JBNHI.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_100_sss_sss (s is not equal to 0)   [BLS.S <label>]
  //JBHI.L <label>                                  |A|012346|-|--*-*|-----|          |0110_001_100_000_110-0100111011111001-{address}      [BLS.S (*)+8;JMP <label>]
  //JBNLS.L <label>                                 |A|012346|-|--*-*|-----|          |0110_001_100_000_110-0100111011111001-{address}      [BLS.S (*)+8;JMP <label>]
  public static void irpBlssw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlssw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLS.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_101_sss_sss
  //BNHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_101_sss_sss [BLS.S <label>]
  //JBLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_101_sss_sss [BLS.S <label>]
  //JBNHI.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_101_sss_sss [BLS.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLS.S <label>                                   |-|012346|-|--*-*|-----|          |0110_001_110_sss_sss
  //BNHI.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_110_sss_sss [BLS.S <label>]
  //JBLS.S <label>                                  |A|012346|-|--*-*|-----|          |0110_001_110_sss_sss [BLS.S <label>]
  //JBNHI.S <label>                                 |A|012346|-|--*-*|-----|          |0110_001_110_sss_sss [BLS.S <label>]
  public static void irpBlss () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlss

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLS.S <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)
  //BNHI.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)  [BLS.S <label>]
  //JBLS.S <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)  [BLS.S <label>]
  //JBNHI.S <label>                                 |A|--2346|-|--*-*|-----|          |0110_001_111_sss_sss (s is not equal to 63)  [BLS.S <label>]
  //BLS.L <label>                                   |-|--2346|-|--*-*|-----|          |0110_001_111_111_111-{offset}
  //BNHI.L <label>                                  |A|--2346|-|--*-*|-----|          |0110_001_111_111_111-{offset}        [BLS.L <label>]
  public static void irpBlssl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlssl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCC.W <label>                                   |-|012346|-|----*|-----|          |0110_010_000_000_000-{offset}
  //BHS.W <label>                                   |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //BNCS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //BNLO.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //JBCC.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //JBHS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //JBNCS.W <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //JBNLO.W <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_000-{offset}        [BCC.W <label>]
  //BCC.S <label>                                   |-|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)
  //BHS.S <label>                                   |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //BNCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //BNLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //JBCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //JBHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //JBNCS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //JBNLO.S <label>                                 |A|012346|-|----*|-----|          |0110_010_000_sss_sss (s is not equal to 0)   [BCC.S <label>]
  //JBCS.L <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
  //JBLO.L <label>                                  |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
  //JBNCC.L <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
  //JBNHS.L <label>                                 |A|012346|-|----*|-----|          |0110_010_000_000_110-0100111011111001-{address}      [BCC.S (*)+8;JMP <label>]
  public static void irpBhssw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_HS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBhssw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCC.S <label>                                   |-|012346|-|----*|-----|          |0110_010_001_sss_sss
  //BHS.S <label>                                   |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //BNCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //BNLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //JBCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //JBHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //JBNCS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //JBNLO.S <label>                                 |A|012346|-|----*|-----|          |0110_010_001_sss_sss [BCC.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCC.S <label>                                   |-|012346|-|----*|-----|          |0110_010_010_sss_sss
  //BHS.S <label>                                   |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  //BNCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  //BNLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  //JBCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  //JBHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  //JBNCS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  //JBNLO.S <label>                                 |A|012346|-|----*|-----|          |0110_010_010_sss_sss [BCC.S <label>]
  public static void irpBhss () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_HS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBhss

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCC.S <label>                                   |-|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)
  //BHS.S <label>                                   |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //BNCS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //BNLO.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //JBCC.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //JBHS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //JBNCS.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //JBNLO.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_011_sss_sss (s is not equal to 63)  [BCC.S <label>]
  //BCC.L <label>                                   |-|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}
  //BHS.L <label>                                   |A|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}        [BCC.L <label>]
  //BNCS.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}        [BCC.L <label>]
  //BNLO.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_011_111_111-{offset}        [BCC.L <label>]
  public static void irpBhssl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_HS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBhssl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCS.W <label>                                   |-|012346|-|----*|-----|          |0110_010_100_000_000-{offset}
  //BLO.W <label>                                   |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //BNCC.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //BNHS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //JBCS.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //JBLO.W <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //JBNCC.W <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //JBNHS.W <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_000-{offset}        [BCS.W <label>]
  //BCS.S <label>                                   |-|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)
  //BLO.S <label>                                   |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //BNCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //BNHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //JBCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //JBLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //JBNCC.S <label>                                 |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //JBNHS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_100_sss_sss (s is not equal to 0)   [BCS.S <label>]
  //JBCC.L <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
  //JBHS.L <label>                                  |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
  //JBNCS.L <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
  //JBNLO.L <label>                                 |A|012346|-|----*|-----|          |0110_010_100_000_110-0100111011111001-{address}      [BCS.S (*)+8;JMP <label>]
  public static void irpBlosw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LO << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlosw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCS.S <label>                                   |-|012346|-|----*|-----|          |0110_010_101_sss_sss
  //BLO.S <label>                                   |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //BNCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //BNHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //JBCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //JBLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //JBNCC.S <label>                                 |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //JBNHS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_101_sss_sss [BCS.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCS.S <label>                                   |-|012346|-|----*|-----|          |0110_010_110_sss_sss
  //BLO.S <label>                                   |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  //BNCC.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  //BNHS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  //JBCS.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  //JBLO.S <label>                                  |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  //JBNCC.S <label>                                 |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  //JBNHS.S <label>                                 |A|012346|-|----*|-----|          |0110_010_110_sss_sss [BCS.S <label>]
  public static void irpBlos () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LO << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlos

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BCS.S <label>                                   |-|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)
  //BLO.S <label>                                   |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //BNCC.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //BNHS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //JBCS.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //JBLO.S <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //JBNCC.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //JBNHS.S <label>                                 |A|--2346|-|----*|-----|          |0110_010_111_sss_sss (s is not equal to 63)  [BCS.S <label>]
  //BCS.L <label>                                   |-|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}
  //BLO.L <label>                                   |A|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}        [BCS.L <label>]
  //BNCC.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}        [BCS.L <label>]
  //BNHS.L <label>                                  |A|--2346|-|----*|-----|          |0110_010_111_111_111-{offset}        [BCS.L <label>]
  public static void irpBlosl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LO << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlosl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BNE.W <label>                                   |-|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}
  //BNEQ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //BNZ.W <label>                                   |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //BNZE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //JBNE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //JBNEQ.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //JBNZ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //JBNZE.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_000-{offset}        [BNE.W <label>]
  //BNE.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)
  //BNEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //BNZ.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //BNZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //JBNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //JBNEQ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //JBNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //JBNZE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_sss_sss (s is not equal to 0)   [BNE.S <label>]
  //JBEQ.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  //JBNEQ.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  //JBNNE.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  //JBNNZ.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  //JBNZ.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  //JBNZE.L <label>                                 |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  //JBZE.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_000_000_110-0100111011111001-{address}      [BNE.S (*)+8;JMP <label>]
  public static void irpBnesw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_NE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBnesw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BNE.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_001_sss_sss
  //BNEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //BNZ.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //BNZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //JBNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //JBNEQ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //JBNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //JBNZE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_001_sss_sss [BNE.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BNE.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_010_sss_sss
  //BNEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  //BNZ.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  //BNZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  //JBNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  //JBNEQ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  //JBNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  //JBNZE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_010_sss_sss [BNE.S <label>]
  public static void irpBnes () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_NE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBnes

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BNE.S <label>                                   |-|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)
  //BNEQ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //BNZ.S <label>                                   |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //BNZE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //JBNE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //JBNEQ.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //JBNZ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //JBNZE.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_011_sss_sss (s is not equal to 63)  [BNE.S <label>]
  //BNE.L <label>                                   |-|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}
  //BNEQ.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}        [BNE.L <label>]
  //BNZ.L <label>                                   |A|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}        [BNE.L <label>]
  //BNZE.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_011_111_111-{offset}        [BNE.L <label>]
  public static void irpBnesl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_NE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBnesl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BEQ.W <label>                                   |-|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}
  //BNNE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //BNNZ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //BZE.W <label>                                   |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //JBEQ.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //JBNNE.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //JBNNZ.W <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //JBZE.W <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_000-{offset}        [BEQ.W <label>]
  //BEQ.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)
  //BNNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //BNNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //BZE.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //JBEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //JBNNE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //JBNNZ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //JBZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_sss_sss (s is not equal to 0)   [BEQ.S <label>]
  //JBNE.L <label>                                  |A|012346|-|--*--|-----|          |0110_011_100_000_110-0100111011111001-{address}      [BEQ.S (*)+8;JMP <label>]
  public static void irpBeqsw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_EQ << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBeqsw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BEQ.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_101_sss_sss
  //BNNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //BNNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //BZE.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //JBEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //JBNNE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //JBNNZ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //JBZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_101_sss_sss [BEQ.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BEQ.S <label>                                   |-|012346|-|--*--|-----|          |0110_011_110_sss_sss
  //BNNE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  //BNNZ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  //BZE.S <label>                                   |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  //JBEQ.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  //JBNNE.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  //JBNNZ.S <label>                                 |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  //JBZE.S <label>                                  |A|012346|-|--*--|-----|          |0110_011_110_sss_sss [BEQ.S <label>]
  public static void irpBeqs () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_EQ << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBeqs

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BEQ.S <label>                                   |-|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)
  //BNNE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //BNNZ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //BZE.S <label>                                   |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //JBEQ.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //JBNNE.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //JBNNZ.S <label>                                 |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //JBZE.S <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_sss_sss (s is not equal to 63)  [BEQ.S <label>]
  //BEQ.L <label>                                   |-|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}
  //BNNE.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}        [BEQ.L <label>]
  //BNNZ.L <label>                                  |A|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}        [BEQ.L <label>]
  //BZE.L <label>                                   |A|--2346|-|--*--|-----|          |0110_011_111_111_111-{offset}        [BEQ.L <label>]
  public static void irpBeqsl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_EQ << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBeqsl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVC.W <label>                                   |-|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}
  //BNVS.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}        [BVC.W <label>]
  //JBNVS.W <label>                                 |A|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}        [BVC.W <label>]
  //JBVC.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_000_000-{offset}        [BVC.W <label>]
  //BVC.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)
  //BNVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)   [BVC.S <label>]
  //JBNVS.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)   [BVC.S <label>]
  //JBVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_sss_sss (s is not equal to 0)   [BVC.S <label>]
  //JBNVC.L <label>                                 |A|012346|-|---*-|-----|          |0110_100_000_000_110-0100111011111001-{address}      [BVC.S (*)+8;JMP <label>]
  //JBVS.L <label>                                  |A|012346|-|---*-|-----|          |0110_100_000_000_110-0100111011111001-{address}      [BVC.S (*)+8;JMP <label>]
  public static void irpBvcsw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_VC << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBvcsw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVC.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_001_sss_sss
  //BNVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_001_sss_sss [BVC.S <label>]
  //JBNVS.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_001_sss_sss [BVC.S <label>]
  //JBVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_001_sss_sss [BVC.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVC.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_010_sss_sss
  //BNVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_010_sss_sss [BVC.S <label>]
  //JBNVS.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_010_sss_sss [BVC.S <label>]
  //JBVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_010_sss_sss [BVC.S <label>]
  public static void irpBvcs () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_VC << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBvcs

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVC.S <label>                                   |-|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)
  //BNVS.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)  [BVC.S <label>]
  //JBNVS.S <label>                                 |A|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)  [BVC.S <label>]
  //JBVC.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_011_sss_sss (s is not equal to 63)  [BVC.S <label>]
  //BVC.L <label>                                   |-|--2346|-|---*-|-----|          |0110_100_011_111_111-{offset}
  //BNVS.L <label>                                  |A|--2346|-|---*-|-----|          |0110_100_011_111_111-{offset}        [BVC.L <label>]
  public static void irpBvcsl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_VC << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBvcsl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVS.W <label>                                   |-|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}
  //BNVC.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}        [BVS.W <label>]
  //JBNVC.W <label>                                 |A|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}        [BVS.W <label>]
  //JBVS.W <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_000_000-{offset}        [BVS.W <label>]
  //BVS.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)
  //BNVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)   [BVS.S <label>]
  //JBNVC.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)   [BVS.S <label>]
  //JBVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_sss_sss (s is not equal to 0)   [BVS.S <label>]
  //JBNVS.L <label>                                 |A|012346|-|---*-|-----|          |0110_100_100_000_110-0100111011111001-{address}      [BVS.S (*)+8;JMP <label>]
  //JBVC.L <label>                                  |A|012346|-|---*-|-----|          |0110_100_100_000_110-0100111011111001-{address}      [BVS.S (*)+8;JMP <label>]
  public static void irpBvssw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_VS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBvssw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVS.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_101_sss_sss
  //BNVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_101_sss_sss [BVS.S <label>]
  //JBNVC.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_101_sss_sss [BVS.S <label>]
  //JBVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_101_sss_sss [BVS.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVS.S <label>                                   |-|012346|-|---*-|-----|          |0110_100_110_sss_sss
  //BNVC.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_110_sss_sss [BVS.S <label>]
  //JBNVC.S <label>                                 |A|012346|-|---*-|-----|          |0110_100_110_sss_sss [BVS.S <label>]
  //JBVS.S <label>                                  |A|012346|-|---*-|-----|          |0110_100_110_sss_sss [BVS.S <label>]
  public static void irpBvss () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_VS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBvss

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BVS.S <label>                                   |-|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)
  //BNVC.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)  [BVS.S <label>]
  //JBNVC.S <label>                                 |A|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)  [BVS.S <label>]
  //JBVS.S <label>                                  |A|--2346|-|---*-|-----|          |0110_100_111_sss_sss (s is not equal to 63)  [BVS.S <label>]
  //BVS.L <label>                                   |-|--2346|-|---*-|-----|          |0110_100_111_111_111-{offset}
  //BNVC.L <label>                                  |A|--2346|-|---*-|-----|          |0110_100_111_111_111-{offset}        [BVS.L <label>]
  public static void irpBvssl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_VS << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBvssl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BPL.W <label>                                   |-|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}
  //BNMI.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}        [BPL.W <label>]
  //JBNMI.W <label>                                 |A|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}        [BPL.W <label>]
  //JBPL.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_000_000-{offset}        [BPL.W <label>]
  //BPL.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)
  //BNMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)   [BPL.S <label>]
  //JBNMI.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)   [BPL.S <label>]
  //JBPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_sss_sss (s is not equal to 0)   [BPL.S <label>]
  //JBMI.L <label>                                  |A|012346|-|-*---|-----|          |0110_101_000_000_110-0100111011111001-{address}      [BPL.S (*)+8;JMP <label>]
  //JBNPL.L <label>                                 |A|012346|-|-*---|-----|          |0110_101_000_000_110-0100111011111001-{address}      [BPL.S (*)+8;JMP <label>]
  public static void irpBplsw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_PL << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBplsw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BPL.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_001_sss_sss
  //BNMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_001_sss_sss [BPL.S <label>]
  //JBNMI.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_001_sss_sss [BPL.S <label>]
  //JBPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_001_sss_sss [BPL.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BPL.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_010_sss_sss
  //BNMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_010_sss_sss [BPL.S <label>]
  //JBNMI.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_010_sss_sss [BPL.S <label>]
  //JBPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_010_sss_sss [BPL.S <label>]
  public static void irpBpls () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_PL << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBpls

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BPL.S <label>                                   |-|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)
  //BNMI.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)  [BPL.S <label>]
  //JBNMI.S <label>                                 |A|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)  [BPL.S <label>]
  //JBPL.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_011_sss_sss (s is not equal to 63)  [BPL.S <label>]
  //BPL.L <label>                                   |-|--2346|-|-*---|-----|          |0110_101_011_111_111-{offset}
  //BNMI.L <label>                                  |A|--2346|-|-*---|-----|          |0110_101_011_111_111-{offset}        [BPL.L <label>]
  public static void irpBplsl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_PL << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBplsl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BMI.W <label>                                   |-|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}
  //BNPL.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}        [BMI.W <label>]
  //JBMI.W <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}        [BMI.W <label>]
  //JBNPL.W <label>                                 |A|012346|-|-*---|-----|          |0110_101_100_000_000-{offset}        [BMI.W <label>]
  //BMI.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)
  //BNPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)   [BMI.S <label>]
  //JBMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)   [BMI.S <label>]
  //JBNPL.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_100_sss_sss (s is not equal to 0)   [BMI.S <label>]
  //JBNMI.L <label>                                 |A|012346|-|-*---|-----|          |0110_101_100_000_110-0100111011111001-{address}      [BMI.S (*)+8;JMP <label>]
  //JBPL.L <label>                                  |A|012346|-|-*---|-----|          |0110_101_100_000_110-0100111011111001-{address}      [BMI.S (*)+8;JMP <label>]
  public static void irpBmisw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_MI << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBmisw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BMI.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_101_sss_sss
  //BNPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_101_sss_sss [BMI.S <label>]
  //JBMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_101_sss_sss [BMI.S <label>]
  //JBNPL.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_101_sss_sss [BMI.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BMI.S <label>                                   |-|012346|-|-*---|-----|          |0110_101_110_sss_sss
  //BNPL.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_110_sss_sss [BMI.S <label>]
  //JBMI.S <label>                                  |A|012346|-|-*---|-----|          |0110_101_110_sss_sss [BMI.S <label>]
  //JBNPL.S <label>                                 |A|012346|-|-*---|-----|          |0110_101_110_sss_sss [BMI.S <label>]
  public static void irpBmis () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_MI << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBmis

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BMI.S <label>                                   |-|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)
  //BNPL.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)  [BMI.S <label>]
  //JBMI.S <label>                                  |A|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)  [BMI.S <label>]
  //JBNPL.S <label>                                 |A|--2346|-|-*---|-----|          |0110_101_111_sss_sss (s is not equal to 63)  [BMI.S <label>]
  //BMI.L <label>                                   |-|--2346|-|-*---|-----|          |0110_101_111_111_111-{offset}
  //BNPL.L <label>                                  |A|--2346|-|-*---|-----|          |0110_101_111_111_111-{offset}        [BMI.L <label>]
  public static void irpBmisl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_MI << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBmisl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGE.W <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}
  //BNLT.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}        [BGE.W <label>]
  //JBGE.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}        [BGE.W <label>]
  //JBNLT.W <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_000_000_000-{offset}        [BGE.W <label>]
  //BGE.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)
  //BNLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)   [BGE.S <label>]
  //JBGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)   [BGE.S <label>]
  //JBNLT.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_000_sss_sss (s is not equal to 0)   [BGE.S <label>]
  //JBLT.L <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_000_000_110-0100111011111001-{address}      [BGE.S (*)+8;JMP <label>]
  //JBNGE.L <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_000_000_110-0100111011111001-{address}      [BGE.S (*)+8;JMP <label>]
  public static void irpBgesw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_GE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBgesw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGE.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_001_sss_sss
  //BNLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_001_sss_sss [BGE.S <label>]
  //JBGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_001_sss_sss [BGE.S <label>]
  //JBNLT.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_001_sss_sss [BGE.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGE.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_010_sss_sss
  //BNLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_010_sss_sss [BGE.S <label>]
  //JBGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_010_sss_sss [BGE.S <label>]
  //JBNLT.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_010_sss_sss [BGE.S <label>]
  public static void irpBges () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_GE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBges

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGE.S <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)
  //BNLT.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)  [BGE.S <label>]
  //JBGE.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)  [BGE.S <label>]
  //JBNLT.S <label>                                 |A|--2346|-|-*-*-|-----|          |0110_110_011_sss_sss (s is not equal to 63)  [BGE.S <label>]
  //BGE.L <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_011_111_111-{offset}
  //BNLT.L <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_011_111_111-{offset}        [BGE.L <label>]
  public static void irpBgesl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_GE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBgesl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLT.W <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}
  //BNGE.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}        [BLT.W <label>]
  //JBLT.W <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}        [BLT.W <label>]
  //JBNGE.W <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_100_000_000-{offset}        [BLT.W <label>]
  //BLT.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)
  //BNGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)   [BLT.S <label>]
  //JBLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)   [BLT.S <label>]
  //JBNGE.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_100_sss_sss (s is not equal to 0)   [BLT.S <label>]
  //JBGE.L <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_100_000_110-0100111011111001-{address}      [BLT.S (*)+8;JMP <label>]
  //JBNLT.L <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_100_000_110-0100111011111001-{address}      [BLT.S (*)+8;JMP <label>]
  public static void irpBltsw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LT << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBltsw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLT.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_101_sss_sss
  //BNGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_101_sss_sss [BLT.S <label>]
  //JBLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_101_sss_sss [BLT.S <label>]
  //JBNGE.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_101_sss_sss [BLT.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLT.S <label>                                   |-|012346|-|-*-*-|-----|          |0110_110_110_sss_sss
  //BNGE.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_110_sss_sss [BLT.S <label>]
  //JBLT.S <label>                                  |A|012346|-|-*-*-|-----|          |0110_110_110_sss_sss [BLT.S <label>]
  //JBNGE.S <label>                                 |A|012346|-|-*-*-|-----|          |0110_110_110_sss_sss [BLT.S <label>]
  public static void irpBlts () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LT << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlts

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLT.S <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)
  //BNGE.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)  [BLT.S <label>]
  //JBLT.S <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)  [BLT.S <label>]
  //JBNGE.S <label>                                 |A|--2346|-|-*-*-|-----|          |0110_110_111_sss_sss (s is not equal to 63)  [BLT.S <label>]
  //BLT.L <label>                                   |-|--2346|-|-*-*-|-----|          |0110_110_111_111_111-{offset}
  //BNGE.L <label>                                  |A|--2346|-|-*-*-|-----|          |0110_110_111_111_111-{offset}        [BLT.L <label>]
  public static void irpBltsl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LT << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBltsl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGT.W <label>                                   |-|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}
  //BNLE.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}        [BGT.W <label>]
  //JBGT.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}        [BGT.W <label>]
  //JBNLE.W <label>                                 |A|012346|-|-***-|-----|          |0110_111_000_000_000-{offset}        [BGT.W <label>]
  //BGT.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)
  //BNLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)   [BGT.S <label>]
  //JBGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)   [BGT.S <label>]
  //JBNLE.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_000_sss_sss (s is not equal to 0)   [BGT.S <label>]
  //JBLE.L <label>                                  |A|012346|-|-***-|-----|          |0110_111_000_000_110-0100111011111001-{address}      [BGT.S (*)+8;JMP <label>]
  //JBNGT.L <label>                                 |A|012346|-|-***-|-----|          |0110_111_000_000_110-0100111011111001-{address}      [BGT.S (*)+8;JMP <label>]
  public static void irpBgtsw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_GT << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBgtsw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGT.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_001_sss_sss
  //BNLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_001_sss_sss [BGT.S <label>]
  //JBGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_001_sss_sss [BGT.S <label>]
  //JBNLE.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_001_sss_sss [BGT.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGT.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_010_sss_sss
  //BNLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_010_sss_sss [BGT.S <label>]
  //JBGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_010_sss_sss [BGT.S <label>]
  //JBNLE.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_010_sss_sss [BGT.S <label>]
  public static void irpBgts () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_GT << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBgts

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BGT.S <label>                                   |-|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)
  //BNLE.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)  [BGT.S <label>]
  //JBGT.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)  [BGT.S <label>]
  //JBNLE.S <label>                                 |A|--2346|-|-***-|-----|          |0110_111_011_sss_sss (s is not equal to 63)  [BGT.S <label>]
  //BGT.L <label>                                   |-|--2346|-|-***-|-----|          |0110_111_011_111_111-{offset}
  //BNLE.L <label>                                  |A|--2346|-|-***-|-----|          |0110_111_011_111_111-{offset}        [BGT.L <label>]
  public static void irpBgtsl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_GT << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBgtsl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLE.W <label>                                   |-|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}
  //BNGT.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}        [BLE.W <label>]
  //JBLE.W <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}        [BLE.W <label>]
  //JBNGT.W <label>                                 |A|012346|-|-***-|-----|          |0110_111_100_000_000-{offset}        [BLE.W <label>]
  //BLE.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)
  //BNGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)   [BLE.S <label>]
  //JBLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)   [BLE.S <label>]
  //JBNGT.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_100_sss_sss (s is not equal to 0)   [BLE.S <label>]
  //JBGT.L <label>                                  |A|012346|-|-***-|-----|          |0110_111_100_000_110-0100111011111001-{address}      [BLE.S (*)+8;JMP <label>]
  //JBNLE.L <label>                                 |A|012346|-|-***-|-----|          |0110_111_100_000_110-0100111011111001-{address}      [BLE.S (*)+8;JMP <label>]
  public static void irpBlesw () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == 0) {  //Bcc.W
      XEiJ.regPC = t + 2;  //pc0+4
      s = mmuReadWordSignExword (t, XEiJ.regSRS);  //16bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlesw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLE.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_101_sss_sss
  //BNGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_101_sss_sss [BLE.S <label>]
  //JBLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_101_sss_sss [BLE.S <label>]
  //JBNGT.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_101_sss_sss [BLE.S <label>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLE.S <label>                                   |-|012346|-|-***-|-----|          |0110_111_110_sss_sss
  //BNGT.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_110_sss_sss [BLE.S <label>]
  //JBLE.S <label>                                  |A|012346|-|-***-|-----|          |0110_111_110_sss_sss [BLE.S <label>]
  //JBNGT.S <label>                                 |A|012346|-|-***-|-----|          |0110_111_110_sss_sss [BLE.S <label>]
  public static void irpBles () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBles

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BLE.S <label>                                   |-|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)
  //BNGT.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)  [BLE.S <label>]
  //JBLE.S <label>                                  |A|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)  [BLE.S <label>]
  //JBNGT.S <label>                                 |A|--2346|-|-***-|-----|          |0110_111_111_sss_sss (s is not equal to 63)  [BLE.S <label>]
  //BLE.L <label>                                   |-|--2346|-|-***-|-----|          |0110_111_111_111_111-{offset}
  //BNGT.L <label>                                  |A|--2346|-|-***-|-----|          |0110_111_111_111_111-{offset}        [BLE.L <label>]
  public static void irpBlesl () throws M68kException {
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    int s = (byte) XEiJ.regOC;  //8bitディスプレースメント
    if (s == -1) {  //Bcc.L
      XEiJ.regPC = t + 4;  //pc0+6
      s = mmuReadLongExword (t, XEiJ.regSRS);  //32bitディスプレースメント
    }
    t += s;  //pc0+2+ディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.MPU_CC_LE << XEiJ.regCCR < 0) {  //分岐する
      irpSetPC (t);
    }
  }  //irpBlesl

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //IOCS <name>                                     |A|012346|-|UUUUU|UUUUU|          |0111_000_0dd_ddd_ddd-0100111001001111        [MOVEQ.L #<data>,D0;TRAP #15]
  //MOVEQ.L #<data>,Dq                              |-|012346|-|-UUUU|-**00|          |0111_qqq_0dd_ddd_ddd
  public static void irpMoveq () throws M68kException {
    XEiJ.mpuCycleCount++;
    int z;
    XEiJ.regRn[XEiJ.regOC >> 9 & 7] = z = (byte) XEiJ.regOC;
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMoveq

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MVS.B <ea>,Dq                                   |-|------|-|-UUUU|-**00|D M+-WXZPI|0111_qqq_100_mmm_rrr (ISA_B)
  //
  //MVS.B <ea>,Dq
  //  バイトデータをロングに符号拡張してDqの全体を更新する
  public static void irpMvsByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z;
    XEiJ.regRn[XEiJ.regOC >> 9 & 7] = z = ea < XEiJ.EA_AR ? (byte) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMvsByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MVS.W <ea>,Dq                                   |-|------|-|-UUUU|-**00|D M+-WXZPI|0111_qqq_101_mmm_rrr (ISA_B)
  //
  //MVS.W <ea>,Dq
  //  ワードデータをロングに符号拡張してDqの全体を更新する
  public static void irpMvsWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z;
    XEiJ.regRn[XEiJ.regOC >> 9 & 7] = z = ea < XEiJ.EA_AR ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //pcws。イミディエイトを分離
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMvsWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MVZ.B <ea>,Dq                                   |-|------|-|-UUUU|-0*00|D M+-WXZPI|0111_qqq_110_mmm_rrr (ISA_B)
  //
  //MVZ.B <ea>,Dq
  //  バイトデータをロングにゼロ拡張してDqの全体を更新する
  public static void irpMvzByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z;
    XEiJ.regRn[XEiJ.regOC >> 9 & 7] = z = ea < XEiJ.EA_AR ? 0xff & XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteZeroExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteZeroData (efaAnyByte (ea), XEiJ.regSRS);  //pcbz。イミディエイトを分離
    XEiJ.regCCR = XEiJ.REG_CCR_X & XEiJ.regCCR | (z == 0 ? XEiJ.REG_CCR_Z : 0);
  }  //irpMvzByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MVZ.W <ea>,Dq                                   |-|------|-|-UUUU|-0*00|D M+-WXZPI|0111_qqq_111_mmm_rrr (ISA_B)
  //
  //MVZ.W <ea>,Dq
  //  ワードデータをロングにゼロ拡張してDqの全体を更新する
  public static void irpMvzWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z;
    XEiJ.regRn[XEiJ.regOC >> 9 & 7] = z = ea < XEiJ.EA_AR ? (char) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordZeroData (efaAnyWord (ea), XEiJ.regSRS);  //pcwz。イミディエイトを分離
    XEiJ.regCCR = XEiJ.REG_CCR_X & XEiJ.regCCR | (z == 0 ? XEiJ.REG_CCR_Z : 0);
  }  //irpMvzWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //OR.B <ea>,Dq                                    |-|012346|-|-UUUU|-**00|D M+-WXZPI|1000_qqq_000_mmm_rrr
  public static void irpOrToRegByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & (XEiJ.regRn[XEiJ.regOC >> 9 & 7] |= 255 & (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS)))];  //ccr_tst_byte。pcbs。イミディエイトを分離。0拡張してからOR
  }  //irpOrToRegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //OR.W <ea>,Dq                                    |-|012346|-|-UUUU|-**00|D M+-WXZPI|1000_qqq_001_mmm_rrr
  public static void irpOrToRegWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = (short) (XEiJ.regRn[XEiJ.regOC >> 9 & 7] |= ea < XEiJ.EA_AR ? (char) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordZeroData (efaAnyWord (ea), XEiJ.regSRS));  //pcwz。イミディエイトを分離。0拡張してからOR
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpOrToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //OR.L <ea>,Dq                                    |-|012346|-|-UUUU|-**00|D M+-WXZPI|1000_qqq_010_mmm_rrr
  public static void irpOrToRegLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] |= ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpOrToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //DIVU.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1000_qqq_011_mmm_rrr
  //
  //DIVU.W <ea>,Dq
  //  M68000PRMでDIVU.Wのオーバーフローの条件が16bit符号あり整数と書かれているのは16bit符号なし整数の間違い
  public static void irpDivuWord () throws M68kException {
    //  X  変化しない
    //  N  ゼロ除算またはオーバーフローのとき不定。商が負のときセット。それ以外はクリア
    //  Z  ゼロ除算またはオーバーフローのとき不定。商が0のときセット。それ以外はクリア
    //  V  ゼロ除算のとき不定。オーバーフローのときセット。それ以外はクリア
    //  C  常にクリア
    XEiJ.mpuCycleCount += 22;  //最大
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int y = ea < XEiJ.EA_AR ? (char) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordZeroData (efaAnyWord (ea), XEiJ.regSRS);  //除数。pcwz。イミディエイトを分離
    int x = XEiJ.regRn[qqq];  //被除数
    if (y == 0) {  //ゼロ除算
      //Dqは変化しない
      XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z | XEiJ.REG_CCR_V)  //XとNとZとVは変化しない
                     );  //Cは常にクリア
      M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
      M68kException.m6eNumber = M68kException.M6E_DIVIDE_BY_ZERO;
      throw M68kException.m6eSignal;
    }
    //無理にintで符号なし除算をやろうとするよりもdoubleにキャストしてから割ったほうが速い
    //  intの除算をdoubleの除算器で行うプロセッサならばなおさら
    //被除数を符号なし32ビットとみなすためlongを経由してdoubleに変換する
    //doubleからlongやintへのキャストは小数点以下が切り捨てられ、オーバーフローは表現できる絶対値最大の値になる
    //doubleから直接intに戻しているので0xffffffff/0x0001=0xffffffffが絶対値最大の0x7fffffffになってしまうが、
    //DIVU.Wではオーバーフローになることに変わりはないのでよいことにする
    //  符号なし32ビットの0xffffffffにしたいときは戻すときもlongを経由すればよい
    int z = (int) ((double) ((long) x & 0xffffffffL) / (double) y);  //商
    if (z >>> 16 != 0) {  //オーバーフローあり
      //Dqは変化しない
      XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z) |  //XとNとZは変化しない
                     XEiJ.REG_CCR_V  //Vは常にセット
                     );  //Cは常にクリア
    } else {  //オーバーフローなし
      XEiJ.regRn[qqq] = x - y * z << 16 | z;  //余り<<16|商
      z = (short) z;
      XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |  //Xは変化しない
                     (z < 0 ? XEiJ.REG_CCR_N : 0) |  //Nは商が負のときセット、さもなくばクリア
                     (z == 0 ? XEiJ.REG_CCR_Z : 0)  //Zは商が0のときセット、さもなくばクリア
                     //Vは常にクリア
                     );  //Cは常にクリア
    }  //if オーバーフローあり/オーバーフローなし
  }  //irpDivuWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SBCD.B Dr,Dq                                    |-|012346|-|UUUUU|*U*U*|          |1000_qqq_100_000_rrr
  //SBCD.B -(Ar),-(Aq)                              |-|012346|-|UUUUU|*U*U*|          |1000_qqq_100_001_rrr
  //OR.B Dq,<ea>                                    |-|012346|-|-UUUU|-**00|  M+-WXZ  |1000_qqq_100_mmm_rrr
  public static void irpOrToMemByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >= XEiJ.EA_MM) {  //OR.B Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      int z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] | mmuReadByteSignData (a, XEiJ.regSRS);
      mmuWriteByteData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    } else if (ea < XEiJ.EA_AR) {  //SBCD.B Dr,Dq
      int qqq = XEiJ.regOC >> 9 & 7;
      XEiJ.mpuCycleCount++;
      int x;
      XEiJ.regRn[qqq] = ~0xff & (x = XEiJ.regRn[qqq]) | irpSbcd (x, XEiJ.regRn[ea]);
    } else {  //SBCD.B -(Ar),-(Aq)
      XEiJ.mpuCycleCount += 2;
      M68kException.m6eIncremented -= 1L << (ea << 3);
      int a = --XEiJ.regRn[ea];  //このr[ea]はアドレスレジスタ
      int y = mmuReadByteZeroData (a, XEiJ.regSRS);
      int aqq = (XEiJ.regOC >> 9) - (64 - 8);
      M68kException.m6eIncremented -= 1L << (aqq << 3);
      a = --XEiJ.regRn[aqq];
      mmuWriteByteData (a, irpSbcd (mmuModifyByteZeroData (a, XEiJ.regSRS), y), XEiJ.regSRS);
    }
  }  //irpOrToMemByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //PACK Dr,Dq,#<data>                              |-|--2346|-|-----|-----|          |1000_qqq_101_000_rrr-{data}
  //PACK -(Ar),-(Aq),#<data>                        |-|--2346|-|-----|-----|          |1000_qqq_101_001_rrr-{data}
  //OR.W Dq,<ea>                                    |-|012346|-|-UUUU|-**00|  M+-WXZ  |1000_qqq_101_mmm_rrr
  //
  //PACK Dr,Dq,#<data>
  //PACK -(Ar),-(Aq),#<data>
  //  PACK/UNPKは第1オペランドのソースと第2オペランドのデスティネーションのサイズが違う。パックされていない方がワードでされている方がバイト
  //  10の位を4ビット右または左にシフトする。第3オペランドの補正値はワードでパックされていない方に加算する。CCRは変化しない
  public static void irpOrToMemWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >= XEiJ.EA_MM) {  //OR.W Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      int z;
      mmuWriteWordData (a, z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] | mmuModifyWordSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    } else if (ea < XEiJ.EA_AR) {  //PACK Dr,Dq,#<data>
      XEiJ.mpuCycleCount += 2;
      int qqq = XEiJ.regOC >> 9 & 7;
      int t = XEiJ.regRn[ea] + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      XEiJ.regRn[qqq] = ~0xff & XEiJ.regRn[qqq] | t >> 4 & 0xf0 | t & 15;
    } else {  //PACK -(Ar),-(Aq),#<data>
      int o = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      M68kException.m6eIncremented -= 2L << (ea << 3);
      int a = XEiJ.regRn[ea] -= 2;
      int t = mmuReadWordSignData (a, XEiJ.regSRS) + o;  //020以上なのでアドレスエラーは出ない
      int aqq = (XEiJ.regOC >> 9) - (64 - 8);
      M68kException.m6eIncremented -= 1L << (aqq << 3);
      a = --XEiJ.regRn[aqq];
      mmuWriteByteData (a, t >> 4 & 0xf0 | t & 15, XEiJ.regSRS);
    }
  }  //irpOrToMemWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //UNPK Dr,Dq,#<data>                              |-|--2346|-|-----|-----|          |1000_qqq_110_000_rrr-{data}
  //UNPK -(Ar),-(Aq),#<data>                        |-|--2346|-|-----|-----|          |1000_qqq_110_001_rrr-{data}
  //OR.L Dq,<ea>                                    |-|012346|-|-UUUU|-**00|  M+-WXZ  |1000_qqq_110_mmm_rrr
  //
  //UNPK Dr,Dq,#<data>
  //UNPK -(Ar),-(Aq),#<data>
  //  PACK/UNPKは第1オペランドのソースと第2オペランドのデスティネーションのサイズが違う。パックされていない方がワードでされている方がバイト
  //  10の位を4ビット右または左にシフトする。第3オペランドの補正値はワードでパックされていない方に加算する。CCRは変化しない
  public static void irpOrToMemLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >= XEiJ.EA_MM) {  //OR.L Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      int z;
      mmuWriteLongData (a, z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] | mmuModifyLongData (a, XEiJ.regSRS), XEiJ.regSRS);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    } else if (ea < XEiJ.EA_AR) {  //UNPK Dr,Dq,#<data>
      int qqq = XEiJ.regOC >> 9 & 7;
      int t = XEiJ.regRn[ea];
      XEiJ.regRn[qqq] = ~0xffff & XEiJ.regRn[qqq] | (char) ((t << 4 & 0x0f00 | t & 15) + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws
    } else {  //UNPK -(Ar),-(Aq),#<data>
      int o = mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
      M68kException.m6eIncremented -= 1L << (ea << 3);
      int a = --XEiJ.regRn[ea];
      int t = mmuReadByteSignData (a, XEiJ.regSRS);
      int aqq = (XEiJ.regOC >> 9) - (64 - 8);
      M68kException.m6eIncremented -= 2L << (aqq << 3);
      a = XEiJ.regRn[aqq] -= 2;
      mmuWriteWordData (a, (t << 4 & 0x0f00 | t & 15) + o, XEiJ.regSRS);  //020以上なのでアドレスエラーは出ない
    }
  }  //irpOrToMemLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //DIVS.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1000_qqq_111_mmm_rrr
  //
  //DIVS.W <ea>,Dq
  //  DIVSの余りの符号は被除数と一致
  //  M68000PRMでDIVS.Wのアドレッシングモードがデータ可変と書かれているのはデータの間違い
  public static void irpDivsWord () throws M68kException {
    //  X  変化しない
    //  N  ゼロ除算またはオーバーフローのとき不定。商が負のときセット。それ以外はクリア
    //  Z  ゼロ除算またはオーバーフローのとき不定。商が0のときセット。それ以外はクリア
    //  V  ゼロ除算のとき不定。オーバーフローのときセット。それ以外はクリア
    //  C  常にクリア
    //divsの余りの符号は被除数と一致
    //Javaの除算演算子の挙動
    //   10 /  3 ==  3   10 %  3 ==  1   10 =  3 *  3 +  1
    //   10 / -3 == -3   10 % -3 ==  1   10 = -3 * -3 +  1
    //  -10 /  3 == -3  -10 %  3 == -1  -10 =  3 * -3 + -1
    //  -10 / -3 ==  3  -10 % -3 == -1  -10 = -3 *  3 + -1
    XEiJ.mpuCycleCount += 22;  //最大
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int y = ea < XEiJ.EA_AR ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //除数。pcws。イミディエイトを分離
    int x = XEiJ.regRn[qqq];  //被除数
    if (y == 0) {  //ゼロ除算
      //Dqは変化しない
      XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z | XEiJ.REG_CCR_V)  //XとNとZとVは変化しない
                     );  //Cは常にクリア
      M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
      M68kException.m6eNumber = M68kException.M6E_DIVIDE_BY_ZERO;
      throw M68kException.m6eSignal;
    }
    int z = x / y;  //商
    if ((short) z != z) {  //オーバーフローあり
      //Dqは変化しない
      XEiJ.regCCR = (XEiJ.regCCR & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_N | XEiJ.REG_CCR_Z) |  //XとNとZは変化しない
                     XEiJ.REG_CCR_V  //Vは常にセット
                     );  //Cは常にクリア
    } else {  //オーバーフローなし
      XEiJ.regRn[qqq] = x - y * z << 16 | (char) z;  //Dqは余り<<16|商&$ffff
      XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |  //Xは変化しない
                     (z < 0 ? XEiJ.REG_CCR_N : 0) |  //Nは商が負のときセット、さもなくばクリア
                     (z == 0 ? XEiJ.REG_CCR_Z : 0)  //Zは商が0のときセット、さもなくばクリア
                     //Vは常にクリア
                     );  //Cは常にクリア
    }
  }  //irpDivsWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUB.B <ea>,Dq                                   |-|012346|-|UUUUU|*****|D M+-WXZPI|1001_qqq_000_mmm_rrr
  public static void irpSubToRegByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int x, y, z;
    y = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離
    x = XEiJ.regRn[qqq];
    z = x - y;
    XEiJ.regRn[qqq] = ~255 & x | 255 & z;
    XEiJ.regCCR = (XEiJ.MPU_TSTB_TABLE[255 & z] |
           ((x ^ y) & (x ^ z)) >> 6 & XEiJ.REG_CCR_V |
           (byte) (x & (y ^ z) ^ (y | z)) >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub_byte
  }  //irpSubToRegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUB.W <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1001_qqq_001_mmm_rrr
  public static void irpSubToRegWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int x, y, z;
    y = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離
    x = XEiJ.regRn[qqq];
    z = x - y;
    XEiJ.regRn[qqq] = ~65535 & x | (char) z;
    XEiJ.regCCR = (z >> 12 & XEiJ.REG_CCR_N | (char) z - 1 >> 14 & XEiJ.REG_CCR_Z |
           ((x ^ y) & (x ^ z)) >> 14 & XEiJ.REG_CCR_V |
           (short) (x & (y ^ z) ^ (y | z)) >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub_word
  }  //irpSubToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUB.L <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1001_qqq_010_mmm_rrr
  public static void irpSubToRegLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    XEiJ.mpuCycleCount++;
    int x, y, z;
    y = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcls。イミディエイトを分離
    x = XEiJ.regRn[qqq];
    z = x - y;
    XEiJ.regRn[qqq] = z;
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ y) & (x ^ z)) >> 30 & XEiJ.REG_CCR_V |
           (x & (y ^ z) ^ (y | z)) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub
  }  //irpSubToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBA.W <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_011_mmm_rrr
  //SUB.W <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_011_mmm_rrr [SUBA.W <ea>,Aq]
  //CLR.W Ar                                        |A|012346|-|-----|-----| A        |1001_rrr_011_001_rrr [SUBA.W Ar,Ar]
  //
  //SUBA.W <ea>,Aq
  //  ソースを符号拡張してロングで減算する
  public static void irpSubaWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    XEiJ.regRn[XEiJ.regOC >> 9 & 15] -= z;  //r[op >> 9 & 15] -= ea < XEiJ.EA_MM ? (short) r[ea] : rws (efaAnyWord (ea));は不可
    //ccrは変化しない
  }  //irpSubaWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBX.B Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1001_qqq_100_000_rrr
  //SUBX.B -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1001_qqq_100_001_rrr
  //SUB.B Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1001_qqq_100_mmm_rrr
  public static void irpSubToMemByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int a, x, y, z;
    if (ea < XEiJ.EA_MM) {
      if (ea < XEiJ.EA_AR) {  //SUBX.B Dr,Dq
        int qqq = XEiJ.regOC >> 9 & 7;
        XEiJ.mpuCycleCount++;
        y = XEiJ.regRn[ea];
        x = XEiJ.regRn[qqq];
        z = x - y - (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        XEiJ.regRn[qqq] = ~255 & x | 255 & z;
      } else {  //SUBX.B -(Ar),-(Aq)
        XEiJ.mpuCycleCount += 2;
        M68kException.m6eIncremented -= 1L << (ea << 3);
        a = --XEiJ.regRn[ea];
        y = mmuReadByteSignData (a, XEiJ.regSRS);  //このr[ea]はアドレスレジスタ
        int aqq = XEiJ.regOC >> 9 & 15;  //1qqq=aqq
        M68kException.m6eIncremented -= 1L << (aqq << 3);
        a = --XEiJ.regRn[aqq];
        x = mmuModifyByteSignData (a, XEiJ.regSRS);
        z = x - y - (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        mmuWriteByteData (a, z, XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 4 & XEiJ.REG_CCR_N | (255 & z) - 1 >> 6 & XEiJ.regCCR & XEiJ.REG_CCR_Z |  //SUBXはZをクリアすることはあるがセットすることはない
             ((x ^ y) & (x ^ z)) >> 6 & XEiJ.REG_CCR_V |
             (byte) (x & (y ^ z) ^ (y | z)) >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_subx_byte
    } else {  //SUB.B Dq,<ea>
      XEiJ.mpuCycleCount++;
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7];
      a = efaMltByte (ea);
      x = mmuModifyByteSignData (a, XEiJ.regSRS);
      z = x - y;
      mmuWriteByteData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = (XEiJ.MPU_TSTB_TABLE[255 & z] |
             ((x ^ y) & (x ^ z)) >> 6 & XEiJ.REG_CCR_V |
             (byte) (x & (y ^ z) ^ (y | z)) >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub_byte
    }
  }  //irpSubToMemByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBX.W Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1001_qqq_101_000_rrr
  //SUBX.W -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1001_qqq_101_001_rrr
  //SUB.W Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1001_qqq_101_mmm_rrr
  public static void irpSubToMemWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int a, x, y, z;
    if (ea < XEiJ.EA_MM) {
      if (ea < XEiJ.EA_AR) {  //SUBX.W Dr,Dq
        int qqq = XEiJ.regOC >> 9 & 7;
        XEiJ.mpuCycleCount++;
        y = XEiJ.regRn[ea];
        x = XEiJ.regRn[qqq];
        z = x - y - (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        XEiJ.regRn[qqq] = ~65535 & x | (char) z;
      } else {  //SUBX.W -(Ar),-(Aq)
        XEiJ.mpuCycleCount += 2;
        M68kException.m6eIncremented -= 2L << (ea << 3);
        a = XEiJ.regRn[ea] -= 2;
        y = mmuReadWordSignData (a, XEiJ.regSRS);  //このr[ea]はアドレスレジスタ
        int aqq = XEiJ.regOC >> 9 & 15;
        M68kException.m6eIncremented -= 2L << (aqq << 3);
        a = XEiJ.regRn[aqq] -= 2;
        x = mmuModifyWordSignData (a, XEiJ.regSRS);
        z = x - y - (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        mmuWriteWordData (a, z, XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 12 & XEiJ.REG_CCR_N | (char) z - 1 >> 14 & XEiJ.regCCR & XEiJ.REG_CCR_Z |  //ADDXはZをクリアすることはあるがセットすることはない
             ((x ^ y) & (x ^ z)) >> 14 & XEiJ.REG_CCR_V |
             (short) (x & (y ^ z) ^ (y | z)) >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_subx_word
    } else {  //SUB.W Dq,<ea>
      XEiJ.mpuCycleCount++;
      y = (short) XEiJ.regRn[XEiJ.regOC >> 9 & 7];
      a = efaMltWord (ea);
      x = mmuModifyWordSignData (a, XEiJ.regSRS);
      z = x - y;
      mmuWriteWordData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = (z >> 12 & XEiJ.REG_CCR_N | (char) z - 1 >> 14 & XEiJ.REG_CCR_Z |
             ((x ^ y) & (x ^ z)) >> 14 & XEiJ.REG_CCR_V |
             (short) (x & (y ^ z) ^ (y | z)) >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub_word
    }
  }  //irpSubToMemWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBX.L Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1001_qqq_110_000_rrr
  //SUBX.L -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1001_qqq_110_001_rrr
  //SUB.L Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1001_qqq_110_mmm_rrr
  public static void irpSubToMemLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_MM) {
      int x;
      int y;
      int z;
      if (ea < XEiJ.EA_AR) {  //SUBX.L Dr,Dq
        int qqq = XEiJ.regOC >> 9 & 7;
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[qqq] = z = (x = XEiJ.regRn[qqq]) - (y = XEiJ.regRn[ea]) - (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
      } else {  //SUBX.L -(Ar),-(Aq)
        XEiJ.mpuCycleCount += 2;
        M68kException.m6eIncremented -= 4L << (ea << 3);
        int a = XEiJ.regRn[ea] -= 4;  //このr[ea]はアドレスレジスタ
        y = mmuReadLongData (a, XEiJ.regSRS);
        int aqq = XEiJ.regOC >> 9 & 15;
        M68kException.m6eIncremented -= 4L << (aqq << 3);
        a = XEiJ.regRn[aqq] -= 4;
        mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) - y - (XEiJ.regCCR >> 4), XEiJ.regSRS);  //Xの左側はすべて0なのでCCR_X&を省略
      }
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_Z : 0) |
             ((x ^ y) & (x ^ z)) >>> 31 << 1 |
             (x & (y ^ z) ^ (y | z)) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_subx
    } else {  //SUB.L Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      int x;
      int y;
      int z;
      mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) - (y = XEiJ.regRn[XEiJ.regOC >> 9 & 7]), XEiJ.regSRS);
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
             ((x ^ y) & (x ^ z)) >>> 31 << 1 |
             (x & (y ^ z) ^ (y | z)) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_sub
    }
  }  //irpSubToMemLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SUBA.L <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_111_mmm_rrr
  //SUB.L <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1001_qqq_111_mmm_rrr [SUBA.L <ea>,Aq]
  //CLR.L Ar                                        |A|012346|-|-----|-----| A        |1001_rrr_111_001_rrr [SUBA.L Ar,Ar]
  public static void irpSubaLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    XEiJ.mpuCycleCount++;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcls。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    XEiJ.regRn[XEiJ.regOC >> 9 & 15] -= z;  //r[op >> 9 & 15] -= ea < XEiJ.EA_MM ? r[ea] : rls (efaAnyLong (ea));は不可
    //ccrは変化しない
  }  //irpSubaLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //SXCALL <name>                                   |A|012346|-|UUUUU|*****|          |1010_0dd_ddd_ddd_ddd [ALINE #<data>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ALINE #<data>                                   |-|012346|-|UUUUU|*****|          |1010_ddd_ddd_ddd_ddd (line 1010 emulator)
  public static void irpAline () throws M68kException {
    irpExceptionFormat0 (M68kException.M6E_LINE_1010_EMULATOR << 2, XEiJ.regPC0);  //pcは命令の先頭
  }  //irpAline

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMP.B <ea>,Dq                                   |-|012346|-|-UUUU|-****|D M+-WXZPI|1011_qqq_000_mmm_rrr
  public static void irpCmpByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int x;
    int y;
    int z = (byte) ((x = (byte) XEiJ.regRn[XEiJ.regOC >> 9 & 7]) - (y = ea < XEiJ.EA_AR ? (byte) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS)));  //pcbs。イミディエイトを分離
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMP.W <ea>,Dq                                   |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_001_mmm_rrr
  public static void irpCmpWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int x;
    int y;
    int z = (short) ((x = (short) XEiJ.regRn[XEiJ.regOC >> 9 & 7]) - (y = ea < XEiJ.EA_MM ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS)));  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMP.L <ea>,Dq                                   |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_010_mmm_rrr
  public static void irpCmpLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int x;
    int y;
    int z = (x = XEiJ.regRn[XEiJ.regOC >> 9 & 7]) - (y = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS));  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcls。イミディエイトを分離
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMPA.W <ea>,Aq                                  |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_011_mmm_rrr
  //CMP.W <ea>,Aq                                   |A|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_011_mmm_rrr [CMPA.W <ea>,Aq]
  //
  //CMPA.W <ea>,Aq
  //  ソースを符号拡張してロングで比較する
  public static void irpCmpaWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    //ソースを符号拡張してからロングで比較する
    int y = ea < XEiJ.EA_MM ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int x;
    int z = (x = XEiJ.regRn[XEiJ.regOC >> 9 & 15]) - y;
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpaWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EOR.B Dq,<ea>                                   |-|012346|-|-UUUU|-**00|D M+-WXZ  |1011_qqq_100_mmm_rrr
  //CMPM.B (Ar)+,(Aq)+                              |-|012346|-|-UUUU|-****|          |1011_qqq_100_001_rrr
  public static void irpEorByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //CMPM.B (Ar)+,(Aq)+
      XEiJ.mpuCycleCount += 2;
      M68kException.m6eIncremented += 1L << (ea << 3);
      int a = XEiJ.regRn[ea]++;  //このr[ea]はアドレスレジスタ
      int y = mmuReadByteSignData (a, XEiJ.regSRS);
      int x;
      int aqq = XEiJ.regOC >> 9 & 15;
      M68kException.m6eIncremented += 1L << (aqq << 3);
      a = XEiJ.regRn[aqq]++;
      int z = (byte) ((x = mmuReadByteSignData (a, XEiJ.regSRS)) - y);
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
             ((x ^ y) & (x ^ z)) >>> 31 << 1 |
             (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
    } else {
      int qqq = XEiJ.regOC >> 9 & 7;
      int z;
      if (ea < XEiJ.EA_AR) {  //EOR.B Dq,Dr
        XEiJ.mpuCycleCount++;
        z = XEiJ.regRn[ea] ^= 255 & XEiJ.regRn[qqq];  //0拡張してからEOR
      } else {  //EOR.B Dq,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltByte (ea);
        mmuWriteByteData (a, z = XEiJ.regRn[qqq] ^ mmuModifyByteSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      }
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    }
  }  //irpEorByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EOR.W Dq,<ea>                                   |-|012346|-|-UUUU|-**00|D M+-WXZ  |1011_qqq_101_mmm_rrr
  //CMPM.W (Ar)+,(Aq)+                              |-|012346|-|-UUUU|-****|          |1011_qqq_101_001_rrr
  public static void irpEorWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int rrr = XEiJ.regOC & 7;
    int mmm = ea >> 3;
    if (mmm == XEiJ.MMM_AR) {  //CMPM.W (Ar)+,(Aq)+
      XEiJ.mpuCycleCount += 2;
      M68kException.m6eIncremented += 2L << (ea << 3);
      int a = (XEiJ.regRn[ea] += 2) - 2;  //このr[ea]はアドレスレジスタ
      int y = mmuReadWordSignData (a, XEiJ.regSRS);
      int x;
      int aqq = XEiJ.regOC >> 9 & 15;
      M68kException.m6eIncremented += 2L << (aqq << 3);
      a = (XEiJ.regRn[aqq] += 2) - 2;
      int z = (short) ((x = mmuReadWordSignData (a, XEiJ.regSRS)) - y);
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
             ((x ^ y) & (x ^ z)) >>> 31 << 1 |
             (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
    } else {
      int qqq = XEiJ.regOC >> 9 & 7;
      int z;
      if (ea < XEiJ.EA_AR) {  //EOR.W Dq,Dr
        XEiJ.mpuCycleCount++;
        z = XEiJ.regRn[rrr] ^= (char) XEiJ.regRn[qqq];  //0拡張してからEOR
      } else {  //EOR.W Dq,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltWord (ea);
        mmuWriteWordData (a, z = XEiJ.regRn[qqq] ^ mmuModifyWordSignData (a, XEiJ.regSRS), XEiJ.regSRS);
      }
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    }
  }  //irpEorWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EOR.L Dq,<ea>                                   |-|012346|-|-UUUU|-**00|D M+-WXZ  |1011_qqq_110_mmm_rrr
  //CMPM.L (Ar)+,(Aq)+                              |-|012346|-|-UUUU|-****|          |1011_qqq_110_001_rrr
  public static void irpEorLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >> 3 == XEiJ.MMM_AR) {  //CMPM.L (Ar)+,(Aq)+
      XEiJ.mpuCycleCount += 2;
      M68kException.m6eIncremented += 4L << (ea << 3);
      int a = (XEiJ.regRn[ea] += 4) - 4;  //このr[ea]はアドレスレジスタ
      int y = mmuReadLongData (a, XEiJ.regSRS);
      int x;
      int aqq = XEiJ.regOC >> 9 & 15;
      M68kException.m6eIncremented += 4L << (aqq << 3);
      a = (XEiJ.regRn[aqq] += 4) - 4;
      int z = (x = mmuReadLongData (a, XEiJ.regSRS)) - y;
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
             ((x ^ y) & (x ^ z)) >>> 31 << 1 |
             (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
    } else {
      int qqq = XEiJ.regOC >> 9 & 7;
      int z;
      if (ea < XEiJ.EA_AR) {  //EOR.L Dq,Dr
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] = z = XEiJ.regRn[ea] ^ XEiJ.regRn[qqq];
      } else {  //EOR.L Dq,<mem>
        XEiJ.mpuCycleCount++;
        int a = efaMltLong (ea);
        mmuWriteLongData (a, z = mmuModifyLongData (a, XEiJ.regSRS) ^ XEiJ.regRn[qqq], XEiJ.regSRS);
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    }
  }  //irpEorLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CMPA.L <ea>,Aq                                  |-|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_111_mmm_rrr
  //CMP.L <ea>,Aq                                   |A|012346|-|-UUUU|-****|DAM+-WXZPI|1011_qqq_111_mmm_rrr [CMPA.L <ea>,Aq]
  public static void irpCmpaLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int y = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcls。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    int x;
    int z = (x = XEiJ.regRn[XEiJ.regOC >> 9 & 15]) - y;
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) |
           ((x ^ y) & (x ^ z)) >>> 31 << 1 |
           (x & (y ^ z) ^ (y | z)) >>> 31);  //ccr_cmp
  }  //irpCmpaLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //AND.B <ea>,Dq                                   |-|012346|-|-UUUU|-**00|D M+-WXZPI|1100_qqq_000_mmm_rrr
  public static void irpAndToRegByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & (XEiJ.regRn[XEiJ.regOC >> 9 & 7] &= ~255 | (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS)))];  //ccr_tst_byte。pcbs。イミディエイトを分離。1拡張してからAND
  }  //irpAndToRegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //AND.W <ea>,Dq                                   |-|012346|-|-UUUU|-**00|D M+-WXZPI|1100_qqq_001_mmm_rrr
  public static void irpAndToRegWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] &= ~65535 | (ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS));  //pcws。イミディエイトを分離。1拡張してからAND
    XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
  }  //irpAndToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //AND.L <ea>,Dq                                   |-|012346|-|-UUUU|-**00|D M+-WXZPI|1100_qqq_010_mmm_rrr
  public static void irpAndToRegLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] &= ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //pcls。イミディエイトを分離
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpAndToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MULU.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1100_qqq_011_mmm_rrr
  public static void irpMuluWord () throws M68kException {
    XEiJ.mpuCycleCount += 2;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int y = ea < XEiJ.EA_AR ? (char) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordZeroData (efaAnyWord (ea), XEiJ.regSRS);  //pcwz。イミディエイトを分離
    int z;
    XEiJ.regRn[qqq] = z = (char) XEiJ.regRn[qqq] * y;  //積の下位32ビット。オーバーフローは無視
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMuluWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ABCD.B Dr,Dq                                    |-|012346|-|UUUUU|*U*U*|          |1100_qqq_100_000_rrr
  //ABCD.B -(Ar),-(Aq)                              |-|012346|-|UUUUU|*U*U*|          |1100_qqq_100_001_rrr
  //AND.B Dq,<ea>                                   |-|012346|-|-UUUU|-**00|  M+-WXZ  |1100_qqq_100_mmm_rrr
  public static void irpAndToMemByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea >= XEiJ.EA_MM) {  //AND.B Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltByte (ea);
      int z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & mmuModifyByteSignData (a, XEiJ.regSRS);
      mmuWriteByteData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.MPU_TSTB_TABLE[255 & z];  //ccr_tst_byte
    } else if (ea < XEiJ.EA_AR) {  //ABCD.B Dr,Dq
      int qqq = XEiJ.regOC >> 9 & 7;
      XEiJ.mpuCycleCount++;
      XEiJ.regRn[qqq] = ~0xff & XEiJ.regRn[qqq] | irpAbcd (XEiJ.regRn[qqq], XEiJ.regRn[ea]);
    } else {  //ABCD.B -(Ar),-(Aq)
      XEiJ.mpuCycleCount += 2;
      M68kException.m6eIncremented -= 1L << (ea << 3);
      int a = --XEiJ.regRn[ea];  //このr[ea]はアドレスレジスタ
      int y = mmuReadByteZeroData (a, XEiJ.regSRS);
      int aqq = (XEiJ.regOC >> 9) - (96 - 8);
      M68kException.m6eIncremented -= 1L << (aqq << 3);
      a = --XEiJ.regRn[aqq];
      mmuWriteByteData (a, irpAbcd (mmuModifyByteZeroData (a, XEiJ.regSRS), y), XEiJ.regSRS);
    }
  }  //irpAndToMemByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EXG.L Dq,Dr                                     |-|012346|-|-----|-----|          |1100_qqq_101_000_rrr
  //EXG.L Aq,Ar                                     |-|012346|-|-----|-----|          |1100_qqq_101_001_rrr
  //AND.W Dq,<ea>                                   |-|012346|-|-UUUU|-**00|  M+-WXZ  |1100_qqq_101_mmm_rrr
  public static void irpAndToMemWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_MM) {  //EXG
      XEiJ.mpuCycleCount++;
      if (ea < XEiJ.EA_AR) {  //EXG.L Dq,Dr
        int qqq = XEiJ.regOC >> 9 & 7;
        int t = XEiJ.regRn[qqq];
        XEiJ.regRn[qqq] = XEiJ.regRn[ea];
        XEiJ.regRn[ea] = t;
      } else {  //EXG.L Aq,Ar
        int aqq = (XEiJ.regOC >> 9) - (96 - 8);
        int t = XEiJ.regRn[aqq];
        XEiJ.regRn[aqq] = XEiJ.regRn[ea];  //このr[ea]アドレスレジスタ
        XEiJ.regRn[ea] = t;  //このr[ea]はアドレスレジスタ
      }
    } else {  //AND.W Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltWord (ea);
      int z = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & mmuModifyWordSignData (a, XEiJ.regSRS);
      mmuWriteWordData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (char) z - 1 >> 31 & XEiJ.REG_CCR_Z | ((short) z < 0 ? XEiJ.REG_CCR_N : 0);  //ccr_tst_word
    }
  }  //irpAndToMemWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //EXG.L Dq,Ar                                     |-|012346|-|-----|-----|          |1100_qqq_110_001_rrr
  //AND.L Dq,<ea>                                   |-|012346|-|-UUUU|-**00|  M+-WXZ  |1100_qqq_110_mmm_rrr
  public static void irpAndToMemLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    if (ea >> 3 == XEiJ.MMM_AR) {  //EXG.L Dq,Ar
      XEiJ.mpuCycleCount++;
      int t = XEiJ.regRn[qqq];
      XEiJ.regRn[qqq] = XEiJ.regRn[ea];  //このr[ea]はアドレスレジスタ
      XEiJ.regRn[ea] = t;  //このr[ea]はアドレスレジスタ
    } else {  //AND.L Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      int z;
      mmuWriteLongData (a, z = mmuModifyLongData (a, XEiJ.regSRS) & XEiJ.regRn[qqq], XEiJ.regSRS);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
    }
  }  //irpAndToMemLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MULS.W <ea>,Dq                                  |-|012346|-|-UUUU|-***0|D M+-WXZPI|1100_qqq_111_mmm_rrr
  public static void irpMulsWord () throws M68kException {
    XEiJ.mpuCycleCount += 2;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int y = ea < XEiJ.EA_AR ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //pcws。イミディエイトを分離
    int z;
    XEiJ.regRn[qqq] = z = (short) XEiJ.regRn[qqq] * y;  //積の下位32ビット。オーバーフローは無視
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpMulsWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADD.B <ea>,Dq                                   |-|012346|-|UUUUU|*****|D M+-WXZPI|1101_qqq_000_mmm_rrr
  public static void irpAddToRegByte () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int x, y, z;
    y = ea < XEiJ.EA_AR ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadByteSignExword ((XEiJ.regPC += 2) - 1, XEiJ.regSRS) : mmuReadByteSignData (efaAnyByte (ea), XEiJ.regSRS);  //pcbs。イミディエイトを分離
    x = XEiJ.regRn[qqq];
    z = x + y;
    XEiJ.regRn[qqq] = ~255 & x | 255 & z;
    XEiJ.regCCR = (XEiJ.MPU_TSTB_TABLE[255 & z] |
           ((x ^ z) & (y ^ z)) >> 6 & XEiJ.REG_CCR_V |
           (byte) ((x | y) ^ (x ^ y) & z) >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add_byte
  }  //irpAddToRegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADD.W <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1101_qqq_001_mmm_rrr
  public static void irpAddToRegWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int x, y, z;
    y = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離
    x = XEiJ.regRn[qqq];
    z = x + y;
    XEiJ.regRn[qqq] = ~65535 & x | (char) z;
    XEiJ.regCCR = (z >> 12 & XEiJ.REG_CCR_N | (char) z - 1 >> 14 & XEiJ.REG_CCR_Z |
           ((x ^ z) & (y ^ z)) >> 14 & XEiJ.REG_CCR_V |
           (short) ((x | y) ^ (x ^ y) & z) >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add_word
  }  //irpAddToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADD.L <ea>,Dq                                   |-|012346|-|UUUUU|*****|DAM+-WXZPI|1101_qqq_010_mmm_rrr
  public static void irpAddToRegLong () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int qqq = XEiJ.regOC >> 9 & 7;
    int x, y, z;
    y = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcls。イミディエイトを分離
    x = XEiJ.regRn[qqq];
    z = x + y;
    XEiJ.regRn[qqq] = z;
    XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
           ((x ^ z) & (y ^ z)) >> 30 & XEiJ.REG_CCR_V |
           ((x | y) ^ (x ^ y) & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add
  }  //irpAddToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDA.W <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_011_mmm_rrr
  //ADD.W <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_011_mmm_rrr [ADDA.W <ea>,Aq]
  //
  //ADDA.W <ea>,Aq
  //  ソースを符号拡張してロングで加算する
  public static void irpAddaWord () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int z = ea < XEiJ.EA_MM ? (short) XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) : mmuReadWordSignData (efaAnyWord (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcws。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    XEiJ.regRn[XEiJ.regOC >> 9 & 15] += z;  //r[op >> 9 & 15] += ea < XEiJ.EA_MM ? (short) r[ea] : rws (efaAnyWord (ea));は不可
    //ccrは変化しない
  }  //irpAddaWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDX.B Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1101_qqq_100_000_rrr
  //ADDX.B -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1101_qqq_100_001_rrr
  //ADD.B Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1101_qqq_100_mmm_rrr
  public static void irpAddToMemByte () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int a, x, y, z;
    if (ea < XEiJ.EA_MM) {
      if (ea < XEiJ.EA_AR) {  //ADDX.B Dr,Dq
        int qqq = XEiJ.regOC >> 9 & 7;
        XEiJ.mpuCycleCount++;
        y = XEiJ.regRn[ea];
        x = XEiJ.regRn[qqq];
        z = x + y + (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        XEiJ.regRn[qqq] = ~255 & x | 255 & z;
      } else {  //ADDX.B -(Ar),-(Aq)
        XEiJ.mpuCycleCount += 2;
        M68kException.m6eIncremented -= 1L << (ea << 3);
        a = --XEiJ.regRn[ea];  //このr[ea]はアドレスレジスタ
        y = mmuReadByteSignData (a, XEiJ.regSRS);
        int aqq = XEiJ.regOC >> 9 & 15;  //1qqq=aqq
        M68kException.m6eIncremented -= 1L << (aqq << 3);
        a = --XEiJ.regRn[aqq];
        x = mmuModifyByteSignData (a, XEiJ.regSRS);
        z = x + y + (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        mmuWriteByteData (a, z, XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 4 & XEiJ.REG_CCR_N | (255 & z) - 1 >> 6 & XEiJ.regCCR & XEiJ.REG_CCR_Z |  //ADDXはZをクリアすることはあるがセットすることはない
             ((x ^ z) & (y ^ z)) >> 6 & XEiJ.REG_CCR_V |
             (byte) ((x | y) ^ (x ^ y) & z) >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_addx_byte
    } else {  //ADD.B Dq,<ea>
      XEiJ.mpuCycleCount++;
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7];
      a = efaMltByte (ea);
      x = mmuModifyByteSignData (a, XEiJ.regSRS);
      z = x + y;
      mmuWriteByteData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = (XEiJ.MPU_TSTB_TABLE[255 & z] |
             ((x ^ z) & (y ^ z)) >> 6 & XEiJ.REG_CCR_V |
             (byte) ((x | y) ^ (x ^ y) & z) >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add_byte
    }
  }  //irpAddToMemByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDX.W Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1101_qqq_101_000_rrr
  //ADDX.W -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1101_qqq_101_001_rrr
  //ADD.W Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1101_qqq_101_mmm_rrr
  public static void irpAddToMemWord () throws M68kException {
    int ea = XEiJ.regOC & 63;
    int a, x, y, z;
    if (ea < XEiJ.EA_MM) {
      if (ea < XEiJ.EA_AR) {  //ADDX.W Dr,Dq
        int qqq = XEiJ.regOC >> 9 & 7;
        XEiJ.mpuCycleCount++;
        y = XEiJ.regRn[ea];
        x = XEiJ.regRn[qqq];
        z = x + y + (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        XEiJ.regRn[qqq] = ~65535 & x | (char) z;
      } else {  //ADDX.W -(Ar),-(Aq)
        XEiJ.mpuCycleCount += 2;
        M68kException.m6eIncremented -= 2L << (ea << 3);
        a = XEiJ.regRn[ea] -= 2;  //このr[ea]はアドレスレジスタ
        y = mmuReadWordSignData (a, XEiJ.regSRS);
        int aqq = XEiJ.regOC >> 9 & 15;
        M68kException.m6eIncremented -= 2L << (aqq << 3);
        a = XEiJ.regRn[aqq] -= 2;
        x = mmuModifyWordSignData (a, XEiJ.regSRS);
        z = x + y + (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
        mmuWriteWordData (a, z, XEiJ.regSRS);
      }
      XEiJ.regCCR = (z >> 12 & XEiJ.REG_CCR_N | (char) z - 1 >> 14 & XEiJ.regCCR & XEiJ.REG_CCR_Z |  //ADDXはZをクリアすることはあるがセットすることはない
             ((x ^ z) & (y ^ z)) >> 14 & XEiJ.REG_CCR_V |
             (short) ((x | y) ^ (x ^ y) & z) >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_addx_word
    } else {  //ADD.W Dq,<ea>
      XEiJ.mpuCycleCount++;
      a = efaMltWord (ea);
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7];
      x = mmuModifyWordSignData (a, XEiJ.regSRS);
      z = x + y;
      mmuWriteWordData (a, z, XEiJ.regSRS);
      XEiJ.regCCR = (z >> 12 & XEiJ.REG_CCR_N | (char) z - 1 >> 14 & XEiJ.REG_CCR_Z |
             ((x ^ z) & (y ^ z)) >> 14 & XEiJ.REG_CCR_V |
             (short) ((x | y) ^ (x ^ y) & z) >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add_word
    }
  }  //irpAddToMemWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDX.L Dr,Dq                                    |-|012346|-|*UUUU|*****|          |1101_qqq_110_000_rrr
  //ADDX.L -(Ar),-(Aq)                              |-|012346|-|*UUUU|*****|          |1101_qqq_110_001_rrr
  //ADD.L Dq,<ea>                                   |-|012346|-|UUUUU|*****|  M+-WXZ  |1101_qqq_110_mmm_rrr
  public static void irpAddToMemLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_MM) {
      int x;
      int y;
      int z;
      if (ea < XEiJ.EA_AR) {  //ADDX.L Dr,Dq
        int qqq = XEiJ.regOC >> 9 & 7;
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[qqq] = z = (x = XEiJ.regRn[qqq]) + (y = XEiJ.regRn[ea]) + (XEiJ.regCCR >> 4);  //Xの左側はすべて0なのでCCR_X&を省略
      } else {  //ADDX.L -(Ar),-(Aq)
        XEiJ.mpuCycleCount += 2;
        M68kException.m6eIncremented -= 4L << (ea << 3);
        int a = XEiJ.regRn[ea] -= 4;  //このr[ea]はアドレスレジスタ
        y = mmuReadLongData (a, XEiJ.regSRS);
        int aqq = XEiJ.regOC >> 9 & 15;
        M68kException.m6eIncremented -= 4L << (aqq << 3);
        a = XEiJ.regRn[aqq] -= 4;
        mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) + y + (XEiJ.regCCR >> 4), XEiJ.regSRS);  //Xの左側はすべて0なのでCCR_X&を省略
      }
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_Z : 0) |
             ((x ^ z) & (y ^ z)) >>> 31 << 1 |
             ((x | y) ^ (x ^ y) & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_addx
    } else {  //ADD.L Dq,<ea>
      XEiJ.mpuCycleCount++;
      int a = efaMltLong (ea);
      int x;
      int y;
      int z;
      mmuWriteLongData (a, z = (x = mmuModifyLongData (a, XEiJ.regSRS)) + (y = XEiJ.regRn[XEiJ.regOC >> 9 & 7]), XEiJ.regSRS);
      XEiJ.regCCR = (z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) |
             ((x ^ z) & (y ^ z)) >>> 31 << 1 |
             ((x | y) ^ (x ^ y) & z) >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //ccr_add
    }
  }  //irpAddToMemLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ADDA.L <ea>,Aq                                  |-|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_111_mmm_rrr
  //ADD.L <ea>,Aq                                   |A|012346|-|-----|-----|DAM+-WXZPI|1101_qqq_111_mmm_rrr [ADDA.L <ea>,Aq]
  public static void irpAddaLong () throws M68kException {
    int ea = XEiJ.regOC & 63;
    XEiJ.mpuCycleCount++;
    int z = ea < XEiJ.EA_MM ? XEiJ.regRn[ea] : ea == XEiJ.EA_IM ? mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) : mmuReadLongData (efaAnyLong (ea), XEiJ.regSRS);  //このr[ea]はデータレジスタまたはアドレスレジスタ。pcls。イミディエイトを分離。ここでAqが変化する可能性があることに注意
    XEiJ.regRn[XEiJ.regOC >> 9 & 15] += z;  //r[op >> 9 & 15] += ea < XEiJ.EA_MM ? r[ea] : rls (efaAnyLong (ea));は不可
    //ccrは変化しない
  }  //irpAddaLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASR.B #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_000_000_rrr
  //LSR.B #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_000_001_rrr
  //ROXR.B #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_000_010_rrr
  //ROR.B #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_000_011_rrr
  //ASR.B Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_000_100_rrr
  //LSR.B Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_000_101_rrr
  //ROXR.B Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_000_110_rrr
  //ROR.B Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_000_111_rrr
  //ASR.B Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_000_000_rrr [ASR.B #1,Dr]
  //LSR.B Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_000_001_rrr [LSR.B #1,Dr]
  //ROXR.B Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_000_010_rrr [ROXR.B #1,Dr]
  //ROR.B Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_000_011_rrr [ROR.B #1,Dr]
  //
  //ASR.B #<data>,Dr
  //ASR.B Dq,Dr
  //  算術右シフトバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*00 Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................ｱｱｲｳｴｵｶｷ ｸｱ*0ｸ Z=ｱｲｳｴｵｶｷ==0
  //     2 ........................ｱｱｱｲｳｴｵｶ ｷｱ*0ｷ Z=ｱｲｳｴｵｶ==0
  //     3 ........................ｱｱｱｱｲｳｴｵ ｶｱ*0ｶ Z=ｱｲｳｴｵ==0
  //     4 ........................ｱｱｱｱｱｲｳｴ ｵｱ*0ｵ Z=ｱｲｳｴ==0
  //     5 ........................ｱｱｱｱｱｱｲｳ ｴｱ*0ｴ Z=ｱｲｳ==0
  //     6 ........................ｱｱｱｱｱｱｱｲ ｳｱ*0ｳ Z=ｱｲ==0
  //     7 ........................ｱｱｱｱｱｱｱｱ ｲｱ*0ｲ Z=ｱ==0
  //     8 ........................ｱｱｱｱｱｱｱｱ ｱｱ*0ｱ Z=ｱ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //LSR.B #<data>,Dr
  //LSR.B Dq,Dr
  //  論理右シフトバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*00 Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................0ｱｲｳｴｵｶｷ ｸ0*0ｸ Z=ｱｲｳｴｵｶｷ==0
  //     2 ........................00ｱｲｳｴｵｶ ｷ0*0ｷ Z=ｱｲｳｴｵｶ==0
  //     3 ........................000ｱｲｳｴｵ ｶ0*0ｶ Z=ｱｲｳｴｵ==0
  //     4 ........................0000ｱｲｳｴ ｵ0*0ｵ Z=ｱｲｳｴ==0
  //     5 ........................00000ｱｲｳ ｴ0*0ｴ Z=ｱｲｳ==0
  //     6 ........................000000ｱｲ ｳ0*0ｳ Z=ｱｲ==0
  //     7 ........................0000000ｱ ｲ0*0ｲ Z=ｱ==0
  //     8 ........................00000000 ｱ010ｱ
  //     9 ........................00000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //ROR.B #<data>,Dr
  //ROR.B Dq,Dr
  //  右ローテートバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*00 Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................ｸｱｲｳｴｵｶｷ Xｸ*0ｸ Z=ｱｲｳｴｵｶｷｸ==0
  //     :
  //     7 ........................ｲｳｴｵｶｷｸｱ Xｲ*0ｲ Z=ｱｲｳｴｵｶｷｸ==0
  //     8 ........................ｱｲｳｴｵｶｷｸ Xｱ*0ｱ Z=ｱｲｳｴｵｶｷｸ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最上位ビット
  //
  //ROXR.B #<data>,Dr
  //ROXR.B Dq,Dr
  //  拡張右ローテートバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*0X Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................Xｱｲｳｴｵｶｷ ｸX*0ｸ Z=ｱｲｳｴｵｶｷX==0
  //     2 ........................ｸXｱｲｳｴｵｶ ｷｸ*0ｷ Z=ｱｲｳｴｵｶｸX==0
  //     3 ........................ｷｸXｱｲｳｴｵ ｶｷ*0ｶ Z=ｱｲｳｴｵｷｸX==0
  //     4 ........................ｶｷｸXｱｲｳｴ ｵｶ*0ｵ Z=ｱｲｳｴｶｷｸX==0
  //     5 ........................ｵｶｷｸXｱｲｳ ｴｵ*0ｴ Z=ｱｲｳｵｶｷｸX==0
  //     6 ........................ｴｵｶｷｸXｱｲ ｳｴ*0ｳ Z=ｱｲｴｵｶｷｸX==0
  //     7 ........................ｳｴｵｶｷｸXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸX==0
  //     8 ........................ｲｳｴｵｶｷｸX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸX==0
  //     9 ........................ｱｲｳｴｵｶｷｸ Xｱ*0X Z=ｱｲｳｴｵｶｷｸ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpXxrToRegByte () throws M68kException {
    int rrr;
    int x = XEiJ.regRn[rrr = XEiJ.regOC & 7];
    int y;
    int z;
    int t;
    XEiJ.mpuCycleCount++;
    switch (XEiJ.regOC >> 3 & 0b111_000 >> 3) {
    case 0b000_000 >> 3:  //ASR.B #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (t = (byte) x >> y) >> 1);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b001_000 >> 3:  //LSR.B #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xff & x | (z = (t = (0xff & x) >>> y) >>> 1);
      XEiJ.regCCR = (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b010_000 >> 3:  //ROXR.B #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      z = (XEiJ.regCCR & XEiJ.REG_CCR_X) << 7 - 4 | (0xff & x) >>> 1;
      if (y == 1 - 1) {  //y=data-1=1-1
        t = x;
      } else {  //y=data-1=2-1～8-1
        z = x << 9 - 1 - y | (t = z >>> y - (2 - 1)) >>> 1;
      }
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) z);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b011_000 >> 3:  //ROR.B #<data>,Dr
      y = XEiJ.regOC >> 9 & 7;  //y=data&7
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) (x << 8 - y | (0xff & x) >>> y));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | z >>> 7 & 1;  //Xは変化しない。Cは結果の最上位ビット
      break;
    case 0b100_000 >> 3:  //ASR.B Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = (byte) x;
        t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (t = (byte) x >> (y <= 8 ? y - 1 : 7)) >> 1);
        t = -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b101_000 >> 3:  //LSR.B Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = (byte) x;
        XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (z < 0 ? XEiJ.REG_CCR_N : z == 0 ? XEiJ.REG_CCR_Z : 0);  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = ~0xff & x | (z = (t = y <= 8 ? (0xff & x) >>> y - 1 : 0) >>> 1);
        XEiJ.regCCR = (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      break;
    case 0b110_000 >> 3:  //ROXR.B Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      //y %= 9;
      y = (y & 7) - (y >> 3);  //y=data=-7～7
      y += y >> 3 & 9;  //y=data=0～8
      if (y == 0) {  //y=data=0
        z = (byte) x;
        t = -(XEiJ.regCCR >> 4 & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //Xは変化しない。CはXのコピー
      } else {  //y=data=1～8
        z = (XEiJ.regCCR & XEiJ.REG_CCR_X) << 7 - 4 | (0xff & x) >>> 1;
        if (y == 1) {  //y=data=1
          t = x;  //Cは最後に押し出されたビット
        } else {  //y=data=2～8
          z = x << 9 - y | (t = z >>> y - 2) >>> 1;
        }
        XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) z);
        t = -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b111_000 >> 3:  //ROR.B Dq,Dr
    default:
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {
        z = (byte) x;
        t = 0;  //Cはクリア
      } else {
        y &= 7;  //y=data=0～7
        XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) (x << 8 - y | (0xff & x) >>> y));
        t = z >>> 7 & 1;  //Cは結果の最上位ビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | t;  //Xは変化しない
    }
  }  //irpXxrToRegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASR.W #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_001_000_rrr
  //LSR.W #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_001_001_rrr
  //ROXR.W #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_001_010_rrr
  //ROR.W #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_001_011_rrr
  //ASR.W Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_001_100_rrr
  //LSR.W Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_001_101_rrr
  //ROXR.W Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_001_110_rrr
  //ROR.W Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_001_111_rrr
  //ASR.W Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_001_000_rrr [ASR.W #1,Dr]
  //LSR.W Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_001_001_rrr [LSR.W #1,Dr]
  //ROXR.W Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_001_010_rrr [ROXR.W #1,Dr]
  //ROR.W Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_001_011_rrr [ROR.W #1,Dr]
  //
  //ASR.W #<data>,Dr
  //ASR.W Dq,Dr
  //ASR.W <ea>
  //  算術右シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｱｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀｱ*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ==0
  //     :
  //    15 ................ｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱ ｲｱ*0ｲ Z=ｱ==0
  //    16 ................ｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱ ｱｱ*0ｱ Z=ｱ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //LSR.W #<data>,Dr
  //LSR.W Dq,Dr
  //LSR.W <ea>
  //  論理右シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................0ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀ0*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ==0
  //     :
  //    15 ................000000000000000ｱ ｲ0*0ｲ Z=ｱ==0
  //    16 ................0000000000000000 ｱ010ｱ
  //    17 ................0000000000000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //ROR.W #<data>,Dr
  //ROR.W Dq,Dr
  //ROR.W <ea>
  //  右ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ﾀｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ Xﾀ*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     :
  //    15 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀｱ Xｲ*0ｲ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //    16 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0ｱ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最上位ビット
  //
  //ROXR.W #<data>,Dr
  //ROXR.W Dq,Dr
  //ROXR.W <ea>
  //  拡張右ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................Xｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀX*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿX==0
  //     2 ................ﾀXｱｲｳｴｵｶｷｸｹｺｻｼｽｾ ｿﾀ*0ｿ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾﾀX==0
  //     :
  //    15 ................ｳｴｵｶｷｸｹｺｻｼｽｾｿﾀXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //    16 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //    17 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpXxrToRegWord () throws M68kException {
    int rrr;
    int x = XEiJ.regRn[rrr = XEiJ.regOC & 7];
    int y;
    int z;
    int t;
    XEiJ.mpuCycleCount++;
    switch (XEiJ.regOC >> 3 & 0b111_000 >> 3) {
    case 0b000_000 >> 3:  //ASR.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (t = (short) x >> y) >> 1);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b001_000 >> 3:  //LSR.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xffff & x | (z = (t = (char) x >>> y) >>> 1);
      XEiJ.regCCR = (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b010_000 >> 3:  //ROXR.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      z = (XEiJ.regCCR & XEiJ.REG_CCR_X) << 15 - 4 | (char) x >>> 1;
      if (y == 1 - 1) {  //y=data-1=1-1
        t = x;
      } else {  //y=data-1=2-1～8-1
        z = x << 17 - 1 - y | (t = z >>> y - (2 - 1)) >>> 1;
      }
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) z);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b011_000 >> 3:  //ROR.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) (x << 16 - 1 - y | (char) x >>> y + 1));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | z >>> 15 & 1;  //Xは変化しない。Cは結果の最上位ビット
      break;
    case 0b100_000 >> 3:  //ASR.W Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = (short) x;
        t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (t = (short) x >> (y <= 16 ? y - 1 : 15)) >> 1);
        t = -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b101_000 >> 3:  //LSR.W Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = (short) x;
        XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (z < 0 ? XEiJ.REG_CCR_N : z == 0 ? XEiJ.REG_CCR_Z : 0);  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = ~0xffff & x | (z = (t = y <= 16 ? (char) x >>> y - 1 : 0) >>> 1);
        XEiJ.regCCR = (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      break;
    case 0b110_000 >> 3:  //ROXR.W Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      //y %= 17;
      y = (y & 15) - (y >> 4);  //y=data=-3～15
      y += y >> 4 & 17;  //y=data=0～16
      if (y == 0) {  //y=data=0
        z = (short) x;
        t = -(XEiJ.regCCR >> 4 & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //Xは変化しない。CはXのコピー
      } else {  //y=data=1～16
        z = (XEiJ.regCCR & XEiJ.REG_CCR_X) << 15 - 4 | (char) x >>> 1;
        if (y == 1) {  //y=data=1
          t = x;  //Cは最後に押し出されたビット
        } else {  //y=data=2～16
          z = x << 17 - y | (t = z >>> y - 2) >>> 1;
        }
        XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) z);
        t = -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b111_000 >> 3:  //ROR.W Dq,Dr
    default:
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {
        z = (short) x;
        t = 0;  //Cはクリア
      } else {
        y &= 15;  //y=data=0～15
        XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) (x << 16 - y | (char) x >>> y));
        t = z >>> 15 & 1;  //Cは結果の最上位ビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | t;  //Xは変化しない
    }
  }  //irpXxrToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASR.L #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_010_000_rrr
  //LSR.L #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_010_001_rrr
  //ROXR.L #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_010_010_rrr
  //ROR.L #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_010_011_rrr
  //ASR.L Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_010_100_rrr
  //LSR.L Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_010_101_rrr
  //ROXR.L Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_010_110_rrr
  //ROR.L Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_010_111_rrr
  //ASR.L Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_010_000_rrr [ASR.L #1,Dr]
  //LSR.L Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_010_001_rrr [LSR.L #1,Dr]
  //ROXR.L Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_010_010_rrr [ROXR.L #1,Dr]
  //ROR.L Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_010_011_rrr [ROR.L #1,Dr]
  //
  //ASR.L #<data>,Dr
  //ASR.L Dq,Dr
  //  算術右シフトロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 ｱｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ ﾐｱ*0ﾐ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ==0
  //     :
  //    31 ｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱ ｲｱ*0ｲ Z=ｱ==0
  //    32 ｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱ ｱｱ*0ｱ Z=ｱ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //LSR.L #<data>,Dr
  //LSR.L Dq,Dr
  //  論理右シフトロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 0ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ ﾐ0*0ﾐ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ==0
  //     :
  //    31 0000000000000000000000000000000ｱ ｲ0*0ｲ Z=ｱ==0
  //    32 00000000000000000000000000000000 ｱ010ｱ
  //    33 00000000000000000000000000000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //ROR.L #<data>,Dr
  //ROR.L Dq,Dr
  //  右ローテートロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 ﾐｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ Xﾐ*0ﾐ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     :
  //    31 ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐｱ Xｲ*0ｲ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //    32 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*0ｱ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最上位ビット
  //
  //ROXR.L #<data>,Dr
  //ROXR.L Dq,Dr
  //  拡張右ローテートロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 Xｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ ﾐX*0ﾐ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏX==0
  //     2 ﾐXｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎ ﾏﾐ*0ﾏ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾐX==0
  //     :
  //    31 ｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐX==0
  //    32 ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐX==0
  //    33 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpXxrToRegLong () throws M68kException {
    int rrr;
    int x = XEiJ.regRn[rrr = XEiJ.regOC & 7];
    int y;
    int z;
    int t;
    XEiJ.mpuCycleCount++;
    switch (XEiJ.regOC >> 3 & 0b111_000 >> 3) {
    case 0b000_000 >> 3:  //ASR.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = z = (t = x >> y) >> 1;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b001_000 >> 3:  //LSR.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = z = (t = x >>> y) >>> 1;
      XEiJ.regCCR = (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b010_000 >> 3:  //ROXR.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      z = (XEiJ.regCCR & XEiJ.REG_CCR_X) << 31 - 4 | x >>> 1;
      if (y == 1 - 1) {  //y=data-1=1-1
        t = x;
      } else {  //y=data-1=2-1～8-1
        z = x << -y | (t = z >>> y - (2 - 1)) >>> 1;  //Javaのシフト演算子は5ビットでマスクされるので33-1-yを-yに省略
      }
      XEiJ.regRn[rrr] = z;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b011_000 >> 3:  //ROR.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = z = x << ~y | x >>> y + 1;  //Javaのシフト演算子は5ビットでマスクされるので32-1-yを~yに省略
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | z >>> 31;  //Xは変化しない。Cは結果の最上位ビット
      break;
    case 0b100_000 >> 3:  //ASR.L Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = x;
        t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = z = (t = x >> (y <= 32 ? y - 1 : 31)) >> 1;
        t = -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b101_000 >> 3:  //LSR.L Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = x;
        XEiJ.regCCR = XEiJ.regCCR & XEiJ.REG_CCR_X | (z < 0 ? XEiJ.REG_CCR_N : z == 0 ? XEiJ.REG_CCR_Z : 0);  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = z = (t = y <= 32 ? x >>> y - 1 : 0) >>> 1;
        XEiJ.regCCR = (z == 0 ? XEiJ.REG_CCR_Z : 0) | -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      break;
    case 0b110_000 >> 3:  //ROXR.L Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      //y %= 33;
      y -= 32 - y >> 6 & 33;  //y=data=0～32
      if (y == 0) {  //y=data=0
        z = x;
        t = -(XEiJ.regCCR >> 4 & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //Xは変化しない。CはXのコピー
      } else {  //y=data=1～32
        z = (XEiJ.regCCR & XEiJ.REG_CCR_X) << 31 - 4 | x >>> 1;
        if (y == 1) {  //y=data=1
          t = x;  //Cは最後に押し出されたビット
        } else {  //y=data=2～32
          z = x << 33 - y | (t = z >>> y - 2) >>> 1;
        }
        XEiJ.regRn[rrr] = z;
        t = -(t & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b111_000 >> 3:  //ROR.L Dq,Dr
    default:
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {
        z = x;
        t = 0;  //Cはクリア
      } else {
        y &= 31;  //y=data=0～31
        XEiJ.regRn[rrr] = z = x << -y | x >>> y;  //Javaのシフト演算子は5ビットでマスクされるので32-yを-yに省略。y=32のときx|xになるが問題ない
        t = z >>> 31;  //Cは結果の最上位ビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | t;  //Xは変化しない
    }
  }  //irpXxrToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASR.W <ea>                                      |-|012346|-|UUUUU|***0*|  M+-WXZ  |1110_000_011_mmm_rrr
  //
  //ASR.W #<data>,Dr
  //ASR.W Dq,Dr
  //ASR.W <ea>
  //  算術右シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｱｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀｱ*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ==0
  //     :
  //    15 ................ｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱ ｲｱ*0ｲ Z=ｱ==0
  //    16 ................ｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱｱ ｱｱ*0ｱ Z=ｱ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  public static void irpAsrToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordSignData (a, XEiJ.regSRS);
    int z = x >> 1;
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = ((z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   -(x & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //XとCは最後に押し出されたビット
  }  //irpAsrToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASL.B #<data>,Dr                                |-|012346|-|UUUUU|*****|          |1110_qqq_100_000_rrr
  //LSL.B #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_100_001_rrr
  //ROXL.B #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_100_010_rrr
  //ROL.B #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_100_011_rrr
  //ASL.B Dq,Dr                                     |-|012346|-|UUUUU|*****|          |1110_qqq_100_100_rrr
  //LSL.B Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_100_101_rrr
  //ROXL.B Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_100_110_rrr
  //ROL.B Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_100_111_rrr
  //ASL.B Dr                                        |A|012346|-|UUUUU|*****|          |1110_001_100_000_rrr [ASL.B #1,Dr]
  //LSL.B Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_100_001_rrr [LSL.B #1,Dr]
  //ROXL.B Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_100_010_rrr [ROXL.B #1,Dr]
  //ROL.B Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_100_011_rrr [ROL.B #1,Dr]
  //
  //ASL.B #<data>,Dr
  //ASL.B Dq,Dr
  //  算術左シフトバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*00 Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................ｲｳｴｵｶｷｸ0 ｱｲ**ｱ Z=ｲｳｴｵｶｷｸ==0,V=ｱｲ!=0/-1
  //     :
  //     7 ........................ｸ0000000 ｷｸ**ｷ Z=ｸ==0,V=ｱｲｳｴｵｶｷｸ!=0/-1
  //     8 ........................00000000 ｸ01*ｸ V=ｱｲｳｴｵｶｷｸ!=0
  //     9 ........................00000000 001*0 V=ｱｲｳｴｵｶｷｸ!=0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  ASRで元に戻せないときセット。他はクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //LSL.B #<data>,Dr
  //LSL.B Dq,Dr
  //  論理左シフトバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*00 Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................ｲｳｴｵｶｷｸ0 ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸ==0
  //     :
  //     7 ........................ｸ0000000 ｷｸ*0ｷ Z=ｸ==0
  //     8 ........................00000000 ｸ010ｸ
  //     9 ........................00000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //ROL.B #<data>,Dr
  //ROL.B Dq,Dr
  //  左ローテートバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*00 Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................ｲｳｴｵｶｷｸｱ Xｲ*0ｱ Z=ｱｲｳｴｵｶｷｸ==0
  //     :
  //     7 ........................ｸｱｲｳｴｵｶｷ Xｸ*0ｷ Z=ｱｲｳｴｵｶｷｸ==0
  //     8 ........................ｱｲｳｴｵｶｷｸ Xｱ*0ｸ Z=ｱｲｳｴｵｶｷｸ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最下位ビット
  //
  //ROXL.B #<data>,Dr
  //ROXL.B Dq,Dr
  //  拡張左ローテートバイト
  //       ........................ｱｲｳｴｵｶｷｸ XNZVC
  //     0 ........................ｱｲｳｴｵｶｷｸ Xｱ*0X Z=ｱｲｳｴｵｶｷｸ==0
  //     1 ........................ｲｳｴｵｶｷｸX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸX==0
  //     2 ........................ｳｴｵｶｷｸXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸX==0
  //     :
  //     7 ........................ｸXｱｲｳｴｵｶ ｷｸ*0ｷ Z=ｱｲｳｴｵｶｸX==0
  //     8 ........................Xｱｲｳｴｵｶｷ ｸX*0ｸ Z=ｱｲｳｴｵｶｷX==0
  //     9 ........................ｱｲｳｴｵｶｷｸ Xｱ*0X Z=ｱｲｳｴｵｶｷｸ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpXxlToRegByte () throws M68kException {
    int rrr;
    int x = XEiJ.regRn[rrr = XEiJ.regOC & 7];
    int y;
    int z;
    int t;
    XEiJ.mpuCycleCount++;
    switch (XEiJ.regOC >> 3 & 0b111_000 >> 3) {
    case 0b000_000 >> 3:  //ASL.B #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) ((t = x << y) << 1));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (z >> y + 1 != (byte) x ? XEiJ.REG_CCR_V : 0) | (byte) t >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //VはASRで元に戻せないときセット。XとCは最後に押し出されたビット
      break;
    case 0b001_000 >> 3:  //LSL.B #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) ((t = x << y) << 1));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (byte) t >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b010_000 >> 3:  //ROXL.B #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      z = x << 1 | XEiJ.regCCR >> 4 & 1;
      if (y == 1 - 1) {  //y=data-1=1-1
        t = x;
      } else {  //y=data-1=2-1～8-1
        z = (t = z << y - (2 - 1)) << 1 | (0xff & x) >>> 9 - 1 - y;
      }
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) z);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (byte) t >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b011_000 >> 3:  //ROL.B #<data>,Dr
      y = XEiJ.regOC >> 9 & 7;  //y=data&7
      XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) (x << y | (0xff & x) >>> 8 - y));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | z & 1;  //Xは変化しない。Cは結果の最下位ビット
      break;
    case 0b100_000 >> 3:  //ASL.B Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y <= 7) {  //y=data=0～7
        if (y == 0) {  //y=data=0
          z = (byte) x;
          t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。VとCはクリア
        } else {  //y=data=1～7
          XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) ((t = x << y - 1) << 1));
          t = (z >> y != (byte) x ? XEiJ.REG_CCR_V : 0) | (byte) t >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //VはASRで元に戻せないときセット。XとCは最後に押し出されたビット
        }
        XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      } else {  //y=data=8～63
        XEiJ.regRn[rrr] = ~0xff & x;
        XEiJ.regCCR = XEiJ.REG_CCR_Z | ((byte) x != 0 ? XEiJ.REG_CCR_V : 0) | (y == 8 ? -(x & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C) : 0);
      }
      break;
    case 0b101_000 >> 3:  //LSL.B Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = (byte) x;
        t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) ((t = y <= 8 ? x << y - 1 : 0) << 1));
        t = (byte) t >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b110_000 >> 3:  //ROXL.B Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      //y %= 9;
      y = (y & 7) - (y >> 3);  //y=data=-7～7
      y += y >> 3 & 9;  //y=data=0～8
      if (y == 0) {  //y=data=0
        z = (byte) x;
        t = -(XEiJ.regCCR >> 4 & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //Xは変化しない。CはXのコピー
      } else {  //y=data=1～8
        z = x << 1 | XEiJ.regCCR >> 4 & 1;
        if (y == 1) {  //y=data=1
          t = x;  //Cは最後に押し出されたビット
        } else {  //y=data=2～8
          z = (t = z << y - 2) << 1 | (0xff & x) >>> 9 - y;
        }
        XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) z);
        t = (byte) t >> 7 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b111_000 >> 3:  //ROL.B Dq,Dr
    default:
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {
        z = (byte) x;
        t = 0;  //Cはクリア
      } else {
        y &= 7;  //y=data=0～7
        XEiJ.regRn[rrr] = ~0xff & x | 0xff & (z = (byte) (x << y | (0xff & x) >>> 8 - y));
        t = z & 1;  //Cは結果の最下位ビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | t;  //Xは変化しない
    }
  }  //irpXxlToRegByte

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASL.W #<data>,Dr                                |-|012346|-|UUUUU|*****|          |1110_qqq_101_000_rrr
  //LSL.W #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_101_001_rrr
  //ROXL.W #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_101_010_rrr
  //ROL.W #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_101_011_rrr
  //ASL.W Dq,Dr                                     |-|012346|-|UUUUU|*****|          |1110_qqq_101_100_rrr
  //LSL.W Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_101_101_rrr
  //ROXL.W Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_101_110_rrr
  //ROL.W Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_101_111_rrr
  //ASL.W Dr                                        |A|012346|-|UUUUU|*****|          |1110_001_101_000_rrr [ASL.W #1,Dr]
  //LSL.W Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_101_001_rrr [LSL.W #1,Dr]
  //ROXL.W Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_101_010_rrr [ROXL.W #1,Dr]
  //ROL.W Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_101_011_rrr [ROL.W #1,Dr]
  //
  //ASL.W #<data>,Dr
  //ASL.W Dq,Dr
  //ASL.W <ea>
  //  算術左シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ0 ｱｲ**ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0,V=ｱｲ!=0/-1
  //     :
  //    15 ................ﾀ000000000000000 ｿﾀ**ｿ Z=ﾀ==0,V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ!=0/-1
  //    16 ................0000000000000000 ﾀ01*ﾀ V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ!=0
  //    17 ................0000000000000000 001*0 V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ!=0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  ASRで元に戻せないときセット。他はクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //LSL.W #<data>,Dr
  //LSL.W Dq,Dr
  //LSL.W <ea>
  //  論理左シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ0 ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     :
  //    15 ................ﾀ000000000000000 ｿﾀ*0ｿ Z=ﾀ==0
  //    16 ................0000000000000000 ﾀ010ﾀ
  //    17 ................0000000000000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //ROL.W #<data>,Dr
  //ROL.W Dq,Dr
  //ROL.W <ea>
  //  左ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀｱ Xｲ*0ｱ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     :
  //    15 ................ﾀｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ Xﾀ*0ｿ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //    16 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最下位ビット
  //
  //ROXL.W #<data>,Dr
  //ROXL.W Dq,Dr
  //ROXL.W <ea>
  //  拡張左ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //     2 ................ｳｴｵｶｷｸｹｺｻｼｽｾｿﾀXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //     :
  //    15 ................ﾀXｱｲｳｴｵｶｷｸｹｺｻｼｽｾ ｿﾀ*0ｿ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾﾀX==0
  //    16 ................Xｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀX*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿX==0
  //    17 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpXxlToRegWord () throws M68kException {
    int rrr;
    int x = XEiJ.regRn[rrr = XEiJ.regOC & 7];
    int y;
    int z;
    int t;
    XEiJ.mpuCycleCount++;
    switch (XEiJ.regOC >> 3 & 0b111_000 >> 3) {
    case 0b000_000 >> 3:  //ASL.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) ((t = x << y) << 1));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (z >> y + 1 != (short) x ? XEiJ.REG_CCR_V : 0) | (short) t >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //VはASRで元に戻せないときセット。XとCは最後に押し出されたビット
      break;
    case 0b001_000 >> 3:  //LSL.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) ((t = x << y) << 1));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (short) t >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b010_000 >> 3:  //ROXL.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      z = x << 1 | XEiJ.regCCR >> 4 & 1;
      if (y == 1 - 1) {  //y=data-1=1-1
        t = x;
      } else {  //y=data-1=2-1～8-1
        z = (t = z << y - (2 - 1)) << 1 | (char) x >>> 17 - 1 - y;
      }
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) z);
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (short) t >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b011_000 >> 3:  //ROL.W #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) (x << y + 1 | (char) x >>> 16 - 1 - y));
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | z & 1;  //Xは変化しない。Cは結果の最下位ビット
      break;
    case 0b100_000 >> 3:  //ASL.W Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y <= 15) {  //y=data=0～15
        if (y == 0) {  //y=data=0
          z = (short) x;
          t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。VとCはクリア
        } else {  //y=data=1～15
          XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) ((t = x << y - 1) << 1));
          t = (z >> y != (short) x ? XEiJ.REG_CCR_V : 0) | (short) t >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //VはASRで元に戻せないときセット。XとCは最後に押し出されたビット
        }
        XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      } else {  //y=data=16～63
        XEiJ.regRn[rrr] = ~0xffff & x;
        XEiJ.regCCR = XEiJ.REG_CCR_Z | ((short) x != 0 ? XEiJ.REG_CCR_V : 0) | (y == 16 ? -(x & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C) : 0);
      }
      break;
    case 0b101_000 >> 3:  //LSL.W Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = (short) x;
        t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) ((t = y <= 16 ? x << y - 1 : 0) << 1));
        t = (short) t >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b110_000 >> 3:  //ROXL.W Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      //y %= 17;
      y = (y & 15) - (y >> 4);  //y=data=-3～15
      y += y >> 4 & 17;  //y=data=0～16
      if (y == 0) {  //y=data=0
        z = (short) x;
        t = -(XEiJ.regCCR >> 4 & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //Xは変化しない。CはXのコピー
      } else {  //y=data=1～16
        z = x << 1 | XEiJ.regCCR >> 4 & 1;
        if (y == 1) {  //y=data=1
          t = x;  //Cは最後に押し出されたビット
        } else {  //y=data=2～16
          z = (t = z << y - 2) << 1 | (char) x >>> 17 - y;
        }
        XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) z);
        t = (short) t >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b111_000 >> 3:  //ROL.W Dq,Dr
    default:
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {
        z = (short) x;
        t = 0;  //Cはクリア
      } else {
        y &= 15;  //y=data=0～15
        XEiJ.regRn[rrr] = ~0xffff & x | (char) (z = (short) (x << y | (char) x >>> 16 - y));
        t = z & 1;  //Cは結果の最下位ビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | t;  //Xは変化しない
    }
  }  //irpXxlToRegWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASL.L #<data>,Dr                                |-|012346|-|UUUUU|*****|          |1110_qqq_110_000_rrr
  //LSL.L #<data>,Dr                                |-|012346|-|UUUUU|***0*|          |1110_qqq_110_001_rrr
  //ROXL.L #<data>,Dr                               |-|012346|-|*UUUU|***0*|          |1110_qqq_110_010_rrr
  //ROL.L #<data>,Dr                                |-|012346|-|-UUUU|-**0*|          |1110_qqq_110_011_rrr
  //ASL.L Dq,Dr                                     |-|012346|-|UUUUU|*****|          |1110_qqq_110_100_rrr
  //LSL.L Dq,Dr                                     |-|012346|-|UUUUU|***0*|          |1110_qqq_110_101_rrr
  //ROXL.L Dq,Dr                                    |-|012346|-|*UUUU|***0*|          |1110_qqq_110_110_rrr
  //ROL.L Dq,Dr                                     |-|012346|-|-UUUU|-**0*|          |1110_qqq_110_111_rrr
  //ASL.L Dr                                        |A|012346|-|UUUUU|*****|          |1110_001_110_000_rrr [ASL.L #1,Dr]
  //LSL.L Dr                                        |A|012346|-|UUUUU|***0*|          |1110_001_110_001_rrr [LSL.L #1,Dr]
  //ROXL.L Dr                                       |A|012346|-|*UUUU|***0*|          |1110_001_110_010_rrr [ROXL.L #1,Dr]
  //ROL.L Dr                                        |A|012346|-|-UUUU|-**0*|          |1110_001_110_011_rrr [ROL.L #1,Dr]
  //
  //ASL.L #<data>,Dr
  //ASL.L Dq,Dr
  //  算術左シフトロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ**0 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ0 ｱｲ**ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0,V=ｱｲ!=0/-1
  //     :
  //    31 ﾐ0000000000000000000000000000000 ﾏﾐ**ﾏ Z=ﾐ==0,V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ!=0/-1
  //    32 00000000000000000000000000000000 ﾐ01*ﾐ V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ!=0
  //    33 00000000000000000000000000000000 001*0 V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ!=0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  ASRで元に戻せないときセット。他はクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //LSL.L #<data>,Dr
  //LSL.L Dq,Dr
  //  論理左シフトロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ0 ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     :
  //    31 ﾐ0000000000000000000000000000000 ﾏﾐ*0ﾏ Z=ﾐ==0
  //    32 00000000000000000000000000000000 ﾐ010ﾐ
  //    33 00000000000000000000000000000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  //
  //ROL.L #<data>,Dr
  //ROL.L Dq,Dr
  //  左ローテートロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐｱ Xｲ*0ｱ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     :
  //    31 ﾐｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ Xﾐ*0ﾏ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //    32 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*0ﾐ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最下位ビット
  //
  //ROXL.L #<data>,Dr
  //ROXL.L Dq,Dr
  //  拡張左ローテートロング
  //       ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ XNZVC
  //     0 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //     1 ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐX==0
  //     2 ｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐX==0
  //     :
  //    31 ﾐXｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎ ﾏﾐ*0ﾏ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾐX==0
  //    32 Xｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ ﾐX*0ﾐ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏX==0
  //    33 ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpXxlToRegLong () throws M68kException {
    int rrr;
    int x = XEiJ.regRn[rrr = XEiJ.regOC & 7];
    int y;
    int z;
    int t;
    XEiJ.mpuCycleCount++;
    switch (XEiJ.regOC >> 3 & 0b111_000 >> 3) {
    case 0b000_000 >> 3:  //ASL.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = z = (t = x << y) << 1;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | (z >> y + 1 != x ? XEiJ.REG_CCR_V : 0) | t >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //VはASRで元に戻せないときセット。XとCは最後に押し出されたビット
      break;
    case 0b001_000 >> 3:  //LSL.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = z = (t = x << y) << 1;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b010_000 >> 3:  //ROXL.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      z = x << 1 | XEiJ.regCCR >> 4 & 1;
      if (y == 1 - 1) {  //y=data-1=1-1
        t = x;
      } else {  //y=data-1=2-1～8-1
        z = (t = z << y - (2 - 1)) << 1 | x >>> -y;  //Javaのシフト演算子は5ビットでマスクされるので33-1-yを-yに省略
      }
      XEiJ.regRn[rrr] = z;
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      break;
    case 0b011_000 >> 3:  //ROL.L #<data>,Dr
      y = (XEiJ.regOC >> 9) - 1 & 7;  //y=data-1=1-1～8-1
      XEiJ.regRn[rrr] = z = x << y + 1 | x >>> ~y;  //Javaのシフト演算子は5ビットでマスクされるので32-1-yを~yに省略
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | z & 1;  //Xは変化しない。Cは結果の最下位ビット
      break;
    case 0b100_000 >> 3:  //ASL.L Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y <= 31) {  //y=data=0～31
        if (y == 0) {  //y=data=0
          z = x;
          t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。VとCはクリア
        } else {  //y=data=1～31
          XEiJ.regRn[rrr] = z = (t = x << y - 1) << 1;
          t = (z >> y != x ? XEiJ.REG_CCR_V : 0) | t >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //VはASRで元に戻せないときセット。XとCは最後に押し出されたビット
        }
        XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      } else {  //y=data=32～63
        XEiJ.regRn[rrr] = 0;
        XEiJ.regCCR = XEiJ.REG_CCR_Z | (x != 0 ? XEiJ.REG_CCR_V : 0) | (y == 32 ? -(x & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C) : 0);
      }
      break;
    case 0b101_000 >> 3:  //LSL.L Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {  //y=data=0
        z = x;
        t = XEiJ.regCCR & XEiJ.REG_CCR_X;  //Xは変化しない。Cはクリア
      } else {  //y=data=1～63
        XEiJ.regRn[rrr] = z = (t = y <= 32 ? x << y - 1 : 0) << 1;
        t = t >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b110_000 >> 3:  //ROXL.L Dq,Dr
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      //y %= 33;
      y -= 32 - y >> 6 & 33;  //y=data=0～32
      if (y == 0) {  //y=data=0
        z = x;
        t = -(XEiJ.regCCR >> 4 & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //Xは変化しない。CはXのコピー
      } else {  //y=data=1～32
        z = x << 1 | XEiJ.regCCR >> 4 & 1;
        if (y == 1) {  //y=data=1
          t = x;  //Cは最後に押し出されたビット
        } else {  //y=data=2～32
          z = (t = z << y - 2) << 1 | x >>> 33 - y;
        }
        XEiJ.regRn[rrr] = z;
        t = t >> 31 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);  //XとCは最後に押し出されたビット
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.REG_CCR_Z : 0) | t;
      break;
    case 0b111_000 >> 3:  //ROL.L Dq,Dr
    default:
      y = XEiJ.regRn[XEiJ.regOC >> 9 & 7] & 63;  //y=0～63。Javaのシフト演算子は5ビットでマスクされることに注意
      if (y == 0) {
        z = x;
        t = 0;  //Cはクリア
      } else {
        XEiJ.regRn[rrr] = z = x << y | x >>> -y;  //Javaのシフト演算子は5ビットでマスクされるのでy&31をyに、32-(y&31)を-yに省略。y=32のときx|xになるが問題ない
        t = z & 1;
      }
      XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X) | t;  //Xは変化しない
    }
  }  //irpXxlToRegLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ASL.W <ea>                                      |-|012346|-|UUUUU|*****|  M+-WXZ  |1110_000_111_mmm_rrr
  //
  //ASL.W #<data>,Dr
  //ASL.W Dq,Dr
  //ASL.W <ea>
  //  算術左シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ0 ｱｲ**ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0,V=ｱｲ!=0/-1
  //     :
  //    15 ................ﾀ000000000000000 ｿﾀ**ｿ Z=ﾀ==0,V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ!=0/-1
  //    16 ................0000000000000000 ﾀ01*ﾀ V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ!=0
  //    17 ................0000000000000000 001*0 V=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ!=0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  ASRで元に戻せないときセット。他はクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  public static void irpAslToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordSignData (a, XEiJ.regSRS);
    int z = (short) (x << 1);
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = ((z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   (x ^ z) >>> 31 << 1 |  //Vは最上位ビットが変化したときセット
                   x >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //XとCは最後に押し出されたビット
  }  //irpAslToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //LSR.W <ea>                                      |-|012346|-|UUUUU|*0*0*|  M+-WXZ  |1110_001_011_mmm_rrr
  //
  //LSR.W #<data>,Dr
  //LSR.W Dq,Dr
  //LSR.W <ea>
  //  論理右シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................0ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀ0*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ==0
  //     :
  //    15 ................000000000000000ｱ ｲ0*0ｲ Z=ｱ==0
  //    16 ................0000000000000000 ｱ010ｱ
  //    17 ................0000000000000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  public static void irpLsrToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordZeroData (a, XEiJ.regSRS);
    int z = x >>> 1;
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = ((z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   -(x & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //XとCは最後に押し出されたビット
  }  //irpLsrToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //LSL.W <ea>                                      |-|012346|-|UUUUU|***0*|  M+-WXZ  |1110_001_111_mmm_rrr
  //
  //LSL.W #<data>,Dr
  //LSL.W Dq,Dr
  //LSL.W <ea>
  //  論理左シフトワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ0 ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     :
  //    15 ................ﾀ000000000000000 ｿﾀ*0ｿ Z=ﾀ==0
  //    16 ................0000000000000000 ﾀ010ﾀ
  //    17 ................0000000000000000 00100
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は最後に押し出されたビット
  public static void irpLslToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordSignData (a, XEiJ.regSRS);
    int z = (short) (x << 1);
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = ((z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   x >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //XとCは最後に押し出されたビット
  }  //irpLslToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ROXR.W <ea>                                     |-|012346|-|*UUUU|***0*|  M+-WXZ  |1110_010_011_mmm_rrr
  //
  //ROXR.W #<data>,Dr
  //ROXR.W Dq,Dr
  //ROXR.W <ea>
  //  拡張右ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................Xｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀX*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿX==0
  //     2 ................ﾀXｱｲｳｴｵｶｷｸｹｺｻｼｽｾ ｿﾀ*0ｿ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾﾀX==0
  //     :
  //    15 ................ｳｴｵｶｷｸｹｺｻｼｽｾｿﾀXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //    16 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //    17 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpRoxrToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordZeroData (a, XEiJ.regSRS);
    int z = -(XEiJ.regCCR & XEiJ.REG_CCR_X) << 15 - 4 | x >>> 1;
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = ((z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   -(x & 1) & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //XとCは最後に押し出されたビット
  }  //irpRoxrToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ROXL.W <ea>                                     |-|012346|-|*UUUU|***0*|  M+-WXZ  |1110_010_111_mmm_rrr
  //
  //ROXL.W #<data>,Dr
  //ROXL.W Dq,Dr
  //ROXL.W <ea>
  //  拡張左ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX ｱｲ*0ｱ Z=ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //     2 ................ｳｴｵｶｷｸｹｺｻｼｽｾｿﾀXｱ ｲｳ*0ｲ Z=ｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀX==0
  //     :
  //    15 ................ﾀXｱｲｳｴｵｶｷｸｹｺｻｼｽｾ ｿﾀ*0ｿ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾﾀX==0
  //    16 ................Xｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ ﾀX*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿX==0
  //    17 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0X Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  countが0のとき変化しない。他は最後に押し出されたビット
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときXのコピー。他は最後に押し出されたビット
  public static void irpRoxlToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordSignData (a, XEiJ.regSRS);
    int z = (short) (x << 1 | XEiJ.regCCR >> 4 & 1);
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = ((z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   x >> 15 & (XEiJ.REG_CCR_X | XEiJ.REG_CCR_C));  //XとCは最後に押し出されたビット
  }  //irpRoxlToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ROR.W <ea>                                      |-|012346|-|-UUUU|-**0*|  M+-WXZ  |1110_011_011_mmm_rrr
  //
  //ROR.W #<data>,Dr
  //ROR.W Dq,Dr
  //ROR.W <ea>
  //  右ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ﾀｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ Xﾀ*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     :
  //    15 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀｱ Xｲ*0ｲ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //    16 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0ｱ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最上位ビット
  public static void irpRorToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordZeroData (a, XEiJ.regSRS);
    int z = (short) (x << 15 | x >>> 1);
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |  //Xは変化しない
                   (z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   z >>> 31);  //Cは結果の最上位ビット
  }  //irpRorToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //ROL.W <ea>                                      |-|012346|-|-UUUU|-**0*|  M+-WXZ  |1110_011_111_mmm_rrr
  //
  //ROL.W #<data>,Dr
  //ROL.W Dq,Dr
  //ROL.W <ea>
  //  左ローテートワード
  //       ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ XNZVC
  //     0 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*00 Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     1 ................ｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀｱ Xｲ*0ｱ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //     :
  //    15 ................ﾀｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ Xﾀ*0ｿ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //    16 ................ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ Xｱ*0ﾀ Z=ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀ==0
  //  CCR
  //    X  常に変化しない
  //    N  結果の最上位ビット
  //    Z  結果が0のときセット。他はクリア
  //    V  常にクリア
  //    C  countが0のときクリア。他は結果の最下位ビット
  public static void irpRolToMem () throws M68kException {
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = efaMltWord (ea);
    int x = mmuModifyWordZeroData (a, XEiJ.regSRS);
    int z = (short) (x << 1 | x >>> 15);
    mmuWriteWordData (a, z, XEiJ.regSRS);
    XEiJ.regCCR = (XEiJ.regCCR & XEiJ.REG_CCR_X |  //Xは変化しない
                   (z < 0 ? XEiJ.REG_CCR_N : 0) |
                   (z == 0 ? XEiJ.REG_CCR_Z : 0) |
                   z & 1);  //Cは結果の最下位ビット
  }  //irpRolToMem

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFTST <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-00000ooooo0wwwww
  //BFTST <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-00000ooooo100www
  //BFTST <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-0000100ooo0wwwww
  //BFTST <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_011_mmm_rrr-0000100ooo100www
  public static void irpBftst () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0000_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 6;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFTST Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
    } else {  //BFTST <mem>{～}
      int a = efaCntLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      o &= 7;
      z = 31 - w + o >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      z = (z == 0 ? mmuReadByteSignData (a, XEiJ.regSRS) << 24 + o :  //不要なバイトにアクセスしない
           z == 1 ? mmuReadWordSignData (a, XEiJ.regSRS) << 16 + o :  //020以上なのでアドレスエラーは出ない
           z == 2 ? (mmuReadWordSignData (a, XEiJ.regSRS) << 8 | mmuReadByteZeroData (a + 2, XEiJ.regSRS)) << 8 + o :
           z == 3 ? mmuReadLongData (a, XEiJ.regSRS) << o :
           mmuReadLongData (a, XEiJ.regSRS) << o | mmuReadByteZeroData (a + 4, XEiJ.regSRS) >>> 8 - o);
    }
    z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBftst

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFEXTU <ea>{#o:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn0ooooo0wwwww
  //BFEXTU <ea>{#o:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn0ooooo100www
  //BFEXTU <ea>{Do:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn100ooo0wwwww
  //BFEXTU <ea>{Do:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_100_111_mmm_rrr-0nnn100ooo100www
  public static void irpBfextu () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0111_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int n = w >> 12;
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 6;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFEXTU Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
    } else {  //BFEXTU <mem>{～}
      int a = efaCntLong (ea) + (o >> 3);
      o &= 7;
      z = 31 - w + o >> 3;
      z = (z == 0 ? mmuReadByteSignData (a, XEiJ.regSRS) << 24 + o :  //不要なバイトにアクセスしない
           z == 1 ? mmuReadWordSignData (a, XEiJ.regSRS) << 16 + o :  //020以上なのでアドレスエラーは出ない
           z == 2 ? (mmuReadWordSignData (a, XEiJ.regSRS) << 8 | mmuReadByteZeroData (a + 2, XEiJ.regSRS)) << 8 + o :
           z == 3 ? mmuReadLongData (a, XEiJ.regSRS) << o :
           mmuReadLongData (a, XEiJ.regSRS) << o | mmuReadByteZeroData (a + 4, XEiJ.regSRS) >>> 8 - o);
    }
    XEiJ.regRn[n] = z >>> w;  //ゼロ拡張
    z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfextu

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFCHG <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-00000ooooo0wwwww
  //BFCHG <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-00000ooooo100www
  //BFCHG <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-0000100ooo0wwwww
  //BFCHG <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_101_011_mmm_rrr-0000100ooo100www
  public static void irpBfchg () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0000_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 8;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFCHG Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
      int t = z ^ -1 << w;  //フィールドの幅だけ反転する
      XEiJ.regRn[ea] = t << -o | t >>> o;
    } else {  //BFCHG <mem>{～}
      int a = efaCltLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      o &= 7;
      z = 31 - w + o >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      if (z == 0) {
        //  <ea>{2,5}  o=2,w=32-5=27                        <ea>  --abcde-
        int t = mmuModifyByteSignData (a, XEiJ.regSRS) << 24;                     //          t  --abcde- 00000000 00000000 00000000  不要なバイトにアクセスしない
        z = t << o;                                //          z  abcde-00 00000000 00000000 00000000
        //                                         //      -1<<w  11111000 00000000 00000000 00000000
        //                                         //  -1<<w>>>o  00111110 00000000 00000000 00000000
        //                                         //t^-1<<w>>>o  --ABCDE- 00000000 00000000 00000000
        mmuWriteByteData (a, (t ^ -1 << w >>> o) >>> 24, XEiJ.regSRS);        //       <ea>  --ABCDE-
      } else if (z == 1) {
        //  <ea>{7,5}  o=7,w=32-5=27                        <ea>  -------a bcde----
        int t = mmuModifyWordSignData (a, XEiJ.regSRS) << 16;                     //          t  -------a bcde---- 00000000 00000000  020以上なのでアドレスエラーは出ない
        z = t << o;                                //          z  abcde--- -0000000 00000000 00000000
        //                                         //      -1<<w  11111000 00000000 00000000 00000000
        //                                         //  -1<<w>>>o  00000001 11110000 00000000 00000000
        //                                         //t^-1<<w>>>o  -------A BCDE---- 00000000 00000000
        mmuWriteWordData (a, (t ^ -1 << w >>> o) >>> 16, XEiJ.regSRS);       //       <ea>  -------A BCDE----
      } else if (z == 2) {
        //  <ea>{7,12}  o=7,w=32-12=20                      <ea>  -------a bcdefghi jkl-----
        int t = mmuModifyWordSignData (a, XEiJ.regSRS) << 16 | mmuModifyByteZeroData (a + 2, XEiJ.regSRS) << 8;  //          t  -------a bcdefghi jkl----- 00000000
        z = t << o;                                //          z  abcdefgh ijkl---- -0000000 00000000
        //                                         //      -1<<w  11111111 11110000 00000000 00000000
        //                                         //  -1<<w>>>o  00000001 11111111 11100000 00000000
        t ^= -1 << w >>> o;                        //          t  -------A BCDEFGHI JKL----- 00000000
        mmuWriteWordData (a, t >>> 16, XEiJ.regSRS);                         //       <ea>  -------A BCDEFGHI jkl-----
        mmuWriteByteData (a + 2, t >>> 8, XEiJ.regSRS);                       //       <ea>  -------A BCDEFGHI JKL-----
      } else if (z == 3) {
        //  <ea>{7,19}  o=7,w=32-19=13                      <ea>  -------a bcdefghi jklmnopq rs------
        int t = mmuModifyLongData (a, XEiJ.regSRS);                           //          t  -------a bcdefghi jklmnopq rs------
        z = t << o;                                //          z  abcdefgh ijklmnop qrs----- -0000000
        //                                         //      -1<<w  11111111 11111111 11100000 00000000
        //                                         //  -1<<w>>>o  00000001 11111111 11111111 11000000
        mmuWriteLongData (a, t ^ -1 << w >>> o, XEiJ.regSRS);                //       <ea>  -------A BCDEFGHI JKLMNOPQ RS------
      } else {
        //  <ea>{7,26}  o=7,w=32-26=6                       <ea>  -------a bcdefghi jklmnopq rstuvwxy z-------
        int t = mmuModifyLongData (a, XEiJ.regSRS);                           //          t  -------a bcdefghi jklmnopq rstuvwxy
        z = t << o;                                //          z  abcdefgh ijklmnop qrstuvwx y0000000
        //                                                -1>>>o  00000001 11111111 11111111 11111111
        mmuWriteLongData (a, t ^ -1 >>> o, XEiJ.regSRS);                     //       <ea>  -------A BCDEFGHI JKLMNOPQ RSTUVWXY
        t = mmuModifyByteZeroData (a + 4, XEiJ.regSRS);                           //          t  00000000 00000000 00000000 z-------
        //                                         //    t>>>8-o  00000000 00000000 00000000 0z------
        z |= t >>> 8 - o;                          //          z  abcdefgh ijklmnop qrstuvwx yz------
        //                                         //  -1<<8-o+w  11111111 11111111 11111111 10000000
        mmuWriteByteData (a + 4, t ^ -1 << 8 - o + w, XEiJ.regSRS);           //       <ea>  -------A BCDEFGHI JKLMNOPQ RSTUVWXY Z-------
      }
    }
    z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfchg

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFEXTS <ea>{#o:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn0ooooo0wwwww
  //BFEXTS <ea>{#o:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn0ooooo100www
  //BFEXTS <ea>{Do:#w},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn100ooo0wwwww
  //BFEXTS <ea>{Do:Dw},Dn                           |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_101_111_mmm_rrr-0nnn100ooo100www
  public static void irpBfexts () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0111_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int n = w >> 12;
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 6;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFEXTS Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
    } else {  //BFEXTS <mem>{～}
      int a = efaCntLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      o &= 7;
      z = 31 - w + o >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      z = (z == 0 ? mmuReadByteSignData (a, XEiJ.regSRS) << 24 + o :  //不要なバイトにアクセスしない
           z == 1 ? mmuReadWordSignData (a, XEiJ.regSRS) << 16 + o :  //020以上なのでアドレスエラーは出ない
           z == 2 ? (mmuReadWordSignData (a, XEiJ.regSRS) << 8 | mmuReadByteZeroData (a + 2, XEiJ.regSRS)) << 8 + o :
           z == 3 ? mmuReadLongData (a, XEiJ.regSRS) << o :
           mmuReadLongData (a, XEiJ.regSRS) << o | mmuReadByteZeroData (a + 4, XEiJ.regSRS) >>> 8 - o);
    }
    XEiJ.regRn[n] = z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfexts

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFCLR <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-00000ooooo0wwwww
  //BFCLR <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-00000ooooo100www
  //BFCLR <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-0000100ooo0wwwww
  //BFCLR <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_110_011_mmm_rrr-0000100ooo100www
  public static void irpBfclr () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0000_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 8;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFCLR Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
      int t = z & ~(-1 << w);  //フィールドの幅だけ0を並べる
      XEiJ.regRn[ea] = t << -o | t >>> o;
    } else {  //BFCLR <mem>{～}
      int a = efaCltLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      o &= 7;
      z = 31 - w + o >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      if (z == 0) {
        //  <ea>{2,5}  o=2,w=32-5=27                        <ea>  --abcde-
        int t = mmuModifyByteSignData (a, XEiJ.regSRS) << 24;                     //          t  --abcde- 00000000 00000000 00000000  不要なバイトにアクセスしない
        z = t << o;                                //          z  abcde-00 00000000 00000000 00000000
        //                                         //      -1<<w  11111000 00000000 00000000 00000000
        //                                         //  -1<<w>>>o  00111110 00000000 00000000 00000000
        //                                        //~(-1<<w>>>o)  11000001 11111111 11111111 11111111
        //                                      //t&~(-1<<w>>>o)  --00000- 00000000 00000000 00000000
        mmuWriteByteData (a, (t & ~(-1 << w >>> o)) >>> 24, XEiJ.regSRS);     //       <ea>  --00000-
      } else if (z == 1) {
        //  <ea>{7,5}  o=7,w=32-5=27                        <ea>  -------a bcde----
        int t = mmuModifyWordSignData (a, XEiJ.regSRS) << 16;                     //          t  -------a bcde---- 00000000 00000000  020以上なのでアドレスエラーは出ない
        z = t << o;                                //          z  abcde--- -0000000 00000000 00000000
        //                                         //      -1<<w  11111000 00000000 00000000 00000000
        //                                         //  -1<<w>>>o  00000001 11110000 00000000 00000000
        //                                        //~(-1<<w>>>o)  11111110 00001111 11111111 11111111
        //                                      //t&~(-1<<w>>>o)  -------0 0000---- 00000000 00000000
        mmuWriteWordData (a, (t & ~(-1 << w >>> o)) >>> 16, XEiJ.regSRS);    //       <ea>  -------0 0000----
      } else if (z == 2) {
        //  <ea>{7,12}  o=7,w=32-12=20                      <ea>  -------a bcdefghi jkl-----
        int t = mmuModifyWordSignData (a, XEiJ.regSRS) << 16 | mmuModifyByteZeroData (a + 2, XEiJ.regSRS) << 8;  //          t  -------a bcdefghi jkl----- 00000000
        z = t << o;                                //          z  abcdefgh ijkl---- -0000000 00000000
        //                                         //      -1<<w  11111111 11110000 00000000 00000000
        //                                         //  -1<<w>>>o  00000001 11111111 11100000 00000000
        //                                        //~(-1<<w>>>o)  11111110 00000000 00011111 11111111
        t &= ~(-1 << w >>> o);                     //          t  -------0 00000000 000----- 00000000
        mmuWriteWordData (a, t >>> 16, XEiJ.regSRS);                         //       <ea>  -------0 00000000 jkl-----
        mmuWriteByteData (a + 2, t >>> 8, XEiJ.regSRS);                       //       <ea>  -------0 00000000 000-----
      } else if (z == 3) {
        //  <ea>{7,19}  o=7,w=32-19=13                      <ea>  -------a bcdefghi jklmnopq rs------
        int t = mmuModifyLongData (a, XEiJ.regSRS);                           //          t  -------a bcdefghi jklmnopq rs------
        z = t << o;                                //          z  abcdefgh ijklmnop qrs----- -0000000
        //                                         //      -1<<w  11111111 11111111 11100000 00000000
        //                                         //  -1<<w>>>o  00000001 11111111 11111111 11000000
        //                                        //~(-1<<w>>>o)  11111110 00000000 00000000 00111111
        mmuWriteLongData (a, t & ~(-1 << w >>> o), XEiJ.regSRS);             //       <ea>  -------0 00000000 00000000 00------
      } else {
        //  <ea>{7,26}  o=7,w=32-26=6                       <ea>  -------a bcdefghi jklmnopq rstuvwxy z-------
        int t = mmuModifyLongData (a, XEiJ.regSRS);                           //          t  -------a bcdefghi jklmnopq rstuvwxy
        z = t << o;                                //          z  abcdefgh ijklmnop qrstuvwx y0000000
        //                                                -1>>>o  00000001 11111111 11111111 11111111
        //                                             ~(-1>>>o)  11111110 00000000 00000000 00000000
        mmuWriteLongData (a, t & ~(-1 >>> o), XEiJ.regSRS);                  //       <ea>  -------0 00000000 00000000 00000000
        t = mmuModifyByteZeroData (a + 4, XEiJ.regSRS);                           //          t  00000000 00000000 00000000 z-------
        //                                         //    t>>>8-o  00000000 00000000 00000000 0z------
        z |= t >>> 8 - o;                          //          z  abcdefgh ijklmnop qrstuvwx yz------
        //                                         //  -1<<8-o+w  11111111 11111111 11111111 10000000
        //                                        //~(-1<<8-o+w)  00000000 00000000 00000000 01111111
        mmuWriteByteData (a + 4, t & ~(-1 << 8 - o + w), XEiJ.regSRS);        //       <ea>  -------0 00000000 00000000 00000000 0-------
      }
    }
    z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfclr

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFFFO <ea>{#o:#w},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn0ooooo0wwwww
  //BFFFO <ea>{#o:Dw},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn0ooooo100www
  //BFFFO <ea>{Do:#w},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn100ooo0wwwww
  //BFFFO <ea>{Do:Dw},Dn                            |-|--2346|-|-UUUU|-**00|D M  WXZP |1110_110_111_mmm_rrr-0nnn100ooo100www
  public static void irpBfffo () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0111_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int n = w >> 12;
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 9;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFFFO Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
    } else {  //BFFFO <mem>{～}
      int a = efaCntLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      int o7 = o & 7;
      z = 31 - w + o7 >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      z = (z == 0 ? mmuReadByteSignData (a, XEiJ.regSRS) << 24 + o7 :  //不要なバイトにアクセスしない
           z == 1 ? mmuReadWordSignData (a, XEiJ.regSRS) << 16 + o7 :  //020以上なのでアドレスエラーは出ない
           z == 2 ? (mmuReadWordSignData (a, XEiJ.regSRS) << 8 | mmuReadByteZeroData (a + 2, XEiJ.regSRS)) << 8 + o7 :
           z == 3 ? mmuReadLongData (a, XEiJ.regSRS) << o7 :
           mmuReadLongData (a, XEiJ.regSRS) << o7 | mmuReadByteZeroData (a + 4, XEiJ.regSRS) >>> 8 - o7);
    }
    if (true) {
      XEiJ.regRn[n] = Integer.numberOfLeadingZeros (z >>> w) - w + o;  //ゼロ拡張してから1のビットを探す。見つからないときはoffset+widthになる
    } else {
      int t = z >>> w;
      if (t == 0) {
        XEiJ.regRn[n] = 32 - w + o;
      } else {
        int k = -(t >>> 16) >> 16 & 16;
        k += -(t >>> k + 8) >> 8 & 8;
        k += -(t >>> k + 4) >> 4 & 4;
        //     bit3  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0
        //     bit2  1  1  1  1  0  0  0  0  1  1  1  1  0  0  0  0
        //     bit1  1  1  0  0  1  1  0  0  1  1  0  0  1  1  0  0
        //     bit0  1  0  1  0  1  0  1  0  1  0  1  0  1  0  1  0
        XEiJ.regRn[n] = ((0b11_11_11_11_11_11_11_11_10_10_10_10_01_01_00_00 >>> (t >>> k << 1)) & 3) + k - w + o;  //intのシフトカウントは下位5bitだけが使用される
      }
    }
    z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfffo

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFSET <ea>{#o:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-00000ooooo0wwwww
  //BFSET <ea>{#o:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-00000ooooo100www
  //BFSET <ea>{Do:#w}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-0000100ooo0wwwww
  //BFSET <ea>{Do:Dw}                               |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_011_mmm_rrr-0000100ooo100www
  public static void irpBfset () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0000_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 8;
    int ea = XEiJ.regOC & 63;
    int z;
    if (ea < XEiJ.EA_AR) {  //BFSET Dr{～}
      z = XEiJ.regRn[ea];
      z = z << o | z >>> -o;  //下位からはみ出したフィールドは上位に戻る
      int t = z | -1 << w;  //フィールドの幅だけ1を並べる
      XEiJ.regRn[ea] = t << -o | t >>> o;
    } else {  //BFSET <mem>{～}
      int a = efaCltLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      o &= 7;
      z = 31 - w + o >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      if (z == 0) {
        //  <ea>{2,5}  o=2,w=32-5=27                        <ea>  --abcde-
        int t = mmuModifyByteSignData (a, XEiJ.regSRS) << 24;                     //          t  --abcde- 00000000 00000000 00000000  不要なバイトにアクセスしない
        z = t << o;                                //          z  abcde-00 00000000 00000000 00000000
        //                                         //      -1<<w  11111000 00000000 00000000 00000000
        //                                         //  -1<<w>>>o  00111110 00000000 00000000 00000000
        //                                         //t|-1<<w>>>o  --11111- 00000000 00000000 00000000
        mmuWriteByteData (a, (t | -1 << w >>> o) >>> 24, XEiJ.regSRS);        //       <ea>  --11111-
      } else if (z == 1) {
        //  <ea>{7,5}  o=7,w=32-5=27                        <ea>  -------a bcde----
        int t = mmuModifyWordSignData (a, XEiJ.regSRS) << 16;                     //          t  -------a bcde---- 00000000 00000000  020以上なのでアドレスエラーは出ない
        z = t << o;                                //          z  abcde--- -0000000 00000000 00000000
        //                                         //      -1<<w  11111000 00000000 00000000 00000000
        //                                         //  -1<<w>>>o  00000001 11110000 00000000 00000000
        //                                         //t|-1<<w>>>o  -------1 1111---- 00000000 00000000
        mmuWriteWordData (a, (t | -1 << w >>> o) >>> 16, XEiJ.regSRS);       //       <ea>  -------1 1111----
      } else if (z == 2) {
        //  <ea>{7,12}  o=7,w=32-12=20                      <ea>  -------a bcdefghi jkl-----
        int t = mmuModifyWordSignData (a, XEiJ.regSRS) << 16 | mmuModifyByteZeroData (a + 2, XEiJ.regSRS) << 8;  //          t  -------a bcdefghi jkl----- 00000000
        z = t << o;                                //          z  abcdefgh ijkl---- -0000000 00000000
        //                                         //      -1<<w  11111111 11110000 00000000 00000000
        //                                         //  -1<<w>>>o  00000001 11111111 11100000 00000000
        t |= -1 << w >>> o;                        //          t  -------1 11111111 111----- 00000000
        mmuWriteWordData (a, t >>> 16, XEiJ.regSRS);                         //       <ea>  -------1 11111111 jkl-----
        mmuWriteByteData (a + 2, t >>> 8, XEiJ.regSRS);                       //       <ea>  -------1 11111111 111-----
      } else if (z == 3) {
        //  <ea>{7,19}  o=7,w=32-19=13                      <ea>  -------a bcdefghi jklmnopq rs------
        int t = mmuModifyLongData (a, XEiJ.regSRS);                           //          t  -------a bcdefghi jklmnopq rs------
        z = t << o;                                //          z  abcdefgh ijklmnop qrs----- -0000000
        //                                         //      -1<<w  11111111 11111111 11100000 00000000
        //                                         //  -1<<w>>>o  00000001 11111111 11111111 11000000
        mmuWriteLongData (a, t | -1 << w >>> o, XEiJ.regSRS);                //       <ea>  -------1 11111111 11111111 11------
      } else {
        //  <ea>{7,26}  o=7,w=32-26=6                       <ea>  -------a bcdefghi jklmnopq rstuvwxy z-------
        int t = mmuModifyLongData (a, XEiJ.regSRS);                           //          t  -------a bcdefghi jklmnopq rstuvwxy
        z = t << o;                                //          z  abcdefgh ijklmnop qrstuvwx y0000000
        //                                                -1>>>o  00000001 11111111 11111111 11111111
        mmuWriteLongData (a, t | -1 >>> o, XEiJ.regSRS);                     //       <ea>  -------1 11111111 11111111 11111111
        t = mmuModifyByteZeroData (a + 4, XEiJ.regSRS);                           //          t  00000000 00000000 00000000 z-------
        //                                         //    t>>>8-o  00000000 00000000 00000000 0z------
        z |= t >>> 8 - o;                          //          z  abcdefgh ijklmnop qrstuvwx yz------
        //                                         //  -1<<8-o+w  11111111 11111111 11111111 10000000
        mmuWriteByteData (a + 4, t | -1 << 8 - o + w, XEiJ.regSRS);           //       <ea>  -------1 11111111 11111111 11111111 1-------
      }
    }
    z >>= w;  //符号拡張。下位のゴミを消す
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfset

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //BFINS Dn,<ea>{#o:#w}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn0ooooo0wwwww
  //BFINS Dn,<ea>{#o:Dw}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn0ooooo100www
  //BFINS Dn,<ea>{Do:#w}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn100ooo0wwwww
  //BFINS Dn,<ea>{Do:Dw}                            |-|--2346|-|-UUUU|-**00|D M  WXZ  |1110_111_111_mmm_rrr-0nnn100ooo100www
  public static void irpBfins () throws M68kException {
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & ~0b0111_111_111_111_111) != 0 ||
        (w & 0b0000_111_111_000_000) > 0b0000_100_111_000_000 ||
        (w & 0b0000_000_000_111_111) > 0b0000_000_000_100_111) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
    int n = w >> 12;
    int o = w << 31 - 11 >= 0 ? w >> 6 & 31 : XEiJ.regRn[w >> 6 & 7];  //o=offset
    w = -(w << 31 - 5 >= 0 ? w : XEiJ.regRn[w & 7]) & 31;  //w=32-width。1<=width<=32なので0<=32-width<=31
    XEiJ.mpuCycleCount += 6;
    int ea = XEiJ.regOC & 63;
    int z = XEiJ.regRn[n] << w;  //z=Dn<<-width
    if (ea < XEiJ.EA_AR) {  //BFINS Dn,Dr{～}
      //  Dr{30,5}  o=30,w=32-5=27                          t=Dr  cde----- -------- -------- ------ab
      //                                                    t<<o  ab000000 00000000 00000000 00000000
      //                                                  t>>>-o  00cde--- -------- -------- --------
      //                                             t<<o|t>>>-o  abcde--- -------- -------- --------
      //                                                   -1<<w  11111000 00000000 00000000 00000000
      //                                                ~(-1<<w)  00000111 11111111 11111111 11111111
      //                                  (t<<o|t>>>-o)&~(-1<<w)  00000--- -------- -------- --------
      //                                                    r[n]  -------- -------- -------- ---ABCDE
      //                                               z=r[n]<<w  ABCDE000 00000000 00000000 00000000
      //                              t=(t<<o|t>>>-o)&~(-1<<w)|z  ABCDE--- -------- -------- --------
      //                                                   t<<-o  CDE----- -------- -------- ------00
      //                                                   t>>>o  00000000 00000000 00000000 000000AB
      //                                             t<<-o|t>>>o  CDE----- -------- -------- ------AB
      int t = XEiJ.regRn[ea];
      t = (t << o | t >>> -o) & ~(-1 << w) | z;
      XEiJ.regRn[ea] = t << -o | t >>> o;
    } else {  //BFINS Dn,<mem>{～}
      int a = efaCltLong (ea) + (o >> 3);  //フィールドの最上位ビットを含むバイトのアドレス
      o &= 7;
      n = 31 - w + o >> 3;  //フィールドが跨ぐバイト境界の数。0～4
      if (n == 0) {
        //  <ea>{2,5}  o=2,w=32-5=27                        <ea>  --abcde-
        //                                         XEiJ.busRbs(a)<<24  --abcde- 00000000 00000000 00000000
        //                                                 -1<<w  11111000 00000000 00000000 00000000
        //                                             -1<<w>>>o  00111110 00000000 00000000 00000000
        //                                          ~(-1<<w>>>o)  11000001 11111111 11111111 11111111
        //                            XEiJ.busRbs(a)<<24&~(-1<<w>>>o)  --00000- 00000000 00000000 00000000
        //                                                  r[n]  -------- -------- -------- ---ABCDE
        //                                             z=r[n]<<w  ABCDE000 00000000 00000000 00000000
        //                                                 z>>>o  00ABCDE0 00000000 00000000 00000000
        //                      XEiJ.busRbs(a)<<24&~(-1<<w>>>o)|z>>>o  --ABCDE- 00000000 00000000 00000000
        mmuWriteByteData (a, (mmuModifyByteSignData (a, XEiJ.regSRS) << 24 & ~(-1 << w >>> o) | z >>> o) >>> 24, XEiJ.regSRS);
      } else if (n == 1) {
        //  <ea>{3,11}  o=3,w=32-11=21                      <ea>  ---abcde fghijk--
        //                                            rws(a)<<16  ---abcde fghijk-- 00000000 00000000
        //                                                 -1<<w  11111111 11100000 00000000 00000000
        //                                             -1<<w>>>o  00011111 11111100 00000000 00000000
        //                                          ~(-1<<w>>>o)  11100000 00000011 11111111 11111111
        //                               rws(a)<<16&~(-1<<w>>>o)  ---00000 000000-- 00000000 00000000
        //                                                  r[n]  -------- -------- -----ABC DEFGHIJK
        //                                             z=r[n]<<w  ABCDEFGH IJK00000 00000000 00000000
        //                                                 z>>>o  000ABCDE FGHIJK00 00000000 00000000
        //                         rws(a)<<16&~(-1<<w>>>o)|z>>>o  ---ABCDE FGHIJK-- 00000000 00000000
        mmuWriteWordData (a, (mmuModifyWordSignData (a, XEiJ.regSRS) << 16 & ~(-1 << w >>> o) | z >>> o) >>> 16, XEiJ.regSRS);
      } else if (n == 2) {
        //  <ea>{4,17}  o=4,w=32-17=15                      <ea>  ----abcd efghijkl mnopq---
        //                                rws(a)<<16|rbz(a+2)<<8  ----abcd efghijkl mnopq--- 00000000
        //                                                 -1<<w  11111111 11111111 10000000 00000000
        //                                             -1<<w>>>o  00001111 11111111 11111000 00000000
        //                                          ~(-1<<w>>>o)  11110000 00000000 00000111 11111111
        //                 (rws(a)<<16|rbz(a+2)<<8)&~(-1<<w>>>o)  ----0000 00000000 00000--- 00000000
        //                                                  r[n]  -------- -------A BCDEFGHI JKLMNOPQ
        //                                             z=r[n]<<w  ABCDEFGH IJKLMNOP Q0000000 00000000
        //                                                 z>>>o  0000ABCD EFGHIJKL MNOPQ000 00000000
        //           (rws(a)<<16|rbz(a+2)<<8)&~(-1<<w>>>o)|z>>>o  ----ABCD EFGHIJKL MNOPQ--- 00000000
        int t = (mmuModifyWordSignData (a, XEiJ.regSRS) << 16 | mmuModifyByteZeroData (a + 2, XEiJ.regSRS) << 8) & ~(-1 << w >>> o) | z >>> o;
        mmuWriteWordData (a, t >>> 16, XEiJ.regSRS);
        mmuWriteByteData (a + 2, t >>> 8, XEiJ.regSRS);
      } else if (n == 3) {
        //  <ea>{5,23}  o=5,w=32-23=9                       <ea>  -----abc defghijk lmnopqrs tuvw----
        //                                                rls(a)  -----abc defghijk lmnopqrs tuvw----
        //                                                 -1<<w  11111111 11111111 11111110 00000000
        //                                             -1<<w>>>o  00000111 11111111 11111111 11110000
        //                                          ~(-1<<w>>>o)  11111000 00000000 00000000 00001111
        //                                   rls(a)&~(-1<<w>>>o)  -----000 00000000 00000000 0000----
        //                                                  r[n]  -------- -ABCDEFG HIJKLMNO PQRSTUVW
        //                                             z=r[n]<<w  ABCDEFGH IJKLMNOP QRSTUVW0 00000000
        //                                                 z>>>o  00000ABC DEFGHIJK LMNOPQRS TUVW0000
        //                             rls(a)&~(-1<<w>>>o)|z>>>o  -----ABC DEFGHIJK LMNOPQRS TUVW----
        mmuWriteLongData (a, mmuModifyLongData (a, XEiJ.regSRS) & ~(-1 << w >>> o) | z >>> o, XEiJ.regSRS);
      } else {
        //  <ea>{6,29}  o=6,w=32-29=3                       <ea>  ------ab cdefghij klmnopqr stuvwxyz abc-----
        //                                                rls(a)  ------ab cdefghij klmnopqr stuvwxyz
        //                                                -1>>>o  00000011 11111111 11111111 11111111
        //                                             ~(-1>>>o)  11111100 00000000 00000000 00000000
        //                                      rls(a)&~(-1>>>o)  ------00 00000000 00000000 00000000
        //                                                  r[n]  ---ABCDE FGHIJKLM NOPQRSTU VWXYZABC
        //                                             z=r[n]<<w  ABCDEFGH IJKLMNOP QRSTUVWX YZABC000
        //                                                 z>>>o  000000AB CDEFGHIJ KLMNOPQR STUVWXYZ
        //                                rls(a)&~(-1>>>o)|z>>>o  ------AB CDEFGHIJ KLMNOPQR STUVWXYZ
        mmuWriteLongData (a, mmuModifyLongData (a, XEiJ.regSRS) & ~(-1 >>> o) | z >>> o, XEiJ.regSRS);
        //                                              rbz(a+4)  00000000 00000000 00000000 abc-----
        //                                             -1<<8-o+w  11111111 11111111 11111111 11100000
        //                                          ~(-1<<8-o+w)  00000000 00000000 00000000 00011111
        //                                 rbz(a+4)&~(-1<<8-o+w)  00000000 00000000 00000000 000-----
        //                                                z<<8-o  CDEFGHIJ KLMNOPQR STUVWXYZ ABC00000
        //                          rbz(a+4)&~(-1<<8-o+w)|z<<8-o  CDEFGHIJ KLMNOPQR STUVWXYZ ABC-----
        mmuWriteByteData (a + 4, mmuModifyByteZeroData (a + 4, XEiJ.regSRS) & ~(-1 << 8 - o + w) | z << 8 - o, XEiJ.regSRS);
      }
    }
    //zは上位に寄ったままだが下位の空きは0なのでそのままテストする
    XEiJ.regCCR = z >> 28 & XEiJ.REG_CCR_N | (z == 0 ? XEiJ.regCCR & XEiJ.REG_CCR_X | XEiJ.REG_CCR_Z : XEiJ.regCCR & XEiJ.REG_CCR_X);  //ccr_tst
  }  //irpBfins

  //浮動小数点例外
  //  48  BSUN   FP分岐または比較不能状態でのセット
  //  49  INEX   FP不正確な結果
  //  50  DZ     FPゼロによる除算
  //  51  UNFL   FPアンダーフロー
  //  52  OPERR  FPオペランドエラー
  //  53  OVFL   FPオーバーフロー
  //  54  SNAN   FPシグナリングNAN
  //  55         FP未実装データ型
  //FPSRのビットオフセット→例外ベクタ番号
/*
  public static final int[] FP_OFFSET_TO_NUMBER = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    48,  //16  15  BSUN   48  BSUN   FP分岐または比較不能状態でのセット
    54,  //17  14  SNAN   54  SNAN   FPシグナリングNAN
    52,  //18  13  OPERR  52  OPERR  FPオペランドエラー
    53,  //19  12  OVFL   53  OVFL   FPオーバーフロー
    51,  //20  11  UNFL   51  UNFL   FPアンダーフロー
    50,  //21  10  DZ     50  DZ     FPゼロによる除算
    49,  //22   9  INEX2  49  INEX   FP不正確な結果
    49,  //23   8  INEX1  49  INEX   FP不正確な結果
    0, 0, 0, 0, 0, 0, 0, 0,
  };
*/
  public static final byte[] FP_OFFSET_TO_NUMBER = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\00006453211\0\0\0\0\0\0\0\0".getBytes (XEiJ.ISO_8859_1);

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FTST.X FPm                                      |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmm0000111010
  //FMOVE.X FPm,FPn                                 |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000000
  //FINT.X FPm,FPn                                  |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000001
  //FSINH.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000010
  //FINTRZ.X FPm,FPn                                |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000011
  //FSQRT.X FPm,FPn                                 |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000100
  //FLOGNP1.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0000110
  //FETOXM1.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001000
  //FTANH.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001001
  //FATAN.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001010
  //FASIN.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001100
  //FATANH.X FPm,FPn                                |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001101
  //FSIN.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001110
  //FTAN.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0001111
  //FETOX.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010000
  //FTWOTOX.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010001
  //FTENTOX.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010010
  //FLOGN.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010100
  //FLOG10.X FPm,FPn                                |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010101
  //FLOG2.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0010110
  //FABS.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011000
  //FCOSH.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011001
  //FNEG.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011010
  //FACOS.X FPm,FPn                                 |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011100
  //FCOS.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011101
  //FGETEXP.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011110
  //FGETMAN.X FPm,FPn                               |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0011111
  //FDIV.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100000
  //FMOD.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100001
  //FADD.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100010
  //FMUL.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100011
  //FSGLDIV.X FPm,FPn                               |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100100
  //FREM.X FPm,FPn                                  |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100101
  //FSCALE.X FPm,FPn                                |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100110
  //FSGLMUL.X FPm,FPn                               |-|--CCS6|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0100111
  //FSUB.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0101000
  //FCMP.X FPm,FPn                                  |-|--CC46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn0111000
  //FSMOVE.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000000
  //FSSQRT.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000001
  //FDMOVE.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000100
  //FDSQRT.X FPm,FPn                                |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1000101
  //FSABS.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011000
  //FSNEG.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011010
  //FDABS.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011100
  //FDNEG.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1011110
  //FSDIV.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100000
  //FSADD.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100010
  //FSMUL.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100011
  //FDDIV.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100100
  //FDADD.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100110
  //FDMUL.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1100111
  //FSSUB.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1101000
  //FDSUB.X FPm,FPn                                 |-|----46|-|-----|-----|          |1111_001_000_000_000-000mmmnnn1101100
  //FSINCOS.X FPm,FPc:FPs                           |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-000mmmsss0110ccc
  //FMOVECR.X #ccc,FPn                              |-|--CCSS|-|-----|-----|          |1111_001_000_000_000-010111nnn0cccccc
  //FMOVE.L FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011000nnn0000000
  //FMOVE.S FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011001nnn0000000
  //FMOVE.W FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011100nnn0000000
  //FMOVE.B FPn,<ea>                                |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-011110nnn0000000
  //FMOVE.L FPIAR,<ea>                              |-|--CC46|-|-----|-----|DAM+-WXZ  |1111_001_000_mmm_rrr-1010010000000000
  //FMOVEM.L FPIAR,<ea>                             |-|--CC46|-|-----|-----|DAM+-WXZ  |1111_001_000_mmm_rrr-1010010000000000
  //FMOVE.L FPSR,<ea>                               |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1010100000000000
  //FMOVEM.L FPSR,<ea>                              |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1010100000000000
  //FMOVE.L FPCR,<ea>                               |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1011000000000000
  //FMOVEM.L FPCR,<ea>                              |-|--CC46|-|-----|-----|D M+-WXZ  |1111_001_000_mmm_rrr-1011000000000000
  //FTST.L <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0100000000111010
  //FMOVE.L <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000000
  //FINT.L <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000001
  //FSINH.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000010
  //FINTRZ.L <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000011
  //FSQRT.L <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000100
  //FLOGNP1.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0000110
  //FETOXM1.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001000
  //FTANH.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001001
  //FATAN.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001010
  //FASIN.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001100
  //FATANH.L <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001101
  //FSIN.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001110
  //FTAN.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0001111
  //FETOX.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010000
  //FTWOTOX.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010001
  //FTENTOX.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010010
  //FLOGN.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010100
  //FLOG10.L <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010101
  //FLOG2.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0010110
  //FABS.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011000
  //FCOSH.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011001
  //FNEG.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011010
  //FACOS.L <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011100
  //FCOS.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011101
  //FGETEXP.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011110
  //FGETMAN.L <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0011111
  //FDIV.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100000
  //FMOD.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100001
  //FADD.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100010
  //FMUL.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100011
  //FSGLDIV.L <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100100
  //FREM.L <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100101
  //FSCALE.L <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100110
  //FSGLMUL.L <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0100111
  //FSUB.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0101000
  //FCMP.L <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn0111000
  //FSMOVE.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000000
  //FSSQRT.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000001
  //FDMOVE.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000100
  //FDSQRT.L <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1000101
  //FSABS.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011000
  //FSNEG.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011010
  //FDABS.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011100
  //FDNEG.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1011110
  //FSDIV.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100000
  //FSADD.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100010
  //FSMUL.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100011
  //FDDIV.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100100
  //FDADD.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100110
  //FDMUL.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1100111
  //FSSUB.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1101000
  //FDSUB.L <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000nnn1101100
  //FSINCOS.L <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010000sss0110ccc
  //FTST.S <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0100010000111010
  //FMOVE.S <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000000
  //FINT.S <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000001
  //FSINH.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000010
  //FINTRZ.S <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000011
  //FSQRT.S <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000100
  //FLOGNP1.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0000110
  //FETOXM1.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001000
  //FTANH.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001001
  //FATAN.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001010
  //FASIN.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001100
  //FATANH.S <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001101
  //FSIN.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001110
  //FTAN.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0001111
  //FETOX.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010000
  //FTWOTOX.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010001
  //FTENTOX.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010010
  //FLOGN.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010100
  //FLOG10.S <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010101
  //FLOG2.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0010110
  //FABS.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011000
  //FCOSH.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011001
  //FNEG.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011010
  //FACOS.S <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011100
  //FCOS.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011101
  //FGETEXP.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011110
  //FGETMAN.S <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0011111
  //FDIV.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100000
  //FMOD.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100001
  //FADD.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100010
  //FMUL.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100011
  //FSGLDIV.S <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100100
  //FREM.S <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100101
  //FSCALE.S <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100110
  //FSGLMUL.S <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0100111
  //FSUB.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0101000
  //FCMP.S <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn0111000
  //FSMOVE.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000000
  //FSSQRT.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000001
  //FDMOVE.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000100
  //FDSQRT.S <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1000101
  //FSABS.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011000
  //FSNEG.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011010
  //FDABS.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011100
  //FDNEG.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1011110
  //FSDIV.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100000
  //FSADD.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100010
  //FSMUL.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100011
  //FDDIV.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100100
  //FDADD.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100110
  //FDMUL.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1100111
  //FSSUB.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1101000
  //FDSUB.S <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001nnn1101100
  //FSINCOS.S <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010001sss0110ccc
  //FTST.W <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0101000000111010
  //FMOVE.W <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000000
  //FINT.W <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000001
  //FSINH.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000010
  //FINTRZ.W <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000011
  //FSQRT.W <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000100
  //FLOGNP1.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0000110
  //FETOXM1.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001000
  //FTANH.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001001
  //FATAN.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001010
  //FASIN.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001100
  //FATANH.W <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001101
  //FSIN.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001110
  //FTAN.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0001111
  //FETOX.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010000
  //FTWOTOX.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010001
  //FTENTOX.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010010
  //FLOGN.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010100
  //FLOG10.W <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010101
  //FLOG2.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0010110
  //FABS.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011000
  //FCOSH.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011001
  //FNEG.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011010
  //FACOS.W <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011100
  //FCOS.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011101
  //FGETEXP.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011110
  //FGETMAN.W <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0011111
  //FDIV.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100000
  //FMOD.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100001
  //FADD.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100010
  //FMUL.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100011
  //FSGLDIV.W <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100100
  //FREM.W <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100101
  //FSCALE.W <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100110
  //FSGLMUL.W <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0100111
  //FSUB.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0101000
  //FCMP.W <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn0111000
  //FSMOVE.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000000
  //FSSQRT.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000001
  //FDMOVE.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000100
  //FDSQRT.W <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1000101
  //FSABS.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011000
  //FSNEG.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011010
  //FDABS.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011100
  //FDNEG.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1011110
  //FSDIV.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100000
  //FSADD.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100010
  //FSMUL.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100011
  //FDDIV.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100100
  //FDADD.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100110
  //FDMUL.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1100111
  //FSSUB.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1101000
  //FDSUB.W <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100nnn1101100
  //FSINCOS.W <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010100sss0110ccc
  //FTST.B <ea>                                     |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-0101100000111010
  //FMOVE.B <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000000
  //FINT.B <ea>,FPn                                 |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000001
  //FSINH.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000010
  //FINTRZ.B <ea>,FPn                               |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000011
  //FSQRT.B <ea>,FPn                                |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000100
  //FLOGNP1.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0000110
  //FETOXM1.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001000
  //FTANH.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001001
  //FATAN.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001010
  //FASIN.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001100
  //FATANH.B <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001101
  //FSIN.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001110
  //FTAN.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0001111
  //FETOX.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010000
  //FTWOTOX.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010001
  //FTENTOX.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010010
  //FLOGN.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010100
  //FLOG10.B <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010101
  //FLOG2.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0010110
  //FABS.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011000
  //FCOSH.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011001
  //FNEG.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011010
  //FACOS.B <ea>,FPn                                |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011100
  //FCOS.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011101
  //FGETEXP.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011110
  //FGETMAN.B <ea>,FPn                              |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0011111
  //FDIV.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100000
  //FMOD.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100001
  //FADD.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100010
  //FMUL.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100011
  //FSGLDIV.B <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100100
  //FREM.B <ea>,FPn                                 |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100101
  //FSCALE.B <ea>,FPn                               |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100110
  //FSGLMUL.B <ea>,FPn                              |-|--CCS6|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0100111
  //FSUB.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0101000
  //FCMP.B <ea>,FPn                                 |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn0111000
  //FSMOVE.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000000
  //FSSQRT.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000001
  //FDMOVE.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000100
  //FDSQRT.B <ea>,FPn                               |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1000101
  //FSABS.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011000
  //FSNEG.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011010
  //FDABS.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011100
  //FDNEG.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1011110
  //FSDIV.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100000
  //FSADD.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100010
  //FSMUL.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100011
  //FDDIV.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100100
  //FDADD.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100110
  //FDMUL.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1100111
  //FSSUB.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1101000
  //FDSUB.B <ea>,FPn                                |-|----46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110nnn1101100
  //FSINCOS.B <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-010110sss0110ccc
  //FMOVE.L <ea>,FPIAR                              |-|--CC46|-|-----|-----|DAM+-WXZPI|1111_001_000_mmm_rrr-1000010000000000
  //FMOVEM.L <ea>,FPIAR                             |-|--CC46|-|-----|-----|DAM+-WXZPI|1111_001_000_mmm_rrr-1000010000000000
  //FMOVE.L <ea>,FPSR                               |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1000100000000000
  //FMOVEM.L <ea>,FPSR                              |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1000100000000000
  //FMOVE.L <ea>,FPCR                               |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1001000000000000
  //FMOVEM.L <ea>,FPCR                              |-|--CC46|-|-----|-----|D M+-WXZPI|1111_001_000_mmm_rrr-1001000000000000
  //FMOVE.X FPn,<ea>                                |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011010nnn0000000
  //FMOVE.P FPn,<ea>{#k}                            |-|--CCSS|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011011nnnkkkkkkk
  //FMOVE.D FPn,<ea>                                |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011101nnn0000000
  //FMOVE.P FPn,<ea>{Dk}                            |-|--CCSS|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-011111nnnkkk0000
  //FMOVEM.L FPSR/FPIAR,<ea>                        |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1010110000000000
  //FMOVEM.L FPCR/FPIAR,<ea>                        |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1011010000000000
  //FMOVEM.L FPCR/FPSR,<ea>                         |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1011100000000000
  //FMOVEM.L FPCR/FPSR/FPIAR,<ea>                   |-|--CC46|-|-----|-----|  M+-WXZ  |1111_001_000_mmm_rrr-1011110000000000
  //FMOVEM.X #<data>,<ea>                           |-|--CC46|-|-----|-----|  M  WXZ  |1111_001_000_mmm_rrr-11110000dddddddd
  //FMOVEM.X <list>,<ea>                            |-|--CC46|-|-----|-----|  M  WXZ  |1111_001_000_mmm_rrr-11110000llllllll
  //FMOVEM.X Dl,<ea>                                |-|--CC4S|-|-----|-----|  M  WXZ  |1111_001_000_mmm_rrr-111110000lll0000
  //FMOVEM.L <ea>,FPSR/FPIAR                        |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1000110000000000
  //FMOVEM.L <ea>,FPCR/FPIAR                        |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1001010000000000
  //FMOVEM.L <ea>,FPCR/FPSR                         |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1001100000000000
  //FMOVEM.L <ea>,FPCR/FPSR/FPIAR                   |-|--CC46|-|-----|-----|  M+-WXZP |1111_001_000_mmm_rrr-1001110000000000
  //FMOVEM.X <ea>,#<data>                           |-|--CC46|-|-----|-----|  M+ WXZP |1111_001_000_mmm_rrr-11010000dddddddd
  //FMOVEM.X <ea>,<list>                            |-|--CC46|-|-----|-----|  M+ WXZP |1111_001_000_mmm_rrr-11010000llllllll
  //FMOVEM.X <ea>,Dl                                |-|--CC4S|-|-----|-----|  M+ WXZP |1111_001_000_mmm_rrr-110110000lll0000
  //FTST.X <ea>                                     |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-0100100000111010
  //FMOVE.X <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000000
  //FINT.X <ea>,FPn                                 |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000001
  //FSINH.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000010
  //FINTRZ.X <ea>,FPn                               |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000011
  //FSQRT.X <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000100
  //FLOGNP1.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0000110
  //FETOXM1.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001000
  //FTANH.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001001
  //FATAN.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001010
  //FASIN.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001100
  //FATANH.X <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001101
  //FSIN.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001110
  //FTAN.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0001111
  //FETOX.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010000
  //FTWOTOX.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010001
  //FTENTOX.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010010
  //FLOGN.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010100
  //FLOG10.X <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010101
  //FLOG2.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0010110
  //FABS.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011000
  //FCOSH.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011001
  //FNEG.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011010
  //FACOS.X <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011100
  //FCOS.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011101
  //FGETEXP.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011110
  //FGETMAN.X <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0011111
  //FDIV.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100000
  //FMOD.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100001
  //FADD.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100010
  //FMUL.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100011
  //FSGLDIV.X <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100100
  //FREM.X <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100101
  //FSCALE.X <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100110
  //FSGLMUL.X <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0100111
  //FSUB.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0101000
  //FCMP.X <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn0111000
  //FSMOVE.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000000
  //FSSQRT.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000001
  //FDMOVE.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000100
  //FDSQRT.X <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1000101
  //FSABS.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011000
  //FSNEG.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011010
  //FDABS.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011100
  //FDNEG.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1011110
  //FSDIV.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100000
  //FSADD.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100010
  //FSMUL.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100011
  //FDDIV.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100100
  //FDADD.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100110
  //FDMUL.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1100111
  //FSSUB.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1101000
  //FDSUB.X <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010nnn1101100
  //FSINCOS.X <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010010sss0110ccc
  //FTST.P <ea>                                     |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-0100110000111010
  //FMOVE.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000000
  //FINT.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000001
  //FSINH.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000010
  //FINTRZ.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000011
  //FSQRT.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000100
  //FLOGNP1.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0000110
  //FETOXM1.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001000
  //FTANH.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001001
  //FATAN.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001010
  //FASIN.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001100
  //FATANH.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001101
  //FSIN.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001110
  //FTAN.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0001111
  //FETOX.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010000
  //FTWOTOX.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010001
  //FTENTOX.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010010
  //FLOGN.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010100
  //FLOG10.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010101
  //FLOG2.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0010110
  //FABS.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011000
  //FCOSH.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011001
  //FNEG.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011010
  //FACOS.P <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011100
  //FCOS.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011101
  //FGETEXP.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011110
  //FGETMAN.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0011111
  //FDIV.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100000
  //FMOD.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100001
  //FADD.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100010
  //FMUL.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100011
  //FSGLDIV.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100100
  //FREM.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100101
  //FSCALE.P <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100110
  //FSGLMUL.P <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0100111
  //FSUB.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0101000
  //FCMP.P <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn0111000
  //FSMOVE.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000000
  //FSSQRT.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000001
  //FDMOVE.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000100
  //FDSQRT.P <ea>,FPn                               |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1000101
  //FSABS.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011000
  //FSNEG.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011010
  //FDABS.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011100
  //FDNEG.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1011110
  //FSDIV.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100000
  //FSADD.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100010
  //FSMUL.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100011
  //FDDIV.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100100
  //FDADD.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100110
  //FDMUL.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1100111
  //FSSUB.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1101000
  //FDSUB.P <ea>,FPn                                |-|----SS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011nnn1101100
  //FSINCOS.P <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010011sss0110ccc
  //FTST.D <ea>                                     |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-0101010000111010
  //FMOVE.D <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000000
  //FINT.D <ea>,FPn                                 |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000001
  //FSINH.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000010
  //FINTRZ.D <ea>,FPn                               |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000011
  //FSQRT.D <ea>,FPn                                |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000100
  //FLOGNP1.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0000110
  //FETOXM1.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001000
  //FTANH.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001001
  //FATAN.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001010
  //FASIN.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001100
  //FATANH.D <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001101
  //FSIN.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001110
  //FTAN.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0001111
  //FETOX.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010000
  //FTWOTOX.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010001
  //FTENTOX.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010010
  //FLOGN.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010100
  //FLOG10.D <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010101
  //FLOG2.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0010110
  //FABS.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011000
  //FCOSH.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011001
  //FNEG.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011010
  //FACOS.D <ea>,FPn                                |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011100
  //FCOS.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011101
  //FGETEXP.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011110
  //FGETMAN.D <ea>,FPn                              |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0011111
  //FDIV.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100000
  //FMOD.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100001
  //FADD.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100010
  //FMUL.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100011
  //FSGLDIV.D <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100100
  //FREM.D <ea>,FPn                                 |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100101
  //FSCALE.D <ea>,FPn                               |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100110
  //FSGLMUL.D <ea>,FPn                              |-|--CCS6|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0100111
  //FSUB.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0101000
  //FCMP.D <ea>,FPn                                 |-|--CC46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn0111000
  //FSMOVE.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000000
  //FSSQRT.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000001
  //FDMOVE.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000100
  //FDSQRT.D <ea>,FPn                               |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1000101
  //FSABS.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011000
  //FSNEG.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011010
  //FDABS.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011100
  //FDNEG.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1011110
  //FSDIV.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100000
  //FSADD.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100010
  //FSMUL.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100011
  //FDDIV.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100100
  //FDADD.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100110
  //FDMUL.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1100111
  //FSSUB.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1101000
  //FDSUB.D <ea>,FPn                                |-|----46|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101nnn1101100
  //FSINCOS.D <ea>,FPc:FPs                          |-|--CCSS|-|-----|-----|  M+-WXZPI|1111_001_000_mmm_rrr-010101sss0110ccc
  //FMOVEM.X #<data>,-(Ar)                          |-|--CC46|-|-----|-----|    -     |1111_001_000_100_rrr-11100000dddddddd
  //FMOVEM.X <list>,-(Ar)                           |-|--CC46|-|-----|-----|    -     |1111_001_000_100_rrr-11100000llllllll
  //FMOVEM.X Dl,-(Ar)                               |-|--CC4S|-|-----|-----|    -     |1111_001_000_100_rrr-111010000lll0000
  //FMOVEM.L #<data>,#<data>,FPSR/FPIAR             |-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1000110000000000-{data}
  //FMOVEM.L #<data>,#<data>,FPCR/FPIAR             |-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1001010000000000-{data}
  //FMOVEM.L #<data>,#<data>,FPCR/FPSR              |-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1001100000000000-{data}
  //FMOVEM.L #<data>,#<data>,#<data>,FPCR/FPSR/FPIAR|-|--CC4S|-|-----|-----|         I|1111_001_000_111_100-1001110000000000-{data}
  @SuppressWarnings ("fallthrough") public static void irpFgen () throws M68kException {
  fgen: {
    if (XEiJ.currentMPU == Model.MPU_MC68LC060) {
      irpFline ();
      break fgen;
    }
    XEiJ.mpuCycleCount++;
    int ea = XEiJ.regOC & 63;
    int a = XEiJ.regPC;
    XEiJ.regPC = a + 2;
    int w = mmuReadWordZeroExword (a, XEiJ.regSRS);  //pcwz。拡張ワード
    int m = w >> 10 & 7;
    int n = w >> 7 & 7;
    int c = w & 0x7f;
    XEiJ.fpuBox.epbSetRoundingPrec (XEiJ.fpuBox.epbFpcr >> 6 & 3);  //丸め桁数
    XEiJ.fpuBox.epbSetRoundingMode (XEiJ.fpuBox.epbFpcr >> 4 & 3);  //丸めモード
    a = 0;  //実効アドレス
    //XEiJ.fpuBox.epbExceptionStatusWord = 0;


    switch (w >> 13) {


    case 0b010:  //$4xxx-$5xxx: Fop.* <ea>,FPn
      XEiJ.fpuBox.epbFpsr &= 0x00ff00ff;
      XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される

      switch (m) {

      case 0b000:  //$40xx-$43xx: Fop.L <ea>,FPn
        {
          XEiJ.mpuCycleCount += 3;
          int i;
          if (ea < XEiJ.EA_AR) {  //Dr
            XEiJ.mpuCycleCount += 2;
            //a = 0;
            i = XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 4;
            i = mmuReadLongExword (a, XEiJ.regSRS);  //pcls
          } else {  //Dr,#<data>以外
            a = efaAnyLong (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
          }
          XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].seti (i);
        }
        break;

      case 0b001:  //$44xx-$47xx: Fop.S <ea>,FPn
        {
          int i;
          if (ea < XEiJ.EA_AR) {  //Dr
            XEiJ.mpuCycleCount += 2;
            //a = 0;
            i = XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 4;
            i = mmuReadLongExword (a, XEiJ.regSRS);  //pcls
          } else {  //Dr,#<data>以外
            a = efaAnyLong (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
          }
          XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].setf0 (i);
        }
        break;

      case 0b010:  //$48xx-$4Bxx: Fop.X <ea>,FPn
        {
          int i;
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //12バイトのイミディエイト
              irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
              break fgen;
            }
            a = XEiJ.regPC;
            XEiJ.regPC = a + 12;
            i = mmuReadLongExword (a, XEiJ.regSRS);
            l = mmuReadQuadExword (a + 4, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyExtd (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
            l = mmuReadQuadSecond (a + 4, XEiJ.regSRS);
          }
          if (XEiJ.fpuBox.epbIsTriple ()) {  //三倍精度
            XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].sety012 (i, l);
          } else {  //拡張精度
            XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].setx012 (i, l);
          }
        }
        break;

      case 0b011:  //$4Cxx-$4Fxx: Fop.P <ea>,FPn
        {
          int i;
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //12バイトのイミディエイト
              irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
              break fgen;
            }
            a = XEiJ.regPC;
            XEiJ.regPC = a + 12;
            i = mmuReadLongExword (a, XEiJ.regSRS);
            l = mmuReadQuadExword (a + 4, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyExtd (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
            l = mmuReadQuadSecond (a + 4, XEiJ.regSRS);
          }
          if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //パックトデシマル
            XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | M68kException.M6E_FP_UNSUPPORTED_DATA_TYPE & 7;
            irpExceptionFormat2 (M68kException.M6E_FP_UNSUPPORTED_DATA_TYPE << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスはソースオペランド
            break fgen;
          }
          XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].setp012 (i, l);
        }
        break;

      case 0b100:  //$50xx-$53xx: Fop.W <ea>,FPn
        {
          XEiJ.mpuCycleCount += 3;
          int i;
          if (ea < XEiJ.EA_AR) {  //Dr
            XEiJ.mpuCycleCount += 2;
            //a = 0;
            i = (short) XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 2;
            i = mmuReadWordSignExword (a, XEiJ.regSRS);  //pcws
          } else {  //Dr,#<data>以外
            a = efaAnyWord (ea);
            i = mmuReadWordSignData (a, XEiJ.regSRS);
          }
          XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].seti (i);
        }
        break;

      case 0b101:  //$54xx-$57xx: Fop.D <ea>,FPn
        {
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 8;
            l = mmuReadQuadExword (a, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyQuad (ea);
            l = mmuReadQuadData (a, XEiJ.regSRS);
          }
          XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].setd01 (l);
        }
        break;

      case 0b110:  //$58xx-$5Bxx: Fop.B <ea>,FPn
        {
          XEiJ.mpuCycleCount += 3;
          int i;
          if (ea < XEiJ.EA_AR) {  //Dr
            XEiJ.mpuCycleCount += 2;
            //a = 0;
            i = (byte) XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 2;
            i = mmuReadByteSignExword (a + 1, XEiJ.regSRS);  //pcbs
          } else {  //Dr,#<data>以外
            a = efaAnyByte (ea);
            i = mmuReadByteSignData (a, XEiJ.regSRS);
          }
          XEiJ.fpuFPn[m = EFPBox.EPB_SRC_TMP].seti (i);
        }
        break;

      case 0b111:  //$5Cxx-$5Fxx: FMOVECR.X #ccc,FPn
      default:
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2);  //pcは次の命令,アドレスはベクタオフセット
          break fgen;
        }
        if (0x40 <= c) {
          //マニュアルにはFMOVECRの命令フォーマットのROMオフセットが7bitあるように書かれているが実際は6bit
          //MC68882で0x40以上を指定すると命令実行前例外のF-Line Emulator(レスポンス$1C0B)が返る
          XEiJ.regPC = XEiJ.regPC0 + 2;  //拡張ワードを読まなかったことにする
          irpFline ();
          break fgen;
        }
        if (false) {
          m = EFPBox.EPB_CONST_START + c;  //定数
          c = 0;  //FMOVE
        } else {
          //FMOVECR
          XEiJ.fpuBox.epbFmovecr (XEiJ.fpuFPn[n], c);
          //FPSRのAEXCを設定する
          XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_TO_AEXC[XEiJ.fpuBox.epbFpsr >> 8 & 255];
          //浮動小数点命令実行後例外 floating-point post-instruction exception
          if (irpFPPostInstruction (a)) {
            break fgen;
          }
          break fgen;
        }

      }
      //浮動小数点命令実行前例外 floating-point pre-instruction exception
      if (irpFPPreInstruction ()) {
        break fgen;
      }
      //Fop.X <ea>,FPn → Fop.X FP[EFPBox.EPB_SRC_TMP],FPn
      //FMOVECR.X #ccc,FPn → FMOVE.X FPc,FPn


      //fallthrough
    case 0b000:  //$0xxx-$1xxx: Fop.X FPm,FPn
      if (w >> 13 == 0) {
        XEiJ.fpuBox.epbFpsr &= 0x00ff00ff;
      }
      //Fop.* <ea>,FPnのときFPIARは設定済み
      XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される

      switch (c) {

      case 0b000_0000:  //$xx00: FMOVE.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuFPn[n].sete (XEiJ.fpuFPn[m]).finish ();
        break;

      case 0b000_0001:  //$xx01: FINT.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //         正規化数の最大値は整数なので丸めても大きくなることはない
        //  UNFL   常にクリア
        //         結果は整数なので非正規化数にはならない
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        //  FINTはsingleとdoubleの丸め処理を行わない
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_EXD);
        XEiJ.fpuFPn[n].round (XEiJ.fpuFPn[m], XEiJ.fpuBox.epbRoundingMode);
        break;

      case 0b000_0010:  //$xx02: FSINH.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].sinh (XEiJ.fpuFPn[m]);
        break;

      case 0b000_0011:  //$xx03: FINTRZ.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //         結果は整数なので非正規化数にはならない
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        //  FINTRZはsingleとdoubleの丸め処理を行わない
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_EXD);
        XEiJ.fpuFPn[n].trunc (XEiJ.fpuFPn[m]);
        break;

      case 0b000_0100:  //$xx04: FSQRT.* *m,FPn
      case 0b000_0101:  //$xx05: FSQRT.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が-0を除く負数のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //         1よりも大きい数は小さくなるので溢れることはない
        //  UNFL   常にクリア
        //         非正規化数の平方根は正規化数なので結果が非正規化数になることはない
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 67;
        XEiJ.fpuFPn[n].sqrt (XEiJ.fpuFPn[m]);
        break;

      case 0b000_0110:  //$xx06: FLOGNP1.* *m,FPn
      case 0b000_0111:  //$xx07: FLOGNP1.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が-1よりも小さいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //         log(1+0)=0,log(1+x)<=xなので結果が引数よりも大きくなることはない
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     引数が-1のときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].log1p (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1000:  //$xx08: FETOXM1.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].expm1 (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1001:  //$xx09: FTANH.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].tanh (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1010:  //$xx0A: FATAN.* *m,FPn
      case 0b000_1011:  //$xx0B: FATAN.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].atan (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1100:  //$xx0C: FASIN.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の絶対値が1よりも大きいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].asin (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1101:  //$xx0D: FATANH.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の絶対値が1よりも大きいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //         1のとき無限大なのだから1の近くでオーバーフローしそうに思えるがatanh(1-2^-80)≒28.07くらい
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     引数の絶対値が1のときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].atanh (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1110:  //$xx0E: FSIN.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].sin (XEiJ.fpuFPn[m]);
        break;

      case 0b000_1111:  //$xx0F: FTAN.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //         cos(x)=0を満たすxは正確に表現できないのだからsin(x)/cos(x)がゼロ除算になるのはおかしい
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].tan (XEiJ.fpuFPn[m]);
        break;

      case 0b001_0000:  //$xx10: FETOX.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].exp (XEiJ.fpuFPn[m]);
        break;

      case 0b001_0001:  //$xx11: FTWOTOX.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].exp2 (XEiJ.fpuFPn[m]);
        break;

      case 0b001_0010:  //$xx12: FTENTOX.* *m,FPn
      case 0b001_0011:  //$xx13: FTENTOX.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].exp10 (XEiJ.fpuFPn[m]);
        break;

      case 0b001_0100:  //$xx14: FLOGN.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が0よりも小さいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //         log(1)=0,log(x)<=x-1なので結果が引数よりも大きくなることはない
        //  UNFL   常にクリア
        //         log(1+2^-80)≒2^-80
        //  DZ     引数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].log (XEiJ.fpuFPn[m]);
        break;

      case 0b001_0101:  //$xx15: FLOG10.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が0よりも小さいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     引数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].log10 (XEiJ.fpuFPn[m]);
        break;

      case 0b001_0110:  //$xx16: FLOG2.* *m,FPn
      case 0b001_0111:  //$xx17: FLOG2.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が0よりも小さいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     引数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].log2 (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1000:  //$xx18: FABS.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuFPn[n].abs (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1001:  //$xx19: FCOSH.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].cosh (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1010:  //$xx1A: FNEG.* *m,FPn
      case 0b001_1011:  //$xx1B: FNEG.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuFPn[n].neg (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1100:  //$xx1C: FACOS.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の絶対値が1よりも大きいときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //         acos(1-ulp(1))はulp(1)よりも大きい
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //         おそらくセットされないのはacos(1)=0だけ
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].acos (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1101:  //$xx1D: FCOS.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //         cos(x)=0を満たすxは正確に表現できず、cos(pi/2)とcos(3*pi/2)が正規化数になってしまう
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].cos (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1110:  //$xx1E: FGETEXP.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].getexp (XEiJ.fpuFPn[m]);
        break;

      case 0b001_1111:  //$xx1F: FGETMAN.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].getman (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0000:  //$xx20: FDIV.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方ゼロまたは両方無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     被除数がゼロ、無限大、NaN以外で除数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 36;
        XEiJ.fpuFPn[n].div (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0001:  //$xx21: FMOD.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  除数がゼロまたは被除数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //         除数がゼロのとき結果は無限大ではなくNaNでありゼロ除算にはならない
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        //  FPSRのquotient byteに符号付き商の下位7bitが入る
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].rem (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0010:  //$xx22: FADD.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方無限大で符号が異なるときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuFPn[n].add (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0011:  //$xx23: FMUL.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の一方がゼロで他方が無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuFPn[n].mul (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0100:  //$xx24: FSGLDIV.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方ゼロまたは両方無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     被除数がゼロ、無限大、NaN以外で除数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 36;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_XSG);
        XEiJ.fpuFPn[n].div (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0101:  //$xx25: FREM.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  除数がゼロまたは被除数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //         除数がゼロのとき結果は無限大ではなくNaNでありゼロ除算にはならない
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //         マニュアルにClearedと書いてあるのは間違い
        //         除数が無限大で被除数をそのまま返す場合でもサイズが減ればアンダーフローや不正確な結果になることはマニュアルにも書かれている
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        //  FPSRのquotient byteに符号付き商の下位7bitが入る
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        XEiJ.fpuFPn[n].ieeerem (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0110:  //$xx26: FSCALE.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        //! 本来はソースが整数のとき浮動小数点数を経由しないが、これは経由してしまっている。結果は同じだが効率が悪い
        XEiJ.fpuFPn[n].scale (XEiJ.fpuFPn[m]);
        break;

      case 0b010_0111:  //$xx27: FSGLMUL.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の一方がゼロで他方が無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        {
          //引数を24bitに切り捨てるときX2をセットしない
          int sr = XEiJ.fpuBox.epbFpsr;
          XEiJ.fpuFPn[EFPBox.EPB_SRC_TMP].roundmanf (XEiJ.fpuFPn[m], EFPBox.EPB_MODE_RZ);
          XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].roundmanf (XEiJ.fpuFPn[n], EFPBox.EPB_MODE_RZ);
          XEiJ.fpuBox.epbFpsr = sr;
        }
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_XSG);
        XEiJ.fpuFPn[n].mul (XEiJ.fpuFPn[EFPBox.EPB_DST_TMP], XEiJ.fpuFPn[EFPBox.EPB_SRC_TMP]);
        break;

      case 0b010_1000:  //$xx28: FSUB.* *m,FPn
      case 0b010_1001:  //$xx29: FSUB.* *m,FPn (MC68882)
      case 0b010_1010:  //$xx2A: FSUB.* *m,FPn (MC68882)
      case 0b010_1011:  //$xx2B: FSUB.* *m,FPn (MC68882)
      case 0b010_1100:  //$xx2C: FSUB.* *m,FPn (MC68882)
      case 0b010_1101:  //$xx2D: FSUB.* *m,FPn (MC68882)
      case 0b010_1110:  //$xx2E: FSUB.* *m,FPn (MC68882)
      case 0b010_1111:  //$xx2F: FSUB.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方無限大で符号が同じときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuFPn[n].sub (XEiJ.fpuFPn[m]);
        break;

      case 0b011_0000:  //$xx30: FSINCOS.* *m,FP0:FPn (c=0,s=n)
      case 0b011_0001:  //$xx31: FSINCOS.* *m,FP1:FPn (c=1,s=n)
      case 0b011_0010:  //$xx32: FSINCOS.* *m,FP2:FPn (c=2,s=n)
      case 0b011_0011:  //$xx33: FSINCOS.* *m,FP3:FPn (c=3,s=n)
      case 0b011_0100:  //$xx34: FSINCOS.* *m,FP4:FPn (c=4,s=n)
      case 0b011_0101:  //$xx35: FSINCOS.* *m,FP5:FPn (c=5,s=n)
      case 0b011_0110:  //$xx36: FSINCOS.* *m,FP6:FPn (c=6,s=n)
      case 0b011_0111:  //$xx37: FSINCOS.* *m,FP7:FPn (c=7,s=n)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が無限大のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   sin(x)の結果が非正規化数のときセット、それ以外はクリア
        //         cos(x)の結果は非正規化数にならない
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        if (!XEiJ.fpuBox.epbIsFullSpec ()) {
          irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
          break fgen;
        }
        c &= 7;
        //m==EFPBox.EPB_SRC_TMP||m==n||m==cの場合があることに注意する
        XEiJ.fpuFPn[EFPBox.EPB_SRC_TMP].sete (XEiJ.fpuFPn[m]);
        XEiJ.fpuFPn[c].cos (XEiJ.fpuFPn[EFPBox.EPB_SRC_TMP]);
        XEiJ.fpuFPn[n].sin (XEiJ.fpuFPn[EFPBox.EPB_SRC_TMP]);
        break;

      case 0b011_1000:  //$xx38: FCMP.* *m,FPn
      case 0b011_1001:  //$xx39: FCMP.* *m,FPn (MC68882)
      case 0b011_1100:  //$xx3C: FCMP.* *m,FPn (MC68882)  コマンドワードの不連続箇所に注意
      case 0b011_1101:  //$xx3D: FCMP.* *m,FPn (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        //  FCMPはinfinityを常にクリアする
        //  efp.compareTo(x,y)を使う
        //    efp.compareTo(x,y)はefp.sub(x,y)よりも速い
        //    efp.sub(x,y)はINEX2をセットしてしまう
        //  efp.compareTo(x,y)は-0<+0だがFCMPは-0==+0なのでこれだけ調節する
        {
          int xf = XEiJ.fpuFPn[n].flg;
          int yf = XEiJ.fpuFPn[m].flg;
          if ((xf | yf) << 3 < 0) {  //どちらかがNaN
            //XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].setnan ();
            XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].flg = EFPBox.N;
          } else {
            int i = ((xf & yf) << 1 < 0 ? 0 :  //両方±0
                     XEiJ.fpuFPn[n].compareTo (XEiJ.fpuFPn[m]));  //-Inf==-Inf<-x<-0<+0<+x<+Inf==+Inf<NaN==NaN
            if (i == 0) {
              if (xf < 0) {
                //XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].negset0 ();
                XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].flg = EFPBox.M | EFPBox.Z;
              } else {
                //XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].set0 ();
                XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].flg = EFPBox.P | EFPBox.Z;
              }
            } else if (i < 0) {
              XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].negset1 ();
            } else {
              XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].set1 ();
            }
          }
          n = EFPBox.EPB_DST_TMP;
        }
        break;

      case 0b011_1010:  //$xx3A: FTST.* *m
      case 0b011_1011:  //$xx3B: FTST.* *m (MC68882)
      case 0b011_1110:  //$xx3E: FTST.* *m (MC68882)  コマンドワードの不連続箇所に注意
      case 0b011_1111:  //$xx3F: FTST.* *m (MC68882)
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        //  ソースオペランドをダミーのデスティネーションオペランドにコピーしてテストする
        //  デスティネーションオペランドは変化しない
        //  デスティネーションオペランドにはFP0が指定される場合が多いがFP0である必要はない
        XEiJ.fpuFPn[EFPBox.EPB_DST_TMP].sete (XEiJ.fpuFPn[m]);
        n = EFPBox.EPB_DST_TMP;
        break;

      case 0b100_0000:  //$xx40: FSMOVE.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].sete (XEiJ.fpuFPn[m]).finish ();
        break;

      case 0b100_0001:  //$xx41: FSSQRT.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が-0を除く負数のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 67;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].sqrt (XEiJ.fpuFPn[m]);
        break;

        //case 0b100_0010:  //$xx42:
        //case 0b100_0011:  //$xx43:

      case 0b100_0100:  //$xx44: FDMOVE.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].sete (XEiJ.fpuFPn[m]).finish ();
        break;

      case 0b100_0101:  //$xx45: FDSQRT.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が-0を除く負数のときセット、それ以外はクリア
        //  OVFL   常にクリア
        //  UNFL   常にクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 67;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].sqrt (XEiJ.fpuFPn[m]);
        break;

        //case 0b100_0110:  //$xx46:
        //case 0b100_0111:  //$xx47:
        //case 0b100_1000:  //$xx48:
        //case 0b100_1001:  //$xx49:
        //case 0b100_1010:  //$xx4A:
        //case 0b100_1011:  //$xx4B:
        //case 0b100_1100:  //$xx4C:
        //case 0b100_1101:  //$xx4D:
        //case 0b100_1110:  //$xx4E:
        //case 0b100_1111:  //$xx4F:
        //case 0b101_0000:  //$xx50:
        //case 0b101_0001:  //$xx51:
        //case 0b101_0010:  //$xx52:
        //case 0b101_0011:  //$xx53:
        //case 0b101_0100:  //$xx54:
        //case 0b101_0101:  //$xx55:
        //case 0b101_0110:  //$xx56:
        //case 0b101_0111:  //$xx57:

      case 0b101_1000:  //$xx58: FSABS.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].abs (XEiJ.fpuFPn[m]);
        break;

        //case 0b101_1001:  //$xx59:

      case 0b101_1010:  //$xx5A: FSNEG.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].neg (XEiJ.fpuFPn[m]);
        break;

        //case 0b101_1011:  //$xx5B:

      case 0b101_1100:  //$xx5C: FDABS.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].abs (XEiJ.fpuFPn[m]);
        break;

        //case 0b101_1101:  //$xx5D:

      case 0b101_1110:  //$xx5E: FDNEG.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  常にクリア
        //  OVFL   常にクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  常にクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].neg (XEiJ.fpuFPn[m]);
        break;

        //case 0b101_1111:  //$xx5F:

      case 0b110_0000:  //$xx60: FSDIV.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方ゼロまたは両方無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     被除数がゼロ、無限大、NaN以外で除数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 36;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].div (XEiJ.fpuFPn[m]);
        break;

        //case 0b110_0001:  //$xx61:

      case 0b110_0010:  //$xx62: FSADD.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方無限大で符号が異なるときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].add (XEiJ.fpuFPn[m]);
        break;

      case 0b110_0011:  //$xx63: FSMUL.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の一方がゼロで他方が無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].mul (XEiJ.fpuFPn[m]);
        break;

      case 0b110_0100:  //$xx64: FDDIV.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方ゼロまたは両方無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     被除数がゼロ、無限大、NaN以外で除数がゼロのときセット、それ以外はクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 36;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].div (XEiJ.fpuFPn[m]);
        break;

        //case 0b110_0101:  //$xx65:

      case 0b110_0110:  //$xx66: FDADD.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方無限大で符号が異なるときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].add (XEiJ.fpuFPn[m]);
        break;

      case 0b110_0111:  //$xx67: FDMUL.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数の一方がゼロで他方が無限大のときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].mul (XEiJ.fpuFPn[m]);
        break;

      case 0b110_1000:  //$xx68: FSSUB.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方無限大で符号が同じときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_SGL);
        XEiJ.fpuFPn[n].sub (XEiJ.fpuFPn[m]);
        break;

        //case 0b110_1001:  //$xx69:
        //case 0b110_1010:  //$xx6A:
        //case 0b110_1011:  //$xx6B:

      case 0b110_1100:  //$xx6C: FDSUB.* *m,FPn
        //  BSUN   常にクリア
        //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
        //  OPERR  引数が両方無限大で符号が同じときセット、それ以外はクリア
        //  OVFL   オーバーフローしたときセット、それ以外はクリア
        //  UNFL   結果が非正規化数のときセット、それ以外はクリア
        //  DZ     常にクリア
        //  INEX2  結果に誤差があるときセット、それ以外はクリア
        //  INEX1  引数がpackedで正確に変換できないときセット、それ以外はクリア
        XEiJ.mpuCycleCount += 2;
        XEiJ.fpuBox.epbSetRoundingPrec (EFPBox.EPB_PREC_DBL);
        XEiJ.fpuFPn[n].sub (XEiJ.fpuFPn[m]);
        break;

        //case 0b110_1101:  //$xx6D:
        //case 0b110_1110:  //$xx6E:
        //case 0b110_1111:  //$xx6F:

      case 0b111_0000:  //$xx70: FLGAMMA *m,FPn
        if (EFPBox.EPB_EXTRA_OPERATION) {
          XEiJ.fpuFPn[n].lgamma (XEiJ.fpuFPn[m]);
          break;
        } else {
          XEiJ.regPC = XEiJ.regPC0 + 2;  //拡張ワードを読まなかったことにする
          irpFline ();
          break fgen;
        }

      case 0b111_0001:  //$xx71: FTGAMMA *m,FPn
        if (EFPBox.EPB_EXTRA_OPERATION) {
          XEiJ.fpuFPn[n].tgamma (XEiJ.fpuFPn[m]);
          break;
        } else {
          XEiJ.regPC = XEiJ.regPC0 + 2;  //拡張ワードを読まなかったことにする
          irpFline ();
          break fgen;
        }

        //case 0b111_0010:  //$xx72:
        //case 0b111_0011:  //$xx73:
        //case 0b111_0100:  //$xx74:
        //case 0b111_0101:  //$xx75:
        //case 0b111_0110:  //$xx76:
        //case 0b111_0111:  //$xx77:
        //case 0b111_1000:  //$xx78:
        //case 0b111_1001:  //$xx79:
        //case 0b111_1010:  //$xx7A:
        //case 0b111_1011:  //$xx7B:
        //case 0b111_1100:  //$xx7C:
        //case 0b111_1101:  //$xx7D:
        //case 0b111_1110:  //$xx7E:
        //case 0b111_1111:  //$xx7F:

      default:  //未定義
        XEiJ.regPC = XEiJ.regPC0 + 2;  //拡張ワードを読まなかったことにする
        irpFline ();
        break fgen;
      }
      //FPSRのFPCCを設定する
      XEiJ.fpuBox.epbFpsr |= XEiJ.fpuFPn[n].flg >>> 4;
      //FPSRのAEXCを設定する
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_TO_AEXC[XEiJ.fpuBox.epbFpsr >> 8 & 255];
      //浮動小数点命令実行後例外 floating-point post-instruction exception
      if (irpFPPostInstruction (a)) {
        break fgen;
      }
      break fgen;


    case 0b011:  //$6xxx-$7xxx: FMOVE.* FPn,<ea>
      //  BSUN   常にクリア
      //  SNAN   引数がシグナリングNaNのときセット、それ以外はクリア
      //  OPERR  byte,word,longで無限大または指定されたサイズに収まらないとき、packedでk-factorが17よりも大きいか指数部が3桁に収まらないときセット、それ以外はクリア
      //  OVFL   packedではなくてオーバーフローしたときセット、それ以外はクリア
      //  UNFL   packedではなくて結果が非正規化数のときセット、それ以外はクリア
      //  DZ     常にクリア
      //  INEX2  結果に誤差があるときセット、それ以外はクリア
      //  INEX1  常にクリア
      XEiJ.fpuBox.epbFpsr &= 0xffff00ff;  //FMOVE.* FPn,<ea>でFPSRのコンディションコードバイトは変化しない
      XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される

      switch (m) {

      case 0b000:  //$60xx-$63xx: FMOVE.L FPn,<ea>
        {
          int i = XEiJ.fpuFPn[n].geti (XEiJ.fpuBox.epbRoundingMode);
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            XEiJ.regRn[ea] = i;
          } else {  //Dr以外
            a = efaMltLong (ea);
            mmuWriteLongData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b001:  //$64xx-$67xx: FMOVE.S FPn,<ea>
        {
          int i = XEiJ.fpuFPn[n].getf0 (XEiJ.fpuBox.epbRoundingMode);
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            XEiJ.regRn[ea] = i;
          } else {  //Dr以外
            a = efaMltLong (ea);
            mmuWriteLongData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b010:  //$68xx-$6Bxx: FMOVE.X FPn,<ea>
        {
          byte[] b = new byte[12];
          if (XEiJ.fpuBox.epbIsTriple ()) {  //三倍精度
            XEiJ.fpuFPn[n].gety012 (b, 0, XEiJ.fpuBox.epbRoundingMode);
          } else {  //拡張精度
            XEiJ.fpuFPn[n].getx012 (b, 0, XEiJ.fpuBox.epbRoundingMode);
          }
          a = efaMltExtd (ea);
          mmuWriteByteArray (a, b, 0, 12, XEiJ.regSRS);
        }
        break;

      case 0b011:  //$6Cxx-$6Fxx: FMOVE.P FPn,<ea>{#k}
        {
          a = efaMltExtd (ea);
          if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //パックトデシマル
            XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | M68kException.M6E_FP_UNSUPPORTED_DATA_TYPE & 7;
            irpExceptionFormat3 (M68kException.M6E_FP_UNSUPPORTED_DATA_TYPE << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスはデスティネーションオペランド
            break fgen;
          }
          byte[] b = new byte[12];
          XEiJ.fpuFPn[n].getp012 (b, 0, w);  //k-factor付き
          mmuWriteByteArray (a, b, 0, 12, XEiJ.regSRS);
        }
        break;

      case 0b100:  //$70xx-$73xx: FMOVE.W FPn,<ea>
        {
          int i = XEiJ.fpuFPn[n].gets (XEiJ.fpuBox.epbRoundingMode);
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            XEiJ.regRn[ea] = XEiJ.regRn[ea] & ~65535 | (char) i;
          } else {  //Dr以外
            a = efaMltWord (ea);
            mmuWriteWordData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b101:  //$74xx-$77xx: FMOVE.D FPn,<ea>
        {
          long l = XEiJ.fpuFPn[n].getd01 (XEiJ.fpuBox.epbRoundingMode);
          a = efaMltQuad (ea);
          mmuWriteQuadData (a, l, XEiJ.regSRS);
        }
        break;

      case 0b110:  //$78xx-$7Bxx: FMOVE.B FPn,<ea>
        {
          int i = XEiJ.fpuFPn[n].getb (XEiJ.fpuBox.epbRoundingMode);
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            XEiJ.regRn[ea] = XEiJ.regRn[ea] & ~255 | i & 255;
          } else {  //Dr以外
            a = efaMltByte (ea);
            mmuWriteByteData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b111:  //$7Cxx-$7Fxx: FMOVE.P FPn,<ea>{Dl}
      default:
        {
          a = efaMltExtd (ea);
          if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //パックトデシマル
            XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | M68kException.M6E_FP_UNSUPPORTED_DATA_TYPE & 7;
            irpExceptionFormat3 (M68kException.M6E_FP_UNSUPPORTED_DATA_TYPE << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスはデスティネーションオペランド
            break fgen;
          }
          byte[] b = new byte[12];
          XEiJ.fpuFPn[n].getp012 (b, 0, XEiJ.regRn[w >> 4 & 7]);  //k-factor付き
          mmuWriteByteArray (a, b, 0, 12, XEiJ.regSRS);
        }
      }
      //FPSRのAEXCを設定する
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_TO_AEXC[XEiJ.fpuBox.epbFpsr >> 8 & 255];
      //浮動小数点命令実行後例外 floating-point post-instruction exception
      if (irpFPPostInstruction (a)) {
        break fgen;
      }
      break fgen;


    case 0b100:  //$8xxx-$9xxx: FMOVEM.L <ea>,FPCR/FPSR/FPIAR
      XEiJ.mpuCycleCount += 6;
      //  FMOVEM命令は例外を発生させずFPCR/FPSR/FPIARも(デスティネーションに書かれたもの以外)変化しない
      //  格納順序はFPCRが下位アドレス(連結したとき上位),FPIARが上位アドレス(連結したとき下位)

      switch (m) {

      case 0b000:  //$8000: FMOVE.L <ea>,<>
        //  レジスタを1個も指定しないとFPIARが指定されたものとみなされる

      case 0b001:  //$8400: FMOVE.L <ea>,FPIAR
        {
          int i;
          if (ea < XEiJ.EA_MM) {  //Dr,Ar。Ar可
            //a = 0;
            i = XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 4;
            i = mmuReadLongExword (a, XEiJ.regSRS);  //pcls
          } else {  //Dr,Ar,#<data>以外
            a = efaAnyLong (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpiar = i;
        }
        break;

      case 0b010:  //$8800: FMOVE.L <ea>,FPSR
        {
          int i;
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            //a = 0;
            i = XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 4;
            i = mmuReadLongExword (a, XEiJ.regSRS);  //pcls
          } else {  //Dr,#<data>以外
            a = efaAnyLong (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpsr = i & EFPBox.EPB_FPSR_ALL;
          //  fmove.lでfpsrのEXCに書き込んだだけではAEXCは更新されない
          //  fmove.lでfpsrに0x0000ff00を書き込んですぐに読み出しても0x0000ff00のまま
        }
        break;

      case 0b011:  //$8C00: FMOVEM.L <ea>,FPSR/FPIAR
        {
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //8バイトのイミディエイト
              irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
              break fgen;
            }
            a = XEiJ.regPC;
            XEiJ.regPC = a + 8;
            l = mmuReadQuadExword (a, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyQuad (ea);
            l = mmuReadQuadData (a, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpsr = (int) (l >>> 32) & EFPBox.EPB_FPSR_ALL;
          XEiJ.fpuBox.epbFpiar = (int) l;
        }
        break;

      case 0b100:  //$9000: FMOVE.L <ea>,FPCR
        {
          int i;
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            a = 0;
            i = XEiJ.regRn[ea];
          } else if (ea == XEiJ.EA_IM) {  //#<data>
            a = XEiJ.regPC;
            XEiJ.regPC = a + 4;
            i = mmuReadLongExword (a, XEiJ.regSRS);  //pcls
          } else {  //Dr,#<data>以外
            a = efaAnyLong (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpcr = i & EFPBox.EPB_FPCR_ALL;
        }
        break;

      case 0b101:  //$9400: FMOVEM.L <ea>,FPCR/FPIAR
        {
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //8バイトのイミディエイト
              irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
              break fgen;
            }
            a = XEiJ.regPC;
            XEiJ.regPC = a + 8;
            l = mmuReadQuadExword (a, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyQuad (ea);
            l = mmuReadQuadData (a, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpcr = (int) (l >>> 32) & EFPBox.EPB_FPCR_ALL;
          XEiJ.fpuBox.epbFpiar = (int) l;
        }
        break;

      case 0b110:  //$9800: FMOVEM.L <ea>,FPCR/FPSR
        {
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //8バイトのイミディエイト
              irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
              break fgen;
            }
            a = XEiJ.regPC;
            XEiJ.regPC = a + 8;
            l = mmuReadQuadExword (a, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyQuad (ea);
            l = mmuReadQuadData (a, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpcr = (int) (l >>> 32) & EFPBox.EPB_FPCR_ALL;
          XEiJ.fpuBox.epbFpsr = (int) l & EFPBox.EPB_FPSR_ALL;
        }
        break;

      case 0b111:  //$9C00: FMOVEM.L <ea>,FPCR/FPSR/FPIAR
      default:
        {
          int i;
          long l;
          if (ea == XEiJ.EA_IM) {  //#<data>
            if (!XEiJ.fpuBox.epbIsFullSpec ()) {  //12バイトのイミディエイト
              irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
              break fgen;
            }
            a = XEiJ.regPC;
            XEiJ.regPC = a + 12;
            i = mmuReadLongExword (a, XEiJ.regSRS);
            l = mmuReadQuadExword (a + 4, XEiJ.regSRS);
          } else {  //#<data>以外
            a = efaAnyExtd (ea);
            i = mmuReadLongData (a, XEiJ.regSRS);
            l = mmuReadQuadSecond (a + 4, XEiJ.regSRS);
          }
          XEiJ.fpuBox.epbFpcr = i & EFPBox.EPB_FPCR_ALL;
          XEiJ.fpuBox.epbFpsr = (int) (l >>> 32) & EFPBox.EPB_FPSR_ALL;
          XEiJ.fpuBox.epbFpiar = (int) l;
        }
        break;
      }
      break fgen;


    case 0b101:  //$Axxx-$Bxxx: FMOVEM.L FPCR/FPSR/FPIAR,<ea>
      //  FMOVEM命令は例外を発生させずFPCR/FPSR/FPIARも(デスティネーションに書かれたもの以外)変化しない
      XEiJ.mpuCycleCount += 4;

      switch (m) {

      case 0b000:  //$A000: FMOVE.L <>,<ea>
        //  レジスタを1個も指定しないとFPIARが指定されたものとみなされる

      case 0b001:  //$A400: FMOVE.L FPIAR,<ea>
        {
          int i = XEiJ.fpuBox.epbFpiar;
          if (ea < XEiJ.EA_MM) {  //Dr,Ar。Ar可
            //a = 0;
            XEiJ.regRn[ea] = i;
          } else {  //Dr,Ar以外
            a = efaMltLong (ea);
            mmuWriteLongData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b010:  //$A800: FMOVE.L FPSR,<ea>
        {
          int i = XEiJ.fpuBox.epbFpsr;
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            //a = 0;
            XEiJ.regRn[ea] = i;
          } else {  //Dr以外
            a = efaMltLong (ea);
            mmuWriteLongData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b011:  //$AC00: FMOVEM.L FPSR/FPIAR,<ea>
        {
          long l = (long) XEiJ.fpuBox.epbFpsr << 32 | XEiJ.fpuBox.epbFpiar & 0xffffffffL;
          a = efaMltQuad (ea);
          mmuWriteQuadData (a, l, XEiJ.regSRS);
        }
        break;

      case 0b100:  //$B000: FMOVE.L FPCR,<ea>
        {
          int i = XEiJ.fpuBox.epbFpcr;
          if (ea < XEiJ.EA_AR) {  //Dr。Ar不可
            //a = 0;
            XEiJ.regRn[ea] = i;
          } else {  //Dr以外
            a = efaMltLong (ea);
            mmuWriteLongData (a, i, XEiJ.regSRS);
          }
        }
        break;

      case 0b101:  //$B400: FMOVEM.L FPCR/FPIAR,<ea>
        {
          long l = (long) XEiJ.fpuBox.epbFpcr << 32 | XEiJ.fpuBox.epbFpiar & 0xffffffffL;
          a = efaMltQuad (ea);
          mmuWriteQuadData (a, l, XEiJ.regSRS);
        }
        break;

      case 0b110:  //$B800: FMOVEM.L FPCR/FPSR,<ea>
        {
          long l = (long) XEiJ.fpuBox.epbFpcr << 32 | XEiJ.fpuBox.epbFpsr & 0xffffffffL;
          a = efaMltQuad (ea);
          mmuWriteQuadData (a, l, XEiJ.regSRS);
        }
        break;

      case 0b111:  //$BC00: FMOVEM.L FPCR/FPSR/FPIAR,<ea>
      default:
        {
          int i = XEiJ.fpuBox.epbFpcr;
          long l = (long) XEiJ.fpuBox.epbFpsr << 32 | XEiJ.fpuBox.epbFpiar & 0xffffffffL;
          a = efaMltExtd (ea);
          mmuWriteLongData (a, i, XEiJ.regSRS);
          mmuWriteQuadSecond (a + 4, l, XEiJ.regSRS);
        }
        break;
      }
      break fgen;


    case 0b110:  //$Cxxx-$Dxxx: FMOVEM.X <ea>,<list>
      //  FMOVEM命令は例外を発生させずFPCR/FPSR/FPIARも(デスティネーションに書かれたもの以外)変化しない
      {
        if ((m & 2) != 0 && !XEiJ.fpuBox.epbIsFullSpec ()) {  //動的レジスタリスト
          irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
          break fgen;
        }
        byte[] b = new byte[12];
        int list = ((m & 2) == 0 ? w : XEiJ.regRn[w >> 4 & 7]) << 24;
        if (ea >> 3 == XEiJ.MMM_MP) {  //(Ar)+
          int arr = XEiJ.regOC & 7 | 8;
          a = XEiJ.regRn[arr];
          for (n = 0; list != 0; n++, list <<= 1) {
            if (list < 0) {
              XEiJ.mpuCycleCount += 3;
              mmuReadByteArray (a, b, 0, 12, XEiJ.regSRS);
              if (XEiJ.fpuBox.epbIsTriple ()) {  //三倍精度
                XEiJ.fpuFPn[n].sety012 (b, 0);
              } else {  //拡張精度
                XEiJ.fpuFPn[n].setx012 (b, 0);
              }
              a += 12;
            }
          }
          XEiJ.regRn[arr] = a;
        } else {  //(Ar)+以外
          a = efaCntLong (ea);
          for (n = 0; list != 0; n++, list <<= 1) {
            if (list < 0) {
              XEiJ.mpuCycleCount += 3;
              mmuReadByteArray (a, b, 0, 12, XEiJ.regSRS);
              if (XEiJ.fpuBox.epbIsTriple ()) {  //三倍精度
                XEiJ.fpuFPn[n].sety012 (b, 0);
              } else {  //拡張精度
                XEiJ.fpuFPn[n].setx012 (b, 0);
              }
              a += 12;
            }
          }
        }
      }
      break fgen;


    case 0b111:  //$Exxx-$Fxxx: FMOVEM.X <list>,<ea>
      //  FMOVEM命令は例外を発生させずFPCR/FPSR/FPIARも(デスティネーションに書かれたもの以外)変化しない
      {
        if ((m & 2) != 0 && !XEiJ.fpuBox.epbIsFullSpec ()) {  //動的レジスタリスト
          irpExceptionFormat0 (M68kException.M6E_UNIMPLEMENTED_EFFECTIVE << 2, XEiJ.regPC0);  //pcは命令の先頭
          break fgen;
        }
        byte[] b = new byte[12];
        int list = ((m & 2) == 0 ? w : XEiJ.regRn[w >> 4 & 7]) << 24;
        if (ea >> 3 == XEiJ.MMM_MN) {  //-(Ar)
          int arr = XEiJ.regOC & 7 | 8;
          a = XEiJ.regRn[arr];
          for (n = 7; list != 0; n--, list <<= 1) {
            if (list < 0) {
              XEiJ.mpuCycleCount += 3;
              a -= 12;
              if (XEiJ.fpuBox.epbIsTriple ()) {  //三倍精度
                XEiJ.fpuFPn[n].gety012 (b, 0, XEiJ.fpuBox.epbRoundingMode);
              } else {  //拡張精度
                XEiJ.fpuFPn[n].getx012 (b, 0, XEiJ.fpuBox.epbRoundingMode);
              }
              mmuWriteByteArray (a, b, 0, 12, XEiJ.regSRS);
            }
          }
          XEiJ.regRn[arr] = a;
        } else {  //-(Ar)以外
          a = efaCltLong (ea);
          for (n = 0; list != 0; n++, list <<= 1) {
            if (list < 0) {
              XEiJ.mpuCycleCount += 3;
              if (XEiJ.fpuBox.epbIsTriple ()) {  //三倍精度
                XEiJ.fpuFPn[n].gety012 (b, 0, XEiJ.fpuBox.epbRoundingMode);
              } else {  //拡張精度
                XEiJ.fpuFPn[n].getx012 (b, 0, XEiJ.fpuBox.epbRoundingMode);
              }
              mmuWriteByteArray (a, b, 0, 12, XEiJ.regSRS);
              a += 12;
            }
          }
        }
      }
      break fgen;


    case 0b001:  //$2xxx-$3xxx: 未定義
    default:  //未定義
      XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される
      XEiJ.regPC = XEiJ.regPC0 + 2;  //拡張ワードを読まなかったことにする
      irpFline ();
      break fgen;
    }
  }  //fgen
  }  //irpFgen


  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FSF.B <ea>                                      |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000000
  //FSEQ.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000001
  //FSOGT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000010
  //FSOGE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000011
  //FSOLT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000100
  //FSOLE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000101
  //FSOGL.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000110
  //FSOR.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000000111
  //FSUN.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001000
  //FSUEQ.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001001
  //FSUGT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001010
  //FSUGE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001011
  //FSULT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001100
  //FSULE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001101
  //FSNE.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001110
  //FST.B <ea>                                      |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000001111
  //FSSF.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010000
  //FSSEQ.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010001
  //FSGT.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010010
  //FSGE.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010011
  //FSLT.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010100
  //FSLE.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010101
  //FSGL.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010110
  //FSGLE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000010111
  //FSNGLE.B <ea>                                   |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011000
  //FSNGL.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011001
  //FSNLE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011010
  //FSNLT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011011
  //FSNGE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011100
  //FSNGT.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011101
  //FSSNE.B <ea>                                    |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011110
  //FSST.B <ea>                                     |-|--CC4S|-|-----|-----|D M+-WXZ  |1111_001_001_mmm_rrr-0000000000011111
  //FDBF Dr,<label>                                 |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000000-{offset}
  //FDBRA Dr,<label>                                |A|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000000-{offset}       [FDBF Dr,<label>]
  //FDBEQ Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000001-{offset}
  //FDBOGT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000010-{offset}
  //FDBOGE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000011-{offset}
  //FDBOLT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000100-{offset}
  //FDBOLE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000101-{offset}
  //FDBOGL Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000110-{offset}
  //FDBOR Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000000111-{offset}
  //FDBUN Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001000-{offset}
  //FDBUEQ Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001001-{offset}
  //FDBUGT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001010-{offset}
  //FDBUGE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001011-{offset}
  //FDBULT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001100-{offset}
  //FDBULE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001101-{offset}
  //FDBNE Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001110-{offset}
  //FDBT Dr,<label>                                 |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000001111-{offset}
  //FDBSF Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010000-{offset}
  //FDBSEQ Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010001-{offset}
  //FDBGT Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010010-{offset}
  //FDBGE Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010011-{offset}
  //FDBLT Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010100-{offset}
  //FDBLE Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010101-{offset}
  //FDBGL Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010110-{offset}
  //FDBGLE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000010111-{offset}
  //FDBNGLE Dr,<label>                              |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011000-{offset}
  //FDBNGL Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011001-{offset}
  //FDBNLE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011010-{offset}
  //FDBNLT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011011-{offset}
  //FDBNGE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011100-{offset}
  //FDBNGT Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011101-{offset}
  //FDBSNE Dr,<label>                               |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011110-{offset}
  //FDBST Dr,<label>                                |-|--CC4S|-|-----|-----|          |1111_001_001_001_rrr-0000000000011111-{offset}
  //FTRAPF.W #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000000-{data}
  //FTRAPEQ.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000001-{data}
  //FTRAPOGT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000010-{data}
  //FTRAPOGE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000011-{data}
  //FTRAPOLT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000100-{data}
  //FTRAPOLE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000101-{data}
  //FTRAPOGL.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000110-{data}
  //FTRAPOR.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000000111-{data}
  //FTRAPUN.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001000-{data}
  //FTRAPUEQ.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001001-{data}
  //FTRAPUGT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001010-{data}
  //FTRAPUGE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001011-{data}
  //FTRAPULT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001100-{data}
  //FTRAPULE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001101-{data}
  //FTRAPNE.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001110-{data}
  //FTRAPT.W #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000001111-{data}
  //FTRAPSF.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010000-{data}
  //FTRAPSEQ.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010001-{data}
  //FTRAPGT.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010010-{data}
  //FTRAPGE.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010011-{data}
  //FTRAPLT.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010100-{data}
  //FTRAPLE.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010101-{data}
  //FTRAPGL.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010110-{data}
  //FTRAPGLE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000010111-{data}
  //FTRAPNGLE.W #<data>                             |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011000-{data}
  //FTRAPNGL.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011001-{data}
  //FTRAPNLE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011010-{data}
  //FTRAPNLT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011011-{data}
  //FTRAPNGE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011100-{data}
  //FTRAPNGT.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011101-{data}
  //FTRAPSNE.W #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011110-{data}
  //FTRAPST.W #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_010-0000000000011111-{data}
  //FTRAPF.L #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000000-{data}
  //FTRAPEQ.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000001-{data}
  //FTRAPOGT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000010-{data}
  //FTRAPOGE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000011-{data}
  //FTRAPOLT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000100-{data}
  //FTRAPOLE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000101-{data}
  //FTRAPOGL.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000110-{data}
  //FTRAPOR.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000000111-{data}
  //FTRAPUN.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001000-{data}
  //FTRAPUEQ.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001001-{data}
  //FTRAPUGT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001010-{data}
  //FTRAPUGE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001011-{data}
  //FTRAPULT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001100-{data}
  //FTRAPULE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001101-{data}
  //FTRAPNE.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001110-{data}
  //FTRAPT.L #<data>                                |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000001111-{data}
  //FTRAPSF.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010000-{data}
  //FTRAPSEQ.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010001-{data}
  //FTRAPGT.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010010-{data}
  //FTRAPGE.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010011-{data}
  //FTRAPLT.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010100-{data}
  //FTRAPLE.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010101-{data}
  //FTRAPGL.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010110-{data}
  //FTRAPGLE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000010111-{data}
  //FTRAPNGLE.L #<data>                             |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011000-{data}
  //FTRAPNGL.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011001-{data}
  //FTRAPNLE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011010-{data}
  //FTRAPNLT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011011-{data}
  //FTRAPNGE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011100-{data}
  //FTRAPNGT.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011101-{data}
  //FTRAPSNE.L #<data>                              |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011110-{data}
  //FTRAPST.L #<data>                               |-|--CC4S|-|-----|-----|          |1111_001_001_111_011-0000000000011111-{data}
  //FTRAPF                                          |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000000
  //FTRAPEQ                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000001
  //FTRAPOGT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000010
  //FTRAPOGE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000011
  //FTRAPOLT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000100
  //FTRAPOLE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000101
  //FTRAPOGL                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000110
  //FTRAPOR                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000000111
  //FTRAPUN                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001000
  //FTRAPUEQ                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001001
  //FTRAPUGT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001010
  //FTRAPUGE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001011
  //FTRAPULT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001100
  //FTRAPULE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001101
  //FTRAPNE                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001110
  //FTRAPT                                          |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000001111
  //FTRAPSF                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010000
  //FTRAPSEQ                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010001
  //FTRAPGT                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010010
  //FTRAPGE                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010011
  //FTRAPLT                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010100
  //FTRAPLE                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010101
  //FTRAPGL                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010110
  //FTRAPGLE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000010111
  //FTRAPNGLE                                       |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011000
  //FTRAPNGL                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011001
  //FTRAPNLE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011010
  //FTRAPNLT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011011
  //FTRAPNGE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011100
  //FTRAPNGT                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011101
  //FTRAPSNE                                        |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011110
  //FTRAPST                                         |-|--CC4S|-|-----|-----|          |1111_001_001_111_100-0000000000011111
  public static void irpFscc () throws M68kException {
  fscc: {
    //XEiJ.fpuBox.epbExceptionStatusWord = 0;
    if (XEiJ.currentMPU == Model.MPU_MC68LC060) {
      irpFline ();
      break fscc;
    }
    XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される
    int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
    if ((w & 0b010000) != 0 && (XEiJ.fpuBox.epbFpsr & XEiJ.FPU_FPSR_NAN) != 0) {  //IEEEノンアウェアテストでNANがセットされているとき
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_BSUN;  //BSUNをセット
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_TO_AEXC[XEiJ.fpuBox.epbFpsr >> 8 & 255];
      if ((XEiJ.fpuBox.epbFpcr & XEiJ.FPU_FPCR_BSUN) != 0) {  //BSUN例外許可
        XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | M68kException.M6E_FP_BRANCH_SET_UNORDERED & 7;
        irpExceptionFormat0 (M68kException.M6E_FP_BRANCH_SET_UNORDERED << 2, XEiJ.regPC0);  //pcは命令の先頭
        break fscc;
      }
    }
    int ea = XEiJ.regOC & 63;
    if (ea < XEiJ.EA_AR) {  //FScc.B Dr
      if (!XEiJ.fpuBox.epbIsFullSpec ()) {
        irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, 0);  //pcは次の命令,アドレスは実効アドレス
        break fscc;
      }
      if (XEiJ.FPU_CCMAP_060[(w & 63) << 4 | XEiJ.fpuBox.epbFpsr >> 24 & 15]) {  //セット
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] |= 0xff;
      } else {  //クリア
        XEiJ.mpuCycleCount++;
        XEiJ.regRn[ea] &= ~0xff;
      }
    } else if (ea < XEiJ.EA_MM) {  //FDBcc Dr,<label>
      if (!XEiJ.fpuBox.epbIsFullSpec ()) {
        XEiJ.regPC += 2;  //オフセットを読み飛ばす
        irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, 0);  //pcは次の命令,アドレスは実効アドレス
        break fscc;
      }
      if (XEiJ.FPU_CCMAP_060[(w & 63) << 4 | XEiJ.fpuBox.epbFpsr >> 24 & 15]) {  //条件が成立しているので通過
        XEiJ.mpuCycleCount += 2;
        XEiJ.regPC += 2;  //オフセットを読み飛ばす
      } else {
        int rrr = XEiJ.regOC & 7;
        int t = XEiJ.regRn[rrr];
        if ((short) t == 0) {  //Drの下位16bitが0なので通過
          XEiJ.mpuCycleCount += 2;
          XEiJ.regRn[rrr] = t + 65535;
          XEiJ.regPC += 2;  //オフセットを読み飛ばす
        } else {  //Drの下位16bitが0でないのでジャンプ
          XEiJ.mpuCycleCount++;
          XEiJ.regRn[rrr] = t - 1;  //下位16bitが0でないので上位16bitは変化しない
          irpSetPC (XEiJ.regPC + mmuReadWordSignExword (XEiJ.regPC, XEiJ.regSRS));  //pc==pc0+2
        }
      }
    } else if (ea < XEiJ.EA_PW) {  //FScc.B <mem>
      int a = efaMltByte (ea);
      if (!XEiJ.fpuBox.epbIsFullSpec ()) {
        irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスは実効アドレス
        break fscc;
      }
      XEiJ.mpuCycleCount++;
      mmuWriteByteData (a, XEiJ.FPU_CCMAP_060[(w & 63) << 4 | XEiJ.fpuBox.epbFpsr >> 24 & 15] ? 0xff : 0x00, XEiJ.regSRS);
    } else if (ea <= XEiJ.EA_IM) {  //FTRAPcc.W/FTRAPcc.L/FTRAPcc
      XEiJ.regPC += (ea & 3) + (ea & 1);  //111_010→2,111_011→4,111_100→0
      if (!XEiJ.fpuBox.epbIsFullSpec ()) {
        irpExceptionFormat2 (M68kException.M6E_FP_UNIMPLEMENTED_INSTRUCTION << 2, XEiJ.regPC, 0);  //pcは次の命令,アドレスは実効アドレス
        break fscc;
      }
      if (!XEiJ.FPU_CCMAP_060[(w & 63) << 4 | XEiJ.fpuBox.epbFpsr >> 24 & 15]) {  //通過
        XEiJ.mpuCycleCount += 2;
      } else {
        M68kException.m6eAddress = XEiJ.regPC0;  //アドレスは命令の先頭
        M68kException.m6eNumber = M68kException.M6E_TRAPV_INSTRUCTION;
        throw M68kException.m6eSignal;
      }
    } else {
      XEiJ.regPC = XEiJ.regPC0 + 2;  //拡張ワードを読まなかったことにする
      irpFline ();
      break fscc;
    }
  }  //fscc
  }  //irpFscc

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FNOP                                            |A|--CC46|-|-----|-----|          |1111_001_010_000_000-0000000000000000        [FBF.W (*)+2]
  //FBF.W <label>                                   |-|--CC46|-|-----|-----|          |1111_001_010_000_000-{offset}
  //FBEQ.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_000_001-{offset}
  //FBOGT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_010-{offset}
  //FBOGE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_011-{offset}
  //FBOLT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_100-{offset}
  //FBOLE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_101-{offset}
  //FBOGL.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_000_110-{offset}
  //FBOR.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_000_111-{offset}
  //FBUN.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_001_000-{offset}
  //FBUEQ.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_001-{offset}
  //FBUGT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_010-{offset}
  //FBUGE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_011-{offset}
  //FBULT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_100-{offset}
  //FBULE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_001_101-{offset}
  //FBNE.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_001_110-{offset}
  //FBT.W <label>                                   |-|--CC46|-|-----|-----|          |1111_001_010_001_111-{offset}
  //FBRA.W <label>                                  |A|--CC46|-|-----|-----|          |1111_001_010_001_111-{offset}        [FBT.W <label>]
  //FBSF.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_000-{offset}
  //FBSEQ.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_010_001-{offset}
  //FBGT.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_010-{offset}
  //FBGE.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_011-{offset}
  //FBLT.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_100-{offset}
  //FBLE.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_101-{offset}
  //FBGL.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_010_110-{offset}
  //FBGLE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_010_111-{offset}
  //FBNGLE.W <label>                                |-|--CC46|-|-----|-----|          |1111_001_010_011_000-{offset}
  //FBNGL.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_001-{offset}
  //FBNLE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_010-{offset}
  //FBNLT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_011-{offset}
  //FBNGE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_100-{offset}
  //FBNGT.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_101-{offset}
  //FBSNE.W <label>                                 |-|--CC46|-|-----|-----|          |1111_001_010_011_110-{offset}
  //FBST.W <label>                                  |-|--CC46|-|-----|-----|          |1111_001_010_011_111-{offset}
  public static void irpFbccWord () throws M68kException {
  fbcc: {
    //XEiJ.fpuBox.epbExceptionStatusWord = 0;
    if (XEiJ.currentMPU == Model.MPU_MC68LC060) {
      irpFline ();
      break fbcc;
    }
    XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される
    if ((XEiJ.regOC & 0b010000) != 0 && (XEiJ.fpuBox.epbFpsr & XEiJ.FPU_FPSR_NAN) != 0) {  //IEEEノンアウェアテストでNANがセットされているとき
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_BSUN;  //BSUNをセット
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_TO_AEXC[XEiJ.fpuBox.epbFpsr >> 8 & 255];
      if ((XEiJ.fpuBox.epbFpcr & XEiJ.FPU_FPCR_BSUN) != 0) {  //BSUN例外許可
        XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | M68kException.M6E_FP_BRANCH_SET_UNORDERED & 7;
        irpExceptionFormat0 (M68kException.M6E_FP_BRANCH_SET_UNORDERED << 2, XEiJ.regPC0);  //pcは命令の先頭
        break fbcc;
      }
    }
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    XEiJ.regPC = t + 2;  //pc0+4
    t += mmuReadWordSignExword (t, XEiJ.regSRS);  //pc0+2+16bitディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.FPU_CCMAP_060[(XEiJ.regOC & 63) << 4 | XEiJ.fpuBox.epbFpsr >> 24 & 15]) {  //分岐する
      irpSetPC (t);
    }
  }  //fbcc
  }  //irpFbccWord

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FBF.L <label>                                   |-|--CC46|-|-----|-----|          |1111_001_011_000_000-{offset}
  //FBEQ.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_000_001-{offset}
  //FBOGT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_010-{offset}
  //FBOGE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_011-{offset}
  //FBOLT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_100-{offset}
  //FBOLE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_101-{offset}
  //FBOGL.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_000_110-{offset}
  //FBOR.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_000_111-{offset}
  //FBUN.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_001_000-{offset}
  //FBUEQ.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_001-{offset}
  //FBUGT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_010-{offset}
  //FBUGE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_011-{offset}
  //FBULT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_100-{offset}
  //FBULE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_001_101-{offset}
  //FBNE.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_001_110-{offset}
  //FBT.L <label>                                   |-|--CC46|-|-----|-----|          |1111_001_011_001_111-{offset}
  //FBRA.L <label>                                  |A|--CC46|-|-----|-----|          |1111_001_011_001_111-{offset}        [FBT.L <label>]
  //FBSF.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_000-{offset}
  //FBSEQ.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_010_001-{offset}
  //FBGT.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_010-{offset}
  //FBGE.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_011-{offset}
  //FBLT.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_100-{offset}
  //FBLE.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_101-{offset}
  //FBGL.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_010_110-{offset}
  //FBGLE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_010_111-{offset}
  //FBNGLE.L <label>                                |-|--CC46|-|-----|-----|          |1111_001_011_011_000-{offset}
  //FBNGL.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_001-{offset}
  //FBNLE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_010-{offset}
  //FBNLT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_011-{offset}
  //FBNGE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_100-{offset}
  //FBNGT.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_101-{offset}
  //FBSNE.L <label>                                 |-|--CC46|-|-----|-----|          |1111_001_011_011_110-{offset}
  //FBST.L <label>                                  |-|--CC46|-|-----|-----|          |1111_001_011_011_111-{offset}
  public static void irpFbccLong () throws M68kException {
  fbcc: {
    //XEiJ.fpuBox.epbExceptionStatusWord = 0;
    if (XEiJ.currentMPU == Model.MPU_MC68LC060) {
      irpFline ();
      break fbcc;
    }
    XEiJ.fpuBox.epbFpiar = XEiJ.regPC0;  //FPIARはFMOVEM/FMOVE FPcr/FSAVE/FRESTORE以外の命令で例外が発生しなくても更新される
    if ((XEiJ.regOC & 0b010000) != 0 && (XEiJ.fpuBox.epbFpsr & XEiJ.FPU_FPSR_NAN) != 0) {  //IEEEノンアウェアテストでNANがセットされているとき
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_BSUN;  //BSUNをセット
      XEiJ.fpuBox.epbFpsr |= XEiJ.FPU_FPSR_EXC_TO_AEXC[XEiJ.fpuBox.epbFpsr >> 8 & 255];
      if ((XEiJ.fpuBox.epbFpcr & XEiJ.FPU_FPCR_BSUN) != 0) {  //BSUN例外許可
        XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | M68kException.M6E_FP_BRANCH_SET_UNORDERED & 7;
        irpExceptionFormat0 (M68kException.M6E_FP_BRANCH_SET_UNORDERED << 2, XEiJ.regPC0);  //pcは命令の先頭
        break fbcc;
      }
    }
    XEiJ.mpuCycleCount++;
    int t = XEiJ.regPC;  //pc0+2
    XEiJ.regPC = t + 4;  //pc0+6
    t += mmuReadLongExword (t, XEiJ.regSRS);  //pc0+2+32bitディスプレースメント
    if ((t & 1) != 0) {  //分岐先のアドレスが奇数
      //MC68060のBcc/DBcc/FBccは分岐先のアドレスが奇数のとき分岐しなくてもアドレスエラーになる。FDBccは分岐するときだけ
      irpBccAddressError (t);
    }
    if (XEiJ.FPU_CCMAP_060[(XEiJ.regOC & 63) << 4 | XEiJ.fpuBox.epbFpsr >> 24 & 15]) {  //分岐する
      irpSetPC (t);
    }
  }  //fbcc
  }  //irpFbccLong

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FSAVE <ea>                                      |-|--CC46|P|-----|-----|  M -WXZ  |1111_001_100_mmm_rrr
  public static void irpFsave () throws M68kException {
    if (XEiJ.currentMPU == Model.MPU_MC68LC060) {
      irpFline ();
      return;
    }
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 3;
    int ea = XEiJ.regOC & 63;
    int a;
    if (ea >> 3 == XEiJ.MMM_MN) {  //-(Ar)
      int arr = XEiJ.regOC & 7 | 8;
      M68kException.m6eIncremented -= 12L << (arr << 3);
      a = XEiJ.regRn[arr] -= 12;
    } else {  //-(Ar)以外
      a = efaCltWord (ea);
    }
    if (XEiJ.fpuBox.epbExceptionStatusWord == 0) {  //例外なし
      mmuWriteLongData (a, 0x00006000, 1);  //アイドルフレーム
      mmuWriteQuadSecond (a + 4, 0L, 1);
    } else {  //例外あり
      mmuWriteLongData (a, XEiJ.fpuBox.epbExceptionOperandExponent | XEiJ.fpuBox.epbExceptionStatusWord, 1);  //例外フレーム
      mmuWriteQuadSecond (a + 4, XEiJ.fpuBox.epbExceptionOperandMantissa, 1);
      XEiJ.fpuBox.epbExceptionStatusWord = 0;
    }
  }  //irpFsave

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FRESTORE <ea>                                   |-|--CC46|P|-----|-----|  M+ WXZP |1111_001_101_mmm_rrr
  public static void irpFrestore () throws M68kException {
    if (XEiJ.currentMPU == Model.MPU_MC68LC060) {
      irpFline ();
      return;
    }
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 6;
    int ea = XEiJ.regOC & 63;
    int a;
    if (ea >> 3 == XEiJ.MMM_MP) {  //(Ar)+
      int arr = XEiJ.regOC & 7 | 8;
      M68kException.m6eIncremented += 12L << (arr << 3);
      a = XEiJ.regRn[arr] += 12;
    } else {  //(Ar)+以外
      a = efaCntWord (ea);
    }
    int i = mmuReadLongData (a, 1);
    long l = mmuReadQuadData (a + 4, 1);
    if ((i & 0xff00) == 0xe000) {  //例外フレーム
      //例外ハンドラが0xe0xxを0x60xxに変更してFRESTOREする場合がある
      XEiJ.fpuBox.epbExceptionStatusWord = (char) i;
      XEiJ.fpuBox.epbExceptionOperandExponent = i & 0xffff0000;
      XEiJ.fpuBox.epbExceptionOperandMantissa = l;
    } else {
      XEiJ.fpuBox.epbExceptionStatusWord = 0;
      XEiJ.fpuBox.epbExceptionOperandExponent = 0;
      XEiJ.fpuBox.epbExceptionOperandMantissa = 0x0000000000000000L;
    }
    //FPSRのAEXCをクリアする
    XEiJ.fpuBox.epbFpsr = 0;
    //FPIARをクリアする
    XEiJ.fpuBox.epbFpiar = 0;
  }  //irpFrestore

  //irpFPPreInstruction ()
  //  浮動小数点命令実行前例外 floating-point pre-instruction exception
  //  優先順位はBSUN>SNAN>OPERR>OVFL>UNFL>DZ>INEX2/INEX1
  //  複数の例外が同時に発生したときは最上位の例外ハンドラだけが呼び出される
  //  浮動小数点例外ハンドラは自分よりも下位の浮動小数点例外が発生していないか確認しなければならない
  public static boolean irpFPPreInstruction () throws M68kException {
    int mask = XEiJ.fpuBox.epbFpcr & XEiJ.fpuBox.epbFpsr & 0x0000ff00;
    if (mask == 0) {
      return false;
    }
    int number = FP_OFFSET_TO_NUMBER[Integer.numberOfLeadingZeros (mask)];
    XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | number & 7;
    irpExceptionFormat0 (number << 2, XEiJ.regPC0);  //pcは命令の先頭
    return true;
  }  //irpFPPreInstruction()

  //irpFPPostInstruction (a)
  //  浮動小数点命令実行後例外 floating-point post-instruction exception
  //  優先順位はBSUN>SNAN>OPERR>OVFL>UNFL>DZ>INEX2/INEX1
  //  複数の例外が同時に発生したときは最上位の例外ハンドラだけが呼び出される
  //  浮動小数点例外ハンドラは自分よりも下位の浮動小数点例外が発生していないか確認しなければならない
  public static boolean irpFPPostInstruction (int a) throws M68kException {
    int mask = XEiJ.fpuBox.epbFpcr & XEiJ.fpuBox.epbFpsr & 0x0000ff00;
    if (mask == 0) {
      return false;
    }
    int number = FP_OFFSET_TO_NUMBER[Integer.numberOfLeadingZeros (mask)];
    XEiJ.fpuBox.epbExceptionStatusWord = 0xe000 | number & 7;
    irpExceptionFormat3 (number << 2, XEiJ.regPC, a);  //pcは次の命令,アドレスはデスティネーションオペランド
    return true;
  }  //irpFPPostInstruction(int)

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CINVL NC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_000_001_rrr
  //CINVP NC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_000_010_rrr
  //CINVA NC                                        |-|----46|P|-----|-----|          |1111_010_000_011_000
  //CPUSHL NC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_000_101_rrr
  //CPUSHP NC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_000_110_rrr
  //CPUSHA NC                                       |-|----46|P|-----|-----|          |1111_010_000_111_000
  public static void irpCinvCpushNC () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
  }  //irpCinvCpushNC

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CINVL DC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_001_001_rrr
  //CINVP DC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_001_010_rrr
  //CINVA DC                                        |-|----46|P|-----|-----|          |1111_010_001_011_000
  //CPUSHL DC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_001_101_rrr
  //CPUSHP DC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_001_110_rrr
  //CPUSHA DC                                       |-|----46|P|-----|-----|          |1111_010_001_111_000
  public static void irpCinvCpushDC () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
  }  //irpCinvCpushDC

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CINVL IC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_010_001_rrr
  //CINVP IC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_010_010_rrr
  //CINVA IC                                        |-|----46|P|-----|-----|          |1111_010_010_011_000
  //CPUSHL IC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_010_101_rrr
  //CPUSHP IC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_010_110_rrr
  //CPUSHA IC                                       |-|----46|P|-----|-----|          |1111_010_010_111_000
  public static void irpCinvCpushIC () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
  }  //irpCinvCpushIC

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //CINVL BC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_011_001_rrr
  //CINVP BC,(Ar)                                   |-|----46|P|-----|-----|          |1111_010_011_010_rrr
  //CINVA BC                                        |-|----46|P|-----|-----|          |1111_010_011_011_000
  //CPUSHL BC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_011_101_rrr
  //CPUSHP BC,(Ar)                                  |-|----46|P|-----|-----|          |1111_010_011_110_rrr
  //CPUSHA BC                                       |-|----46|P|-----|-----|          |1111_010_011_111_000
  public static void irpCinvCpushBC () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount++;
  }  //irpCinvCpushBC

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //PFLUSHN (Ar)                                    |-|----46|P|-----|-----|          |1111_010_100_000_rrr
  //PFLUSH (Ar)                                     |-|----46|P|-----|-----|          |1111_010_100_001_rrr
  //PFLUSHAN                                        |-|----46|P|-----|-----|          |1111_010_100_010_000
  //PFLUSHA                                         |-|----46|P|-----|-----|          |1111_010_100_011_000
  public static void irpPflush () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    if (XEiJ.regOC <= 0b1111_010_100_000_111) {  //PFLUSHN (An)
      XEiJ.mpuCycleCount += 18;
      mmuInvalidateNonGlobalCache (XEiJ.regRn[XEiJ.regOC - (0b1111_010_100_000_000 - 8)]);
    } else if (XEiJ.regOC <= 0b1111_010_100_001_111) {  //PFLUSH (An)
      XEiJ.mpuCycleCount += 18;
      mmuInvalidateCache (XEiJ.regRn[XEiJ.regOC - (0b1111_010_100_001_000 - 8)]);
    } else if (XEiJ.regOC == 0b1111_010_100_010_000) {  //PFLUSHAN
      XEiJ.mpuCycleCount += 33;
      mmuInvalidateAllNonGlobalCache ();
    } else if (XEiJ.regOC == 0b1111_010_100_011_000) {  //PFLUSHA
      XEiJ.mpuCycleCount += 33;
      mmuInvalidateAllCache ();
    } else {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpPflush

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //PLPAW (Ar)                                      |-|-----6|P|-----|-----|          |1111_010_110_001_rrr
  public static void irpPlpaw () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 15;
    int ann = XEiJ.regOC - (0b1111_010_110_001_000 - 8);  //8+nnn
    XEiJ.regRn[ann] = mmuLoadPhysicalAddressWrite (XEiJ.regRn[ann]);
  }  //irpPlpaw

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //PLPAR (Ar)                                      |-|-----6|P|-----|-----|          |1111_010_111_001_rrr
  //
  //PLPAR (Ar)
  //  ReadだがSFCではなくDFCを使う
  public static void irpPlpar () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    XEiJ.mpuCycleCount += 15;
    int ann = XEiJ.regOC - (0b1111_010_111_001_000 - 8);  //8+nnn
    XEiJ.regRn[ann] = mmuLoadPhysicalAddressRead (XEiJ.regRn[ann]);
  }  //irpPlpar

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //MOVE16 (Ar)+,xxx.L                              |-|----46|-|-----|-----|          |1111_011_000_000_rrr-{address}
  //MOVE16 xxx.L,(Ar)+                              |-|----46|-|-----|-----|          |1111_011_000_001_rrr-{address}
  //MOVE16 (Ar),xxx.L                               |-|----46|-|-----|-----|          |1111_011_000_010_rrr-{address}
  //MOVE16 xxx.L,(Ar)                               |-|----46|-|-----|-----|          |1111_011_000_011_rrr-{address}
  //MOVE16 (Ar)+,(An)+                              |-|----46|-|-----|-----|          |1111_011_000_100_rrr-1nnn000000000000
  //
  //MOVE16 (Ar)+,xxx.L
  //MOVE16 xxx.L,(Ar)+
  //MOVE16 (Ar),xxx.L
  //MOVE16 xxx.L,(Ar)
  //MOVE16 (Ar)+,(An)+
  //  アドレスの下位4bitは無視される
  //  ポストインクリメントで16増えるとき下位4bitは変化しない
  //  r==nのときMOVE16 (Ar)+,(Ar)+はMOVE16 (Ar),(Ar)+のような動作になる。データは動かずArは16だけ増える(M68060UM 1-21)
  public static void irpMove16 () throws M68kException {
    if (XEiJ.regOC <= 0b1111_011_000_011_111) {  //どちらかがxxx.L
      XEiJ.mpuCycleCount += 18;
      int arr = XEiJ.regOC - (0b1111_011_000_000_000 - 8);  //8+rrr
      int a = XEiJ.regRn[arr] & -16;
      int x = mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS) & -16;  //pcls
      if ((XEiJ.regOC & 0b001_000) == 0) {  //(Ar)→xxx.L
        long l = mmuReadQuadData (a, XEiJ.regSRS);
        long m = mmuReadQuadSecond (a + 8, XEiJ.regSRS);
        mmuWriteQuadData (x, l, XEiJ.regSRS);
        mmuWriteQuadSecond (x + 8, m, XEiJ.regSRS);
      } else {  //xxx.L→(An)
        long l = mmuReadQuadData (x, XEiJ.regSRS);
        long m = mmuReadQuadSecond (x + 8, XEiJ.regSRS);
        mmuWriteQuadData (a, l, XEiJ.regSRS);
        mmuWriteQuadSecond (a + 8, m, XEiJ.regSRS);
      }
      if ((XEiJ.regOC & 0b010_000) == 0) {  //(Ar)+
        XEiJ.regRn[arr] += 16;  //aはマスクされているのでa+16は不可
      }
    } else if (XEiJ.regOC <= 0b1111_011_000_100_111) {
      int w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz
      if ((w & 0b1000111111111111) == 0b1000000000000000) {  //MOVE16 (Ar)+,(As)+
        XEiJ.mpuCycleCount += 18;
        int arr = XEiJ.regOC - (0b1111_011_000_100_000 - 8);  //8+rrr
        int a = XEiJ.regRn[arr] & -16;
        int ass = w >> 12;  //8+sss
        int x = XEiJ.regRn[ass] & -16;
        long l = mmuReadQuadData (a, XEiJ.regSRS);
        long m = mmuReadQuadSecond (a + 8, XEiJ.regSRS);
        mmuWriteQuadData (x, l, XEiJ.regSRS);
        mmuWriteQuadSecond (x + 8, m, XEiJ.regSRS);
        XEiJ.regRn[arr] += 16;  //aはマスクされているのでa+16は不可
        if (arr != ass) {
          XEiJ.regRn[ass] += 16;  //xはマスクされているのでx+16は不可
        }
      } else {
        M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
        throw M68kException.m6eSignal;
      }
    } else {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpMove16

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //LPSTOP.W #<data>                                |-|-----6|P|-----|-----|          |1111_100_000_000_000-0000000111000000-{data}
  public static void irpLpstop () throws M68kException {
    if (XEiJ.regSRS == 0) {  //ユーザモードのとき
      M68kException.m6eNumber = M68kException.M6E_PRIVILEGE_VIOLATION;
      throw M68kException.m6eSignal;
    }
    //以下はスーパーバイザモード
    //!!! 非対応
  }  //irpLpstop

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FPACK <data>                                    |A|012346|-|UUUUU|*****|          |1111_111_0dd_ddd_ddd [FLINE #<data>]
  public static void irpFpack () throws M68kException {
    if (!MainMemory.mmrFEfuncActivated) {
      irpFline ();
      return;
    }
    StringBuilder sb;
    int a0;
    if (FEFunction.FPK_DEBUG_TRACE) {
      sb = new StringBuilder ();
      String name = Disassembler.DIS_FPACK_NAME[XEiJ.regOC & 255];
      if (name.length () == 0) {
        XEiJ.fmtHex4 (sb.append ('$'), XEiJ.regOC);
      } else {
        sb.append (name);
      }
      sb.append ('\n');
      XEiJ.fmtHex8 (XEiJ.fmtHex8 (XEiJ.fmtHex8 (XEiJ.fmtHex8 (sb.append ("  D0="), XEiJ.regRn[0]).append (" D1="), XEiJ.regRn[1]).append (" D2="), XEiJ.regRn[2]).append (" D3="), XEiJ.regRn[3]);
      a0 = XEiJ.regRn[8];
      MainMemory.mmrRstr (sb.append (" (A0)=\""), a0, MainMemory.mmrStrlen (a0, 20)).append ("\"\n");
    }
    XEiJ.mpuCycleCount += FEFunction.FPK_CLOCK;  //一律にFEFunction.FPK_CLOCKサイクルかかることにする
    switch (XEiJ.regOC & 255) {
    case 0x00: FEFunction.fpkLMUL (); break;
    case 0x01: FEFunction.fpkLDIV (); break;
    case 0x02: FEFunction.fpkLMOD (); break;
      //case 0x03: break;
    case 0x04: FEFunction.fpkUMUL (); break;
    case 0x05: FEFunction.fpkUDIV (); break;
    case 0x06: FEFunction.fpkUMOD (); break;
      //case 0x07: break;
    case 0x08: FEFunction.fpkIMUL (); break;
    case 0x09: FEFunction.fpkIDIV (); break;
      //case 0x0a: break;
      //case 0x0b: break;
    case 0x0c: FEFunction.fpkRANDOMIZE (); break;
    case 0x0d: FEFunction.fpkSRAND (); break;
    case 0x0e: FEFunction.fpkRAND (); break;
      //case 0x0f: break;
    case 0x10: fpkSTOL (); break;
    case 0x11: fpkLTOS (); break;
    case 0x12: fpkSTOH (); break;
    case 0x13: fpkHTOS (); break;
    case 0x14: fpkSTOO (); break;
    case 0x15: fpkOTOS (); break;
    case 0x16: fpkSTOB (); break;
    case 0x17: fpkBTOS (); break;
    case 0x18: fpkIUSING (); break;
      //case 0x19: break;
    case 0x1a: FEFunction.fpkLTOD (); break;
    case 0x1b: FEFunction.fpkDTOL (); break;
    case 0x1c: FEFunction.fpkLTOF (); break;
    case 0x1d: FEFunction.fpkFTOL (); break;
    case 0x1e: FEFunction.fpkFTOD (); break;
    case 0x1f: FEFunction.fpkDTOF (); break;
    case 0x20: fpkVAL (); break;
    case 0x21: fpkUSING (); break;
    case 0x22: fpkSTOD (); break;
    case 0x23: fpkDTOS (); break;
    case 0x24: fpkECVT (); break;
    case 0x25: fpkFCVT (); break;
    case 0x26: fpkGCVT (); break;
      //case 0x27: break;
    case 0x28: FEFunction.fpkDTST (); break;
    case 0x29: FEFunction.fpkDCMP (); break;
    case 0x2a: FEFunction.fpkDNEG (); break;
    case 0x2b: FEFunction.fpkDADD (); break;
    case 0x2c: FEFunction.fpkDSUB (); break;
    case 0x2d: FEFunction.fpkDMUL (); break;
    case 0x2e: FEFunction.fpkDDIV (); break;
    case 0x2f: FEFunction.fpkDMOD (); break;
    case 0x30: FEFunction.fpkDABS (); break;
    case 0x31: FEFunction.fpkDCEIL (); break;
    case 0x32: FEFunction.fpkDFIX (); break;
    case 0x33: FEFunction.fpkDFLOOR (); break;
    case 0x34: FEFunction.fpkDFRAC (); break;
    case 0x35: FEFunction.fpkDSGN (); break;
    case 0x36: FEFunction.fpkSIN (); break;
    case 0x37: FEFunction.fpkCOS (); break;
    case 0x38: FEFunction.fpkTAN (); break;
    case 0x39: FEFunction.fpkATAN (); break;
    case 0x3a: FEFunction.fpkLOG (); break;
    case 0x3b: FEFunction.fpkEXP (); break;
    case 0x3c: FEFunction.fpkSQR (); break;
    case 0x3d: FEFunction.fpkPI (); break;
    case 0x3e: FEFunction.fpkNPI (); break;
    case 0x3f: FEFunction.fpkPOWER (); break;
    case 0x40: FEFunction.fpkRND (); break;
    case 0x41: FEFunction.fpkSINH (); break;
    case 0x42: FEFunction.fpkCOSH (); break;
    case 0x43: FEFunction.fpkTANH (); break;
    case 0x44: FEFunction.fpkATANH (); break;
    case 0x45: FEFunction.fpkASIN (); break;
    case 0x46: FEFunction.fpkACOS (); break;
    case 0x47: FEFunction.fpkLOG10 (); break;
    case 0x48: FEFunction.fpkLOG2 (); break;
    case 0x49: FEFunction.fpkDFREXP (); break;
    case 0x4a: FEFunction.fpkDLDEXP (); break;
    case 0x4b: FEFunction.fpkDADDONE (); break;
    case 0x4c: FEFunction.fpkDSUBONE (); break;
    case 0x4d: FEFunction.fpkDDIVTWO (); break;
    case 0x4e: FEFunction.fpkDIEECNV (); break;
    case 0x4f: FEFunction.fpkIEEDCNV (); break;
    case 0x50: fpkFVAL (); break;
    case 0x51: FEFunction.fpkFUSING (); break;
    case 0x52: FEFunction.fpkSTOF (); break;
    case 0x53: FEFunction.fpkFTOS (); break;
    case 0x54: FEFunction.fpkFECVT (); break;
    case 0x55: FEFunction.fpkFFCVT (); break;
    case 0x56: FEFunction.fpkFGCVT (); break;
      //case 0x57: break;
    case 0x58: FEFunction.fpkFTST (); break;
    case 0x59: FEFunction.fpkFCMP (); break;
    case 0x5a: FEFunction.fpkFNEG (); break;
    case 0x5b: FEFunction.fpkFADD (); break;
    case 0x5c: FEFunction.fpkFSUB (); break;
    case 0x5d: FEFunction.fpkFMUL (); break;
    case 0x5e: FEFunction.fpkFDIV (); break;
    case 0x5f: FEFunction.fpkFMOD (); break;
    case 0x60: FEFunction.fpkFABS (); break;
    case 0x61: FEFunction.fpkFCEIL (); break;
    case 0x62: FEFunction.fpkFFIX (); break;
    case 0x63: FEFunction.fpkFFLOOR (); break;
    case 0x64: FEFunction.fpkFFRAC (); break;
    case 0x65: FEFunction.fpkFSGN (); break;
    case 0x66: FEFunction.fpkFSIN (); break;
    case 0x67: FEFunction.fpkFCOS (); break;
    case 0x68: FEFunction.fpkFTAN (); break;
    case 0x69: FEFunction.fpkFATAN (); break;
    case 0x6a: FEFunction.fpkFLOG (); break;
    case 0x6b: FEFunction.fpkFEXP (); break;
    case 0x6c: FEFunction.fpkFSQR (); break;
    case 0x6d: FEFunction.fpkFPI (); break;
    case 0x6e: FEFunction.fpkFNPI (); break;
    case 0x6f: FEFunction.fpkFPOWER (); break;
    case 0x70: FEFunction.fpkFRND (); break;
    case 0x71: FEFunction.fpkFSINH (); break;
    case 0x72: FEFunction.fpkFCOSH (); break;
    case 0x73: FEFunction.fpkFTANH (); break;
    case 0x74: FEFunction.fpkFATANH (); break;
    case 0x75: FEFunction.fpkFASIN (); break;
    case 0x76: FEFunction.fpkFACOS (); break;
    case 0x77: FEFunction.fpkFLOG10 (); break;
    case 0x78: FEFunction.fpkFLOG2 (); break;
    case 0x79: FEFunction.fpkFFREXP (); break;
    case 0x7a: FEFunction.fpkFLDEXP (); break;
    case 0x7b: FEFunction.fpkFADDONE (); break;
    case 0x7c: FEFunction.fpkFSUBONE (); break;
    case 0x7d: FEFunction.fpkFDIVTWO (); break;
    case 0x7e: FEFunction.fpkFIEECNV (); break;
    case 0x7f: FEFunction.fpkIEEFCNV (); break;
      //case 0x80: break;
      //case 0x81: break;
      //case 0x82: break;
      //case 0x83: break;
      //case 0x84: break;
      //case 0x85: break;
      //case 0x86: break;
      //case 0x87: break;
      //case 0x88: break;
      //case 0x89: break;
      //case 0x8a: break;
      //case 0x8b: break;
      //case 0x8c: break;
      //case 0x8d: break;
      //case 0x8e: break;
      //case 0x8f: break;
      //case 0x90: break;
      //case 0x91: break;
      //case 0x92: break;
      //case 0x93: break;
      //case 0x94: break;
      //case 0x95: break;
      //case 0x96: break;
      //case 0x97: break;
      //case 0x98: break;
      //case 0x99: break;
      //case 0x9a: break;
      //case 0x9b: break;
      //case 0x9c: break;
      //case 0x9d: break;
      //case 0x9e: break;
      //case 0x9f: break;
      //case 0xa0: break;
      //case 0xa1: break;
      //case 0xa2: break;
      //case 0xa3: break;
      //case 0xa4: break;
      //case 0xa5: break;
      //case 0xa6: break;
      //case 0xa7: break;
      //case 0xa8: break;
      //case 0xa9: break;
      //case 0xaa: break;
      //case 0xab: break;
      //case 0xac: break;
      //case 0xad: break;
      //case 0xae: break;
      //case 0xaf: break;
      //case 0xb0: break;
      //case 0xb1: break;
      //case 0xb2: break;
      //case 0xb3: break;
      //case 0xb4: break;
      //case 0xb5: break;
      //case 0xb6: break;
      //case 0xb7: break;
      //case 0xb8: break;
      //case 0xb9: break;
      //case 0xba: break;
      //case 0xbb: break;
      //case 0xbc: break;
      //case 0xbd: break;
      //case 0xbe: break;
      //case 0xbf: break;
      //case 0xc0: break;
      //case 0xc1: break;
      //case 0xc2: break;
      //case 0xc3: break;
      //case 0xc4: break;
      //case 0xc5: break;
      //case 0xc6: break;
      //case 0xc7: break;
      //case 0xc8: break;
      //case 0xc9: break;
      //case 0xca: break;
      //case 0xcb: break;
      //case 0xcc: break;
      //case 0xcd: break;
      //case 0xce: break;
      //case 0xcf: break;
      //case 0xd0: break;
      //case 0xd1: break;
      //case 0xd2: break;
      //case 0xd3: break;
      //case 0xd4: break;
      //case 0xd5: break;
      //case 0xd6: break;
      //case 0xd7: break;
      //case 0xd8: break;
      //case 0xd9: break;
      //case 0xda: break;
      //case 0xdb: break;
      //case 0xdc: break;
      //case 0xdd: break;
      //case 0xde: break;
      //case 0xdf: break;
    case 0xe0: fpkCLMUL (); break;
    case 0xe1: fpkCLDIV (); break;
    case 0xe2: fpkCLMOD (); break;
    case 0xe3: fpkCUMUL (); break;
    case 0xe4: fpkCUDIV (); break;
    case 0xe5: fpkCUMOD (); break;
    case 0xe6: fpkCLTOD (); break;
    case 0xe7: fpkCDTOL (); break;
    case 0xe8: fpkCLTOF (); break;
    case 0xe9: fpkCFTOL (); break;
    case 0xea: fpkCFTOD (); break;
    case 0xeb: fpkCDTOF (); break;
    case 0xec: fpkCDCMP (); break;
    case 0xed: fpkCDADD (); break;
    case 0xee: fpkCDSUB (); break;
    case 0xef: fpkCDMUL (); break;
    case 0xf0: fpkCDDIV (); break;
    case 0xf1: fpkCDMOD (); break;
    case 0xf2: fpkCFCMP (); break;
    case 0xf3: fpkCFADD (); break;
    case 0xf4: fpkCFSUB (); break;
    case 0xf5: fpkCFMUL (); break;
    case 0xf6: fpkCFDIV (); break;
    case 0xf7: fpkCFMOD (); break;
    case 0xf8: fpkCDTST (); break;
    case 0xf9: fpkCFTST (); break;
    case 0xfa: fpkCDINC (); break;
    case 0xfb: fpkCFINC (); break;
    case 0xfc: fpkCDDEC (); break;
    case 0xfd: fpkCFDEC (); break;
    case 0xfe: FEFunction.fpkFEVARG (); break;
    //case 0xff: FEFunction.fpkFEVECS (); break;  //FLOATn.Xに処理させる
    default:
      XEiJ.mpuCycleCount -= FEFunction.FPK_CLOCK;  //戻す
      irpFline ();
    }
    if (FEFunction.FPK_DEBUG_TRACE) {
      int i = sb.length ();
      XEiJ.fmtHex8 (XEiJ.fmtHex8 (XEiJ.fmtHex8 (XEiJ.fmtHex8 (sb.append ("  D0="), XEiJ.regRn[0]).append (" D1="), XEiJ.regRn[1]).append (" D2="), XEiJ.regRn[2]).append (" D3="), XEiJ.regRn[3]);
      int l = MainMemory.mmrStrlen (a0, 20);
      sb.append (" (A0)=\"");
      i = sb.length () - i;
      MainMemory.mmrRstr (sb, a0, l).append ("\"\n");
      if (a0 <= XEiJ.regRn[8] && XEiJ.regRn[8] <= a0 + l) {
        for (i += sb.length () + XEiJ.regRn[8] - a0; sb.length () < i; ) {
          sb.append (' ');
        }
        sb.append ('^');
      }
      System.out.println (sb.toString ());
    }
  }  //irpFpack

  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //DOS <data>                                      |A|012346|-|UUUUU|UUUUU|          |1111_111_1dd_ddd_ddd [FLINE #<data>]
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //FLINE #<data>                                   |-|012346|-|UUUUU|UUUUU|          |1111_ddd_ddd_ddd_ddd (line 1111 emulator)
  public static void irpFline () throws M68kException {
    irpExceptionFormat0 (M68kException.M6E_LINE_1111_EMULATOR << 2, XEiJ.regPC0);  //pcは命令の先頭
  }  //irpFline

  //irpIllegal ()
  //  オペコードの上位10bitで分類されなかった未実装命令
  //  命令実行回数をカウントするために分けてある
  //  0x4afcのILLEGAL命令はTASに分類されて未実装実効アドレスで処理されるのでここには来ない
  public static void irpIllegal () throws M68kException {
    if (true) {
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpIllegal

  //z = irpAbcd (x, y)
  //  ABCD
  public static int irpAbcd (int x, int y) {
    int c = XEiJ.regCCR >> 4;
    int t = (x & 0xff) + (y & 0xff) + c;  //仮の結果
    int z = t;  //結果
    if (0x0a <= (x & 0x0f) + (y & 0x0f) + c) {  //ハーフキャリー
      z += 0x10 - 0x0a;
    }
    //XとCはキャリーがあるときセット、さもなくばクリア
    if (0xa0 <= z) {  //キャリー
      z += 0x100 - 0xa0;
      XEiJ.regCCR |= XEiJ.REG_CCR_X | XEiJ.REG_CCR_C;
    } else {
      XEiJ.regCCR &= ~(XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);
    }
    //Zは結果が0でないときクリア、さもなくば変化しない
    z &= 0xff;
    if (z != 0x00) {
      XEiJ.regCCR &= ~XEiJ.REG_CCR_Z;
    }
    if (false) {
      //000/030のときNは結果の最上位ビット
      if ((z & 0x80) != 0) {
        XEiJ.regCCR |= XEiJ.REG_CCR_N;
      } else {
        XEiJ.regCCR &= ~XEiJ.REG_CCR_N;
      }
      //000のときVは補正値の加算でオーバーフローしたときセット、さもなくばクリア
      int a = z - t;  //補正値
      if ((((t ^ z) & (a ^ z)) & 0x80) != 0) {
        XEiJ.regCCR |= XEiJ.REG_CCR_V;
      } else {
        XEiJ.regCCR &= ~XEiJ.REG_CCR_V;
      }
    } else if (false) {
      //000/030のときNは結果の最上位ビット
      if ((z & 0x80) != 0) {
        XEiJ.regCCR |= XEiJ.REG_CCR_N;
      } else {
        XEiJ.regCCR &= ~XEiJ.REG_CCR_N;
      }
      //030のときVはクリア
      XEiJ.regCCR &= ~XEiJ.REG_CCR_V;
    } else {
      //060のときNとVは変化しない
    }
    return z;
  }  //irpAbcd

  //z = irpSbcd (x, y)
  //  SBCD
  public static int irpSbcd (int x, int y) {
    int b = XEiJ.regCCR >> 4;
    int t = (x & 0xff) - (y & 0xff) - b;  //仮の結果
    int z = t;  //結果
    if ((x & 0x0f) - (y & 0x0f) - b < 0) {  //ハーフボロー
      z -= 0x10 - 0x0a;
    }
    //XとCはボローがあるときセット、さもなくばクリア
    if (z < 0) {  //ボロー
      if (t < 0) {
        z -= 0x100 - 0xa0;
      }
      XEiJ.regCCR |= XEiJ.REG_CCR_X | XEiJ.REG_CCR_C;
    } else {
      XEiJ.regCCR &= ~(XEiJ.REG_CCR_X | XEiJ.REG_CCR_C);
    }
    //Zは結果が0でないときクリア、さもなくば変化しない
    z &= 0xff;
    if (z != 0x00) {
      XEiJ.regCCR &= ~XEiJ.REG_CCR_Z;
    }
    if (false) {
      //000/030のときNは結果の最上位ビット
      if ((z & 0x80) != 0) {
        XEiJ.regCCR |= XEiJ.REG_CCR_N;
      } else {
        XEiJ.regCCR &= ~XEiJ.REG_CCR_N;
      }
      //000のときVは補正値の加算でオーバーフローしたときセット、さもなくばクリア
      int a = z - t;  //補正値
      if ((((t ^ z) & (a ^ z)) & 0x80) != 0) {
        XEiJ.regCCR |= XEiJ.REG_CCR_V;
      } else {
        XEiJ.regCCR &= ~XEiJ.REG_CCR_V;
      }
    } else if (false) {
      //000/030のときNは結果の最上位ビット
      if ((z & 0x80) != 0) {
        XEiJ.regCCR |= XEiJ.REG_CCR_N;
      } else {
        XEiJ.regCCR &= ~XEiJ.REG_CCR_N;
      }
      //030のときVはクリア
      XEiJ.regCCR &= ~XEiJ.REG_CCR_V;
    } else {
      //060のときNとVは変化しない
    }
    return z;
  }  //irpSbcd



  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //                                                | |  MPU | |CCin |CCout|addressing|     1st opcode         2nd opcode
  //                           A:alias P:privileged |A|012346|P|XNZVC|XNZVC|DAM+-WXZPI|bbbb_bbb_bbb_bbb_bbb-bbbbbbbbbbbbbbbb
  //------------------------------------------------+-+------+-+-----+-----+----------+-------------------------------------
  //HFSBOOT                                         |-|012346|-|-----|-----|          |0100_111_000_000_000
  //HFSINST                                         |-|012346|-|-----|-----|          |0100_111_000_000_001
  //HFSSTR                                          |-|012346|-|-----|-----|          |0100_111_000_000_010
  //HFSINT                                          |-|012346|-|-----|-----|          |0100_111_000_000_011
  //EMXNOP                                          |-|012346|-|-----|-----|          |0100_111_000_000_100
  //  エミュレータ拡張命令
  public static void irpEmx () throws M68kException {
    switch (XEiJ.regOC & 63) {
    case XEiJ.EMX_OPCODE_HFSBOOT & 63:
      XEiJ.mpuCycleCount += 19;
      if (HFS.hfsIPLBoot ()) {
        //JMP $6800.W
        irpSetPC (0x00006800);
      }
      break;
    case XEiJ.EMX_OPCODE_HFSINST & 63:
      XEiJ.mpuCycleCount += 19;
      HFS.hfsInstall ();
      break;
    case XEiJ.EMX_OPCODE_HFSSTR & 63:
      XEiJ.mpuCycleCount += 19;
      HFS.hfsStrategy ();
      break;
    case XEiJ.EMX_OPCODE_HFSINT & 63:
      XEiJ.mpuCycleCount += 19;
      //XEiJ.mpuClockTime += TMR_FREQ / 100000L;  //0.01ms
      if (HFS.hfsInterrupt ()) {
        //WAIT
        XEiJ.mpuTraceFlag = 0;  //トレース例外を発生させない
        XEiJ.regPC = XEiJ.regPC0;  //ループ
        XEiJ.mpuClockTime += XEiJ.TMR_FREQ * 4 / 1000000;  //4μs。10MHzのとき40clk
        XEiJ.mpuLastNano += 4000L;
      }
      break;
    case XEiJ.EMX_OPCODE_EMXNOP & 63:
      XEiJ.emxNop ();
      break;
    case XEiJ.EMX_OPCODE_EMXWAIT & 63:
      WaitInstruction.execute ();  //待機命令を実行する
      break;
    default:
      M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
      throw M68kException.m6eSignal;
    }
  }  //irpEmx



  //irpSetPC (a)
  //  pcへデータを書き込む
  //  奇数のときはアドレスエラーが発生する
  public static void irpSetPC (int a) throws M68kException {
    if (XEiJ.TEST_BIT_0_SHIFT ? a << 31 - 0 < 0 : (a & 1) != 0) {
      M68kException.m6eNumber = M68kException.M6E_ADDRESS_ERROR;
      M68kException.m6eAddress = a & -2;  //アドレスを偶数にする
      M68kException.m6eDirection = XEiJ.MPU_WR_READ;
      M68kException.m6eSize = XEiJ.MPU_SS_LONG;
      throw M68kException.m6eSignal;
    }
    if (BranchLog.BLG_ON) {
      //BranchLog.blgJump (a);  //分岐ログに分岐レコードを追加する
      if (BranchLog.blgPrevHeadSuper != (BranchLog.blgHead | BranchLog.blgSuper) || BranchLog.blgPrevTail != XEiJ.regPC0) {  //前回のレコードと異なるとき
        int i = (char) BranchLog.blgNewestRecord++ << BranchLog.BLG_RECORD_SHIFT;
        BranchLog.blgArray[i] = BranchLog.blgPrevHeadSuper = BranchLog.blgHead | BranchLog.blgSuper;
        BranchLog.blgArray[i + 1] = BranchLog.blgPrevTail = XEiJ.regPC0;
      }
      BranchLog.blgHead = XEiJ.regPC = a;
      BranchLog.blgSuper = XEiJ.regSRS >>> 13;
    } else {
      XEiJ.regPC = a;
    }
  }  //irpSetPC

  //irpSetSR (newSr)
  //  srへデータを書き込む
  //  ori to sr/andi to sr/eori to sr/move to sr/stop/rteで使用される
  //  スーパーバイザモードになっていることを確認してから呼び出すこと
  //  rteではr[15]が指すアドレスからsrとpcを取り出してr[15]を更新してから呼び出すこと
  //  スーパーバイザモード→ユーザモードのときは移行のための処理を行う
  //  新しい割り込みマスクレベルよりも高い割り込み処理の終了をデバイスに通知する
  public static void irpSetSR (int newSr) {
    XEiJ.regSRT1 = XEiJ.REG_SR_T1 & newSr;
    XEiJ.regSRM = XEiJ.REG_SR_M & newSr;
    if ((XEiJ.regSRS = XEiJ.REG_SR_S & newSr) == 0) {  //スーパーバイザモード→ユーザモード
      XEiJ.mpuISP = XEiJ.regRn[15];  //SSPを保存
      XEiJ.regRn[15] = XEiJ.mpuUSP;  //USPを復元
      if (DataBreakPoint.DBP_ON) {
        DataBreakPoint.dbpMemoryMap = DataBreakPoint.dbpUserMap;  //ユーザメモリマップに切り替える
      } else {
        XEiJ.busMemoryMap = XEiJ.busUserMap;  //ユーザメモリマップに切り替える
      }
      if (InstructionBreakPoint.IBP_ON) {
        InstructionBreakPoint.ibpOp1MemoryMap = InstructionBreakPoint.ibpOp1UserMap;
      }
    }
    int t = (XEiJ.mpuIMR = 0x7f >> ((XEiJ.regSRI = XEiJ.REG_SR_I & newSr) >> 8)) & XEiJ.mpuISR;  //XEiJ.mpuISRで1→0とするビット
    if (t != 0) {  //終了する割り込みがあるとき
      XEiJ.mpuISR ^= t;
      //デバイスに割り込み処理の終了を通知する
      if (t == XEiJ.MPU_MFP_INTERRUPT_MASK) {  //MFPのみ
        MC68901.mfpDone ();
      } else if (t == XEiJ.MPU_DMA_INTERRUPT_MASK) {  //DMAのみ
        HD63450.dmaDone ();
      } else if (t == XEiJ.MPU_SCC_INTERRUPT_MASK) {  //SCCのみ
        Z8530.sccDone ();
      } else if (t == XEiJ.MPU_IOI_INTERRUPT_MASK) {  //IOIのみ
        IOInterrupt.ioiDone ();
      } else if (t == XEiJ.MPU_EB2_INTERRUPT_MASK) {  //EB2のみ
        XEiJ.eb2Done ();
      } else {  //SYSのみまたは複数
        if (XEiJ.TEST_BIT_1_SHIFT ? t << 24 + XEiJ.MPU_MFP_INTERRUPT_LEVEL < 0 : (t & XEiJ.MPU_MFP_INTERRUPT_MASK) != 0) {
          MC68901.mfpDone ();
        }
        if (t << 24 + XEiJ.MPU_DMA_INTERRUPT_LEVEL < 0) {  //(t & XEiJ.MPU_DMA_INTERRUPT_MASK) != 0
          HD63450.dmaDone ();
        }
        if (XEiJ.TEST_BIT_2_SHIFT ? t << 24 + XEiJ.MPU_SCC_INTERRUPT_LEVEL < 0 : (t & XEiJ.MPU_SCC_INTERRUPT_MASK) != 0) {
          Z8530.sccDone ();
        }
        if (t << 24 + XEiJ.MPU_IOI_INTERRUPT_LEVEL < 0) {  //(t & XEiJ.MPU_IOI_INTERRUPT_MASK) != 0
          IOInterrupt.ioiDone ();
        }
        if (t << 24 + XEiJ.MPU_EB2_INTERRUPT_LEVEL < 0) {  //(t & XEiJ.MPU_EB2_INTERRUPT_MASK) != 0
          XEiJ.eb2Done ();
        }
        if (XEiJ.TEST_BIT_0_SHIFT ? t << 24 + XEiJ.MPU_SYS_INTERRUPT_LEVEL < 0 : (t & XEiJ.MPU_SYS_INTERRUPT_MASK) != 0) {
          XEiJ.sysDone ();
        }
      }
    }
    XEiJ.mpuIMR |= ~XEiJ.mpuISR & XEiJ.MPU_SYS_INTERRUPT_MASK;  //割り込みマスクレベルが7のときレベル7割り込みの処理中でなければレベル7割り込みを許可する
    XEiJ.regCCR = XEiJ.REG_CCR_MASK & newSr;
  }  //irpSetSR

  //irpInterrupt (offset, level)
  //  割り込み処理を開始する
  public static void irpInterrupt (int offset, int level) throws M68kException {
    if (XEiJ.regOC == 0b0100_111_001_110_010) {  //最後に実行した命令はSTOP命令
      XEiJ.regPC = XEiJ.regPC0 + 4;  //次の命令に進む
    }
    XEiJ.mpuClockTime += XEiJ.mpuModifiedUnit * 19;
    int save_sr = XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR;
    XEiJ.regSRI = level << 8;  //割り込みマスクを要求されたレベルに変更する
    XEiJ.mpuIMR = 0x7f >> level;
    XEiJ.mpuISR |= 0x80 >> level;
    XEiJ.regSRT1 = XEiJ.mpuTraceFlag = 0;  //srのTビットを消す
    int sp;
    if (XEiJ.regSRS != 0) {  //スーパーバイザモード
      sp = XEiJ.regRn[15];
    } else {  //ユーザモード
      XEiJ.regSRS = XEiJ.REG_SR_S;  //スーパーバイザモードへ移行する
      XEiJ.mpuUSP = XEiJ.regRn[15];  //USPを保存
      sp = XEiJ.mpuISP;  //SSPを復元
      if (DataBreakPoint.DBP_ON) {
        DataBreakPoint.dbpMemoryMap = DataBreakPoint.dbpSuperMap;  //スーパーバイザメモリマップに切り替える
      } else {
        XEiJ.busMemoryMap = XEiJ.busSuperMap;  //スーパーバイザメモリマップに切り替える
      }
      if (InstructionBreakPoint.IBP_ON) {
        InstructionBreakPoint.ibpOp1MemoryMap = InstructionBreakPoint.ibpOp1SuperMap;
      }
    }
    //以下はスーパーバイザモード
    XEiJ.regRn[15] = sp -= 8;
    mmuWriteWordData (sp + 6, offset, 1);  //7-6:フォーマットとベクタオフセット
    mmuWriteLongData (sp + 2, XEiJ.regPC, 1);  //5-2:プログラムカウンタ
    mmuWriteWordData (sp, save_sr, 1);  //1-0:ステータスレジスタ
    //if (XEiJ.regSRM != 0) {  //マスタモードのとき
    XEiJ.regSRM = 0;  //割り込みモードへ移行する
    //}
    if (BranchLog.BLG_ON) {
      XEiJ.regPC0 = XEiJ.regPC;  //rteによる割り込み終了と同時に次の割り込みを受け付けたとき間でpc0を更新しないと2番目の分岐レコードの終了アドレスが1番目と同じになっておかしな分岐レコードができてしまう
    }
    irpSetPC (mmuReadLongFour (XEiJ.mpuVBR + offset, 1));  //例外ベクタを取り出してジャンプする
  }  //irpInterrupt

  //irpExceptionFormat0 (offset, save_pc)
  //  例外処理を開始する
  //  スタックへのプッシュ、ベクタの取り出し、ジャンプのいずれかでバスエラーまたはアドレスエラーが発生する場合がある
  public static void irpExceptionFormat0 (int offset, int save_pc) throws M68kException {
    XEiJ.mpuCycleCount += 19;
    int save_sr = XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR;
    XEiJ.regSRT1 = XEiJ.mpuTraceFlag = 0;  //srのTビットを消す
    int sp;
    if (XEiJ.regSRS != 0) {  //スーパーバイザモード
      sp = XEiJ.regRn[15];
    } else {  //ユーザモード
      XEiJ.regSRS = XEiJ.REG_SR_S;  //スーパーバイザモードへ移行する
      XEiJ.mpuUSP = XEiJ.regRn[15];  //USPを保存
      sp = XEiJ.mpuISP;  //SSPを復元
      if (DataBreakPoint.DBP_ON) {
        DataBreakPoint.dbpMemoryMap = DataBreakPoint.dbpSuperMap;  //スーパーバイザメモリマップに切り替える
      } else {
        XEiJ.busMemoryMap = XEiJ.busSuperMap;  //スーパーバイザメモリマップに切り替える
      }
      if (InstructionBreakPoint.IBP_ON) {
        InstructionBreakPoint.ibpOp1MemoryMap = InstructionBreakPoint.ibpOp1SuperMap;
      }
    }
    //以下はスーパーバイザモード
    XEiJ.regRn[15] = sp -= 8;
    mmuWriteWordData (sp + 6, offset, 1);  //7-6:フォーマットとベクタオフセット
    mmuWriteLongData (sp + 2, save_pc, 1);  //5-2:プログラムカウンタ
    mmuWriteWordData (sp, save_sr, 1);  //1-0:ステータスレジスタ
    irpSetPC (mmuReadLongFour (XEiJ.mpuVBR + offset, 1));  //例外ベクタを取り出してジャンプする
  }  //irpExceptionFormat0

  //irpExceptionFormat2 (offset, save_pc, address)
  //  例外処理を開始する
  //  スタックへのプッシュ、ベクタの取り出し、ジャンプのいずれかでバスエラーまたはアドレスエラーが発生する場合がある
  public static void irpExceptionFormat2 (int offset, int save_pc, int address) throws M68kException {
    XEiJ.mpuCycleCount += 19;
    int save_sr = XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR;
    XEiJ.regSRT1 = XEiJ.mpuTraceFlag = 0;  //srのTビットを消す
    int sp;
    if (XEiJ.regSRS != 0) {  //スーパーバイザモード
      sp = XEiJ.regRn[15];
    } else {  //ユーザモード
      XEiJ.regSRS = XEiJ.REG_SR_S;  //スーパーバイザモードへ移行する
      XEiJ.mpuUSP = XEiJ.regRn[15];  //USPを保存
      sp = XEiJ.mpuISP;  //SSPを復元
      if (DataBreakPoint.DBP_ON) {
        DataBreakPoint.dbpMemoryMap = DataBreakPoint.dbpSuperMap;  //スーパーバイザメモリマップに切り替える
      } else {
        XEiJ.busMemoryMap = XEiJ.busSuperMap;  //スーパーバイザメモリマップに切り替える
      }
      if (InstructionBreakPoint.IBP_ON) {
        InstructionBreakPoint.ibpOp1MemoryMap = InstructionBreakPoint.ibpOp1SuperMap;
      }
    }
    //以下はスーパーバイザモード
    XEiJ.regRn[15] = sp -= 12;
    mmuWriteLongData (sp + 8, address, 1);  //11-8:アドレス
    mmuWriteWordData (sp + 6, 0x2000 | offset, 1);  //7-6:フォーマットとベクタオフセット
    mmuWriteLongData (sp + 2, save_pc, 1);  //5-2:プログラムカウンタ
    mmuWriteWordData (sp, save_sr, 1);  //1-0:ステータスレジスタ
    irpSetPC (mmuReadLongFour (XEiJ.mpuVBR + offset, 1));  //例外ベクタを取り出してジャンプする
  }  //irpExceptionFormat2

  //irpExceptionFormat3 (offset, save_pc, address)
  //  例外処理を開始する
  //  スタックへのプッシュ、ベクタの取り出し、ジャンプのいずれかでバスエラーまたはアドレスエラーが発生する場合がある
  public static void irpExceptionFormat3 (int offset, int save_pc, int address) throws M68kException {
    XEiJ.mpuCycleCount += 19;
    int save_sr = XEiJ.regSRT1 | XEiJ.regSRS | XEiJ.regSRM | XEiJ.regSRI | XEiJ.regCCR;
    XEiJ.regSRT1 = XEiJ.mpuTraceFlag = 0;  //srのTビットを消す
    int sp;
    if (XEiJ.regSRS != 0) {  //スーパーバイザモード
      sp = XEiJ.regRn[15];
    } else {  //ユーザモード
      XEiJ.regSRS = XEiJ.REG_SR_S;  //スーパーバイザモードへ移行する
      XEiJ.mpuUSP = XEiJ.regRn[15];  //USPを保存
      sp = XEiJ.mpuISP;  //SSPを復元
      if (DataBreakPoint.DBP_ON) {
        DataBreakPoint.dbpMemoryMap = DataBreakPoint.dbpSuperMap;  //スーパーバイザメモリマップに切り替える
      } else {
        XEiJ.busMemoryMap = XEiJ.busSuperMap;  //スーパーバイザメモリマップに切り替える
      }
      if (InstructionBreakPoint.IBP_ON) {
        InstructionBreakPoint.ibpOp1MemoryMap = InstructionBreakPoint.ibpOp1SuperMap;
      }
    }
    //以下はスーパーバイザモード
    XEiJ.regRn[15] = sp -= 12;
    mmuWriteLongData (sp + 8, address, 1);  //11-8:実効アドレス
    mmuWriteWordData (sp + 6, 0x3000 | offset, 1);  //7-6:フォーマットとベクタオフセット
    mmuWriteLongData (sp + 2, save_pc, 1);  //5-2:プログラムカウンタ
    mmuWriteWordData (sp, save_sr, 1);  //1-0:ステータスレジスタ
    irpSetPC (mmuReadLongFour (XEiJ.mpuVBR + offset, 1));  //例外ベクタを取り出してジャンプする
  }  //irpExceptionFormat3



  //a = efaAnyByte (ea)  //|  M+-WXZPI|
  //  任意のモードのバイトオペランドの実効アドレスを求める
  //  (A7)+と-(A7)はA7を奇偶に関わらず2変化させ、跨いだワードの上位バイト(アドレスの小さい方)を参照する
  //  #<data>はオペコードに続くワードの下位バイトを参照する。上位バイトは不定なので参照してはならない
  @SuppressWarnings ("fallthrough") public static int efaAnyByte (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (0 << 3);
        return XEiJ.regRn[ 8]++;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (1 << 3);
        return XEiJ.regRn[ 9]++;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (2 << 3);
        return XEiJ.regRn[10]++;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (3 << 3);
        return XEiJ.regRn[11]++;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (4 << 3);
        return XEiJ.regRn[12]++;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (5 << 3);
        return XEiJ.regRn[13]++;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (6 << 3);
        return XEiJ.regRn[14]++;
      } else {
        M68kException.m6eIncremented += 1L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b011_000 - 8)]++;
      }
    case 0b011_111:  //(A7)+
      M68kException.m6eIncremented += 2L << (7 << 3);
      return (XEiJ.regRn[15] += 2) - 2;
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (0 << 3);
        return --XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (1 << 3);
        return --XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (2 << 3);
        return --XEiJ.regRn[10];
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (3 << 3);
        return --XEiJ.regRn[11];
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (4 << 3);
        return --XEiJ.regRn[12];
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (5 << 3);
        return --XEiJ.regRn[13];
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (6 << 3);
        return --XEiJ.regRn[14];
      } else {
        M68kException.m6eIncremented -= 1L << ((ea & 7) << 3);
        return --XEiJ.regRn[ea - (0b100_000 - 8)];
      }
    case 0b100_111:  //-(A7)
      M68kException.m6eIncremented -= 2L << (7 << 3);
      return XEiJ.regRn[15] -= 2;
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_100:  //#<data>
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regPC += 2) - 1;  //下位バイト
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return t + 1;  //下位バイト
      }
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaAnyByte

  //a = efaMemByte (ea)  //|  M+-WXZP |
  //  メモリモードのバイトオペランドの実効アドレスを求める
  //  efaAnyByteとの違いは#<data>がないこと
  @SuppressWarnings ("fallthrough") public static int efaMemByte (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (0 << 3);
        return XEiJ.regRn[ 8]++;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (1 << 3);
        return XEiJ.regRn[ 9]++;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (2 << 3);
        return XEiJ.regRn[10]++;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (3 << 3);
        return XEiJ.regRn[11]++;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (4 << 3);
        return XEiJ.regRn[12]++;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (5 << 3);
        return XEiJ.regRn[13]++;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (6 << 3);
        return XEiJ.regRn[14]++;
      } else {
        M68kException.m6eIncremented += 1L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b011_000 - 8)]++;
      }
    case 0b011_111:  //(A7)+
      M68kException.m6eIncremented += 2L << (7 << 3);
      return (XEiJ.regRn[15] += 2) - 2;
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (0 << 3);
        return --XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (1 << 3);
        return --XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (2 << 3);
        return --XEiJ.regRn[10];
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (3 << 3);
        return --XEiJ.regRn[11];
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (4 << 3);
        return --XEiJ.regRn[12];
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (5 << 3);
        return --XEiJ.regRn[13];
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (6 << 3);
        return --XEiJ.regRn[14];
      } else {
        M68kException.m6eIncremented -= 1L << ((ea & 7) << 3);
        return --XEiJ.regRn[ea - (0b100_000 - 8)];
      }
    case 0b100_111:  //-(A7)
      M68kException.m6eIncremented -= 2L << (7 << 3);
      return XEiJ.regRn[15] -= 2;
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMemByte

  //a = efaMltByte (ea)  //|  M+-WXZ  |
  //  メモリ可変モードのバイトオペランドの実効アドレスを求める
  //  efaMemByteとの違いは(d16,PC)と(d8,PC,Rn.wl)がないこと
  @SuppressWarnings ("fallthrough") public static int efaMltByte (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (0 << 3);
        return XEiJ.regRn[ 8]++;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (1 << 3);
        return XEiJ.regRn[ 9]++;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (2 << 3);
        return XEiJ.regRn[10]++;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (3 << 3);
        return XEiJ.regRn[11]++;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (4 << 3);
        return XEiJ.regRn[12]++;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (5 << 3);
        return XEiJ.regRn[13]++;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 1L << (6 << 3);
        return XEiJ.regRn[14]++;
      } else {
        M68kException.m6eIncremented += 1L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b011_000 - 8)]++;
      }
    case 0b011_111:  //(A7)+
      M68kException.m6eIncremented += 2L << (7 << 3);
      return (XEiJ.regRn[15] += 2) - 2;
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (0 << 3);
        return --XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (1 << 3);
        return --XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (2 << 3);
        return --XEiJ.regRn[10];
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (3 << 3);
        return --XEiJ.regRn[11];
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (4 << 3);
        return --XEiJ.regRn[12];
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (5 << 3);
        return --XEiJ.regRn[13];
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 1L << (6 << 3);
        return --XEiJ.regRn[14];
      } else {
        M68kException.m6eIncremented -= 1L << ((ea & 7) << 3);
        return --XEiJ.regRn[ea - (0b100_000 - 8)];
      }
    case 0b100_111:  //-(A7)
      M68kException.m6eIncremented -= 2L << (7 << 3);
      return XEiJ.regRn[15] -= 2;
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMltByte

  //a = efaCntByte (ea)  //|  M  WXZP |
  //  制御モードのロングオペランドの実効アドレスを求める
  //  efaMemByteとの違いは(Ar)+と-(Ar)がないこと
  @SuppressWarnings ("fallthrough") public static int efaCntByte (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaCntByte

  //a = efaAnyWord (ea)  //|  M+-WXZPI|
  //  任意のモードのワードオペランドの実効アドレスを求める
  //  efaAnyByteとの違いは(Ar)+と-(Ar)がArを2変化させることと、(A7)+と-(A7)と#<data>の特別な動作がないこと
  @SuppressWarnings ("fallthrough") public static int efaAnyWord (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (0 << 3);
        return (XEiJ.regRn[ 8] += 2) - 2;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (1 << 3);
        return (XEiJ.regRn[ 9] += 2) - 2;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (2 << 3);
        return (XEiJ.regRn[10] += 2) - 2;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (3 << 3);
        return (XEiJ.regRn[11] += 2) - 2;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (4 << 3);
        return (XEiJ.regRn[12] += 2) - 2;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (5 << 3);
        return (XEiJ.regRn[13] += 2) - 2;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (6 << 3);
        return (XEiJ.regRn[14] += 2) - 2;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (7 << 3);
        return (XEiJ.regRn[15] += 2) - 2;
      } else {
        M68kException.m6eIncremented += 2L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 2) - 2;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (0 << 3);
        return XEiJ.regRn[ 8] -= 2;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (1 << 3);
        return XEiJ.regRn[ 9] -= 2;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (2 << 3);
        return XEiJ.regRn[10] -= 2;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (3 << 3);
        return XEiJ.regRn[11] -= 2;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (4 << 3);
        return XEiJ.regRn[12] -= 2;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (5 << 3);
        return XEiJ.regRn[13] -= 2;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (6 << 3);
        return XEiJ.regRn[14] -= 2;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (7 << 3);
        return XEiJ.regRn[15] -= 2;
      } else {
        M68kException.m6eIncremented -= 2L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 2;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_100:  //#<data>
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regPC += 2) - 2;
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return t;
      }
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaAnyWord

  //a = efaMemWord (ea)  //|  M+-WXZP |
  //  メモリモードのワードオペランドの実効アドレスを求める
  //  efaAnyWordとの違いは#<data>がないこと
  @SuppressWarnings ("fallthrough") public static int efaMemWord (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (0 << 3);
        return (XEiJ.regRn[ 8] += 2) - 2;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (1 << 3);
        return (XEiJ.regRn[ 9] += 2) - 2;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (2 << 3);
        return (XEiJ.regRn[10] += 2) - 2;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (3 << 3);
        return (XEiJ.regRn[11] += 2) - 2;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (4 << 3);
        return (XEiJ.regRn[12] += 2) - 2;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (5 << 3);
        return (XEiJ.regRn[13] += 2) - 2;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (6 << 3);
        return (XEiJ.regRn[14] += 2) - 2;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (7 << 3);
        return (XEiJ.regRn[15] += 2) - 2;
      } else {
        M68kException.m6eIncremented += 2L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 2) - 2;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (0 << 3);
        return XEiJ.regRn[ 8] -= 2;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (1 << 3);
        return XEiJ.regRn[ 9] -= 2;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (2 << 3);
        return XEiJ.regRn[10] -= 2;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (3 << 3);
        return XEiJ.regRn[11] -= 2;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (4 << 3);
        return XEiJ.regRn[12] -= 2;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (5 << 3);
        return XEiJ.regRn[13] -= 2;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (6 << 3);
        return XEiJ.regRn[14] -= 2;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (7 << 3);
        return XEiJ.regRn[15] -= 2;
      } else {
        M68kException.m6eIncremented -= 2L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 2;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMemWord

  //a = efaMltWord (ea)  //|  M+-WXZ  |
  //  メモリ可変モードのワードオペランドの実効アドレスを求める
  //  efaMemWordとの違いは(d16,PC)と(d8,PC,Rn.wl)がないこと
  @SuppressWarnings ("fallthrough") public static int efaMltWord (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (0 << 3);
        return (XEiJ.regRn[ 8] += 2) - 2;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (1 << 3);
        return (XEiJ.regRn[ 9] += 2) - 2;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (2 << 3);
        return (XEiJ.regRn[10] += 2) - 2;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (3 << 3);
        return (XEiJ.regRn[11] += 2) - 2;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (4 << 3);
        return (XEiJ.regRn[12] += 2) - 2;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (5 << 3);
        return (XEiJ.regRn[13] += 2) - 2;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (6 << 3);
        return (XEiJ.regRn[14] += 2) - 2;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 2L << (7 << 3);
        return (XEiJ.regRn[15] += 2) - 2;
      } else {
        M68kException.m6eIncremented += 2L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 2) - 2;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (0 << 3);
        return XEiJ.regRn[ 8] -= 2;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (1 << 3);
        return XEiJ.regRn[ 9] -= 2;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (2 << 3);
        return XEiJ.regRn[10] -= 2;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (3 << 3);
        return XEiJ.regRn[11] -= 2;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (4 << 3);
        return XEiJ.regRn[12] -= 2;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (5 << 3);
        return XEiJ.regRn[13] -= 2;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (6 << 3);
        return XEiJ.regRn[14] -= 2;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 2L << (7 << 3);
        return XEiJ.regRn[15] -= 2;
      } else {
        M68kException.m6eIncremented -= 2L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 2;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMltWord

  //a = efaCntWord (ea)  //|  M  WXZP |
  //  制御モードのワードオペランドの実効アドレスを求める
  //  efaMemWordとの違いは(Ar)+と-(Ar)がないこと
  @SuppressWarnings ("fallthrough") public static int efaCntWord (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaCntWord

  //a = efaCltWord (ea)  //|  M  WXZ  |
  //  制御可変モードのワードオペランドの実効アドレスを求める
  //  efaCntWordとの違いは(d16,PC)と(d8,PC,Rn.wl)がないこと
  @SuppressWarnings ("fallthrough") public static int efaCltWord (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaCltWord

  //a = efaAnyLong (ea)  //|  M+-WXZPI|
  //  任意のモードのロングオペランドの実効アドレスを求める
  //  efaAnyWordとの違いは(Ar)+と-(Ar)がArを4変化させることと、#<data>がPCを4変化させることと、
  //  オペランドのアクセスが1ワード増える分の4サイクルが追加されていること
  @SuppressWarnings ("fallthrough") public static int efaAnyLong (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (0 << 3);
        return (XEiJ.regRn[ 8] += 4) - 4;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (1 << 3);
        return (XEiJ.regRn[ 9] += 4) - 4;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (2 << 3);
        return (XEiJ.regRn[10] += 4) - 4;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (3 << 3);
        return (XEiJ.regRn[11] += 4) - 4;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (4 << 3);
        return (XEiJ.regRn[12] += 4) - 4;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (5 << 3);
        return (XEiJ.regRn[13] += 4) - 4;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (6 << 3);
        return (XEiJ.regRn[14] += 4) - 4;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (7 << 3);
        return (XEiJ.regRn[15] += 4) - 4;
      } else {
        M68kException.m6eIncremented += 4L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 4) - 4;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (0 << 3);
        return XEiJ.regRn[ 8] -= 4;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (1 << 3);
        return XEiJ.regRn[ 9] -= 4;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (2 << 3);
        return XEiJ.regRn[10] -= 4;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (3 << 3);
        return XEiJ.regRn[11] -= 4;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (4 << 3);
        return XEiJ.regRn[12] -= 4;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (5 << 3);
        return XEiJ.regRn[13] -= 4;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (6 << 3);
        return XEiJ.regRn[14] -= 4;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (7 << 3);
        return XEiJ.regRn[15] -= 4;
      } else {
        M68kException.m6eIncremented -= 4L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 4;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_100:  //#<data>
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regPC += 4) - 4;
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 4;
        return t;
      }
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaAnyLong

  //a = efaMemLong (ea)  //|  M+-WXZP |
  //  メモリモードのロングオペランドの実効アドレスを求める
  //  efaAnyLongとの違いは#<data>がないこと
  @SuppressWarnings ("fallthrough") public static int efaMemLong (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (0 << 3);
        return (XEiJ.regRn[ 8] += 4) - 4;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (1 << 3);
        return (XEiJ.regRn[ 9] += 4) - 4;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (2 << 3);
        return (XEiJ.regRn[10] += 4) - 4;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (3 << 3);
        return (XEiJ.regRn[11] += 4) - 4;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (4 << 3);
        return (XEiJ.regRn[12] += 4) - 4;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (5 << 3);
        return (XEiJ.regRn[13] += 4) - 4;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (6 << 3);
        return (XEiJ.regRn[14] += 4) - 4;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (7 << 3);
        return (XEiJ.regRn[15] += 4) - 4;
      } else {
        M68kException.m6eIncremented += 4L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 4) - 4;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (0 << 3);
        return XEiJ.regRn[ 8] -= 4;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (1 << 3);
        return XEiJ.regRn[ 9] -= 4;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (2 << 3);
        return XEiJ.regRn[10] -= 4;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (3 << 3);
        return XEiJ.regRn[11] -= 4;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (4 << 3);
        return XEiJ.regRn[12] -= 4;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (5 << 3);
        return XEiJ.regRn[13] -= 4;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (6 << 3);
        return XEiJ.regRn[14] -= 4;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (7 << 3);
        return XEiJ.regRn[15] -= 4;
      } else {
        M68kException.m6eIncremented -= 4L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 4;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMemLong

  //a = efaMltLong (ea)  //|  M+-WXZ  |
  //  メモリ可変モードのロングオペランドの実効アドレスを求める
  //  efaMemLongとの違いは(d16,PC)と(d8,PC,Rn.wl)がないこと
  @SuppressWarnings ("fallthrough") public static int efaMltLong (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (0 << 3);
        return (XEiJ.regRn[ 8] += 4) - 4;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (1 << 3);
        return (XEiJ.regRn[ 9] += 4) - 4;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (2 << 3);
        return (XEiJ.regRn[10] += 4) - 4;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (3 << 3);
        return (XEiJ.regRn[11] += 4) - 4;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (4 << 3);
        return (XEiJ.regRn[12] += 4) - 4;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (5 << 3);
        return (XEiJ.regRn[13] += 4) - 4;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (6 << 3);
        return (XEiJ.regRn[14] += 4) - 4;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 4L << (7 << 3);
        return (XEiJ.regRn[15] += 4) - 4;
      } else {
        M68kException.m6eIncremented += 4L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 4) - 4;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (0 << 3);
        return XEiJ.regRn[ 8] -= 4;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (1 << 3);
        return XEiJ.regRn[ 9] -= 4;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (2 << 3);
        return XEiJ.regRn[10] -= 4;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (3 << 3);
        return XEiJ.regRn[11] -= 4;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (4 << 3);
        return XEiJ.regRn[12] -= 4;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (5 << 3);
        return XEiJ.regRn[13] -= 4;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (6 << 3);
        return XEiJ.regRn[14] -= 4;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 4L << (7 << 3);
        return XEiJ.regRn[15] -= 4;
      } else {
        M68kException.m6eIncremented -= 4L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 4;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMltLong

  //a = efaCntLong (ea)  //|  M  WXZP |
  //  制御モードのロングオペランドの実効アドレスを求める
  //  efaMemLongとの違いは(Ar)+と-(Ar)がないこと
  @SuppressWarnings ("fallthrough") public static int efaCntLong (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaCntLong

  //a = efaCltLong (ea)  //|  M  WXZ  |
  //  制御可変モードのワードオペランドの実効アドレスを求める
  //  efaCntLongとの違いは(d16,PC)と(d8,PC,Rn.wl)がないこと
  @SuppressWarnings ("fallthrough") public static int efaCltLong (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaCltLong

  //a = efaAnyQuad (ea)  //|  M+-WXZPI|
  //  任意のモードのクワッドオペランドの実効アドレスを求める
  //  efaAnyLongとの違いは(Ar)+と-(Ar)がArを8変化させることと、#<data>がPCを8変化させることと、
  //  オペランドのアクセスが2ワード増える分の8サイクルが追加されていること
  @SuppressWarnings ("fallthrough") public static int efaAnyQuad (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (0 << 3);
        return (XEiJ.regRn[ 8] += 8) - 8;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (1 << 3);
        return (XEiJ.regRn[ 9] += 8) - 8;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (2 << 3);
        return (XEiJ.regRn[10] += 8) - 8;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (3 << 3);
        return (XEiJ.regRn[11] += 8) - 8;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (4 << 3);
        return (XEiJ.regRn[12] += 8) - 8;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (5 << 3);
        return (XEiJ.regRn[13] += 8) - 8;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (6 << 3);
        return (XEiJ.regRn[14] += 8) - 8;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (7 << 3);
        return (XEiJ.regRn[15] += 8) - 8;
      } else {
        M68kException.m6eIncremented += 8L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 8) - 8;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (0 << 3);
        return XEiJ.regRn[ 8] -= 8;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (1 << 3);
        return XEiJ.regRn[ 9] -= 8;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (2 << 3);
        return XEiJ.regRn[10] -= 8;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (3 << 3);
        return XEiJ.regRn[11] -= 8;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (4 << 3);
        return XEiJ.regRn[12] -= 8;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (5 << 3);
        return XEiJ.regRn[13] -= 8;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (6 << 3);
        return XEiJ.regRn[14] -= 8;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (7 << 3);
        return XEiJ.regRn[15] -= 8;
      } else {
        M68kException.m6eIncremented -= 8L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 8;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_100:  //#<data>
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regPC += 8) - 8;
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 8;
        return t;
      }
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaAnyQuad

  //a = efaMltQuad (ea)  //|  M+-WXZ  |
  //  メモリ可変モードのクワッドオペランドの実効アドレスを求める
  //  efaMltLongとの違いは(Ar)+と-(Ar)がArを8変化させることと、#<data>がPCを8変化させることと、
  //  オペランドのアクセスが2ワード増える分の8サイクルが追加されていること
  @SuppressWarnings ("fallthrough") public static int efaMltQuad (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (0 << 3);
        return (XEiJ.regRn[ 8] += 8) - 8;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (1 << 3);
        return (XEiJ.regRn[ 9] += 8) - 8;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (2 << 3);
        return (XEiJ.regRn[10] += 8) - 8;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (3 << 3);
        return (XEiJ.regRn[11] += 8) - 8;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (4 << 3);
        return (XEiJ.regRn[12] += 8) - 8;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (5 << 3);
        return (XEiJ.regRn[13] += 8) - 8;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (6 << 3);
        return (XEiJ.regRn[14] += 8) - 8;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 8L << (7 << 3);
        return (XEiJ.regRn[15] += 8) - 8;
      } else {
        M68kException.m6eIncremented += 8L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 8) - 8;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (0 << 3);
        return XEiJ.regRn[ 8] -= 8;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (1 << 3);
        return XEiJ.regRn[ 9] -= 8;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (2 << 3);
        return XEiJ.regRn[10] -= 8;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (3 << 3);
        return XEiJ.regRn[11] -= 8;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (4 << 3);
        return XEiJ.regRn[12] -= 8;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (5 << 3);
        return XEiJ.regRn[13] -= 8;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (6 << 3);
        return XEiJ.regRn[14] -= 8;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 8L << (7 << 3);
        return XEiJ.regRn[15] -= 8;
      } else {
        M68kException.m6eIncremented -= 8L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 8;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMltQuad

  //a = efaAnyExtd (ea)  //|  M+-WXZPI|
  //  任意のモードのエクステンデッドオペランドの実効アドレスを求める
  //  efaAnyQuadとの違いは(Ar)+と-(Ar)がArを12変化させることと、#<data>がPCを12変化させることと、
  //  オペランドのアクセスが2ワード増える分の8サイクルが追加されていること
  @SuppressWarnings ("fallthrough") public static int efaAnyExtd (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (0 << 3);
        return (XEiJ.regRn[ 8] += 12) - 12;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (1 << 3);
        return (XEiJ.regRn[ 9] += 12) - 12;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (2 << 3);
        return (XEiJ.regRn[10] += 12) - 12;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (3 << 3);
        return (XEiJ.regRn[11] += 12) - 12;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (4 << 3);
        return (XEiJ.regRn[12] += 12) - 12;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (5 << 3);
        return (XEiJ.regRn[13] += 12) - 12;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (6 << 3);
        return (XEiJ.regRn[14] += 12) - 12;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (7 << 3);
        return (XEiJ.regRn[15] += 12) - 12;
      } else {
        M68kException.m6eIncremented += 12L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 12) - 12;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (0 << 3);
        return XEiJ.regRn[ 8] -= 12;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (1 << 3);
        return XEiJ.regRn[ 9] -= 12;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (2 << 3);
        return XEiJ.regRn[10] -= 12;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (3 << 3);
        return XEiJ.regRn[11] -= 12;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (4 << 3);
        return XEiJ.regRn[12] -= 12;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (5 << 3);
        return XEiJ.regRn[13] -= 12;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (6 << 3);
        return XEiJ.regRn[14] -= 12;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (7 << 3);
        return XEiJ.regRn[15] -= 12;
      } else {
        M68kException.m6eIncremented -= 12L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 12;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_100:  //#<data>
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regPC += 12) - 12;
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 12;
        return t;
      }
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaAnyExtd

  //a = efaMltExtd (ea)  //|  M+-WXZ  |
  //  メモリ可変モードのエクステンデッドオペランドの実効アドレスを求める
  //  efaMltQuadとの違いは(Ar)+と-(Ar)がArを12変化させることと、#<data>がPCを12変化させることと、
  //  オペランドのアクセスが2ワード増える分の8サイクルが追加されていること
  @SuppressWarnings ("fallthrough") public static int efaMltExtd (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b011_000:  //(A0)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (0 << 3);
        return (XEiJ.regRn[ 8] += 12) - 12;
      }
      //fallthrough
    case 0b011_001:  //(A1)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (1 << 3);
        return (XEiJ.regRn[ 9] += 12) - 12;
      }
      //fallthrough
    case 0b011_010:  //(A2)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (2 << 3);
        return (XEiJ.regRn[10] += 12) - 12;
      }
      //fallthrough
    case 0b011_011:  //(A3)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (3 << 3);
        return (XEiJ.regRn[11] += 12) - 12;
      }
      //fallthrough
    case 0b011_100:  //(A4)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (4 << 3);
        return (XEiJ.regRn[12] += 12) - 12;
      }
      //fallthrough
    case 0b011_101:  //(A5)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (5 << 3);
        return (XEiJ.regRn[13] += 12) - 12;
      }
      //fallthrough
    case 0b011_110:  //(A6)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (6 << 3);
        return (XEiJ.regRn[14] += 12) - 12;
      }
      //fallthrough
    case 0b011_111:  //(A7)+
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented += 12L << (7 << 3);
        return (XEiJ.regRn[15] += 12) - 12;
      } else {
        M68kException.m6eIncremented += 12L << ((ea & 7) << 3);
        return (XEiJ.regRn[ea - (0b011_000 - 8)] += 12) - 12;
      }
    case 0b100_000:  //-(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (0 << 3);
        return XEiJ.regRn[ 8] -= 12;
      }
      //fallthrough
    case 0b100_001:  //-(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (1 << 3);
        return XEiJ.regRn[ 9] -= 12;
      }
      //fallthrough
    case 0b100_010:  //-(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (2 << 3);
        return XEiJ.regRn[10] -= 12;
      }
      //fallthrough
    case 0b100_011:  //-(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (3 << 3);
        return XEiJ.regRn[11] -= 12;
      }
      //fallthrough
    case 0b100_100:  //-(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (4 << 3);
        return XEiJ.regRn[12] -= 12;
      }
      //fallthrough
    case 0b100_101:  //-(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (5 << 3);
        return XEiJ.regRn[13] -= 12;
      }
      //fallthrough
    case 0b100_110:  //-(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (6 << 3);
        return XEiJ.regRn[14] -= 12;
      }
      //fallthrough
    case 0b100_111:  //-(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        M68kException.m6eIncremented -= 12L << (7 << 3);
        return XEiJ.regRn[15] -= 12;
      } else {
        M68kException.m6eIncremented -= 12L << ((ea & 7) << 3);
        return XEiJ.regRn[ea - (0b100_000 - 8)] -= 12;
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaMltExtd

  //a = efaLeaPea (ea)  //|  M  WXZP |
  //  LEA命令とPEA命令のオペランドの実効アドレスを求める
  //  efaCntWordとの違いはサイクル数のみ
  //  LEA命令のベースサイクル数4を含んでいるのでLEA命令ではベースサイクル数を加えなくてよい
  //  PEA命令のベースサイクル数は12-4=8
  @SuppressWarnings ("fallthrough") public static int efaLeaPea (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaLeaPea

  //a = efaJmpJsr (ea)  //|  M  WXZP |
  //  JMP命令とJSR命令のオペランドの実効アドレスを求める
  //  efaCntWordとの違いはサイクル数のみ
  //  JMP命令のベースサイクル数8を含んでいるのでJMP命令ではベースサイクル数を加えなくてよい
  //  JSR命令のベースサイクル数は16-8=8
  @SuppressWarnings ("fallthrough") public static int efaJmpJsr (int ea) throws M68kException {
    int t, w, x;
    switch (ea) {
    case 0b010_000:  //(A0)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 8];
      }
      //fallthrough
    case 0b010_001:  //(A1)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[ 9];
      }
      //fallthrough
    case 0b010_010:  //(A2)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[10];
      }
      //fallthrough
    case 0b010_011:  //(A3)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[11];
      }
      //fallthrough
    case 0b010_100:  //(A4)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[12];
      }
      //fallthrough
    case 0b010_101:  //(A5)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[13];
      }
      //fallthrough
    case 0b010_110:  //(A6)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[14];
      }
      //fallthrough
    case 0b010_111:  //(A7)
      if (XEiJ.EFA_SEPARATE_AR) {
        return XEiJ.regRn[15];
      } else {
        return XEiJ.regRn[ea - (0b010_000 - 8)];
      }
    case 0b101_000:  //(d16,A0)
    case 0b101_001:  //(d16,A1)
    case 0b101_010:  //(d16,A2)
    case 0b101_011:  //(d16,A3)
    case 0b101_100:  //(d16,A4)
    case 0b101_101:  //(d16,A5)
    case 0b101_110:  //(d16,A6)
    case 0b101_111:  //(d16,A7)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      } else {
        t = XEiJ.regPC;
        XEiJ.regPC = t + 2;
        return (XEiJ.regRn[ea - (0b101_000 - 8)]  //ベースレジスタ
                + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
      }
    case 0b110_000:  //(d8,A0,Rn.wl)
    case 0b110_001:  //(d8,A1,Rn.wl)
    case 0b110_010:  //(d8,A2,Rn.wl)
    case 0b110_011:  //(d8,A3,Rn.wl)
    case 0b110_100:  //(d8,A4,Rn.wl)
    case 0b110_101:  //(d8,A5,Rn.wl)
    case 0b110_110:  //(d8,A6,Rn.wl)
    case 0b110_111:  //(d8,A7,Rn.wl)
      if (XEiJ.MPU_COMPOUND_POSTINCREMENT) {
        w = mmuReadWordZeroExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcwz。拡張ワード
      } else {
        w = XEiJ.regPC;
        XEiJ.regPC = w + 2;
        w = mmuReadWordZeroExword (w, XEiJ.regSRS);  //pcwz。拡張ワード
      }
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            XEiJ.regRn[ea - (0b110_000 - 8)])  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    case 0b111_000:  //(xxx).W
      return mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS);  //pcws
    case 0b111_001:  //(xxx).L
      return mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS);  //pcls
    case 0b111_010:  //(d16,PC)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      return (t  //ベースレジスタ
              + mmuReadWordSignExword (t, XEiJ.regSRS));  //pcws。ワードディスプレースメント
    case 0b111_011:  //(d8,PC,Rn.wl)
      t = XEiJ.regPC;
      XEiJ.regPC = t + 2;
      w = mmuReadWordZeroExword (t, XEiJ.regSRS);  //pcwz。拡張ワード
      if (w << 31 - 8 < 0) {  //フルフォーマット
        XEiJ.mpuCycleCount += w << -2 == 0 ? 1 : 3;  //メモリ間接なし:メモリ間接あり
      }
      t = (((~w & 0x0180) == 0 ? 0 :  //ベースレジスタサプレス
            t)  //ベースレジスタ
           + (w << 31 - 8 >= 0 ? (byte) w :  //バイトディスプレースメント
              w << 31 - 5 >= 0 ? 0 :  //ヌルベースディスプレースメント
              w << 31 - 4 >= 0 ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードベースディスプレースメント
              mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングベースディスプレースメント
      x = ((~w & 0x0140) == 0 ? 0 :  //インデックスサプレス
           (w << 31 - 11 >= 0 ? (short) XEiJ.regRn[w >> 12] :  //ワードインデックス
            XEiJ.regRn[w >> 12])  //ロングインデックス
           << (w >> 9 & 3));  //スケールファクタ。ワードインデックスのときは符号拡張してから掛ける
      return ((w & 0x0103) <= 0x0100 ? t + x :  //メモリ間接なし
              ((XEiJ.TEST_BIT_2_SHIFT ? w << 31 - 2 >= 0 : (w & 4) == 0) ? mmuReadLongData (t + x, XEiJ.regSRS) :  //プリインデックス
               mmuReadLongData (t, XEiJ.regSRS) + x)  //ポストインデックス
              + ((XEiJ.TEST_BIT_1_SHIFT ? w << 31 - 1 >= 0 : (w & 2) == 0) ? 0 :  //ヌルアウタディスプレースメント
                 (XEiJ.TEST_BIT_0_SHIFT ? w << 31 - 0 >= 0 : (w & 1) == 0) ? mmuReadWordSignExword ((XEiJ.regPC += 2) - 2, XEiJ.regSRS) :  //pcws。ワードアウタディスプレースメント
                 mmuReadLongExword ((XEiJ.regPC += 4) - 4, XEiJ.regSRS)));  //pcls。ロングアウタディスプレースメント
    }  //switch
    M68kException.m6eNumber = M68kException.M6E_ILLEGAL_INSTRUCTION;
    throw M68kException.m6eSignal;
  }  //efaJmpJsr



  //fpkSTOL ()
  //  $FE10  __STOL
  //  10進数の文字列を32bit符号あり整数に変換する
  //  /^[ \t]*[-+]?[0-9]+/
  //  先頭の'\t'と' 'を読み飛ばす
  //  <a0.l:10進数の文字列の先頭
  //  >d0.l:32bit符号あり整数
  //  >a0.l:10進数の文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkSTOL () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    int c = mmuReadByteZeroData (a, 1);
    while (c == ' ' || c == '\t') {
      c = mmuReadByteZeroData (++a, 1);
    }
    int n = '7';  //'7'=正,'8'=負
    if (c == '-') {  //負
      n = '8';
      c = mmuReadByteZeroData (++a, 1);
    } else if (c == '+') {  //正
      c = mmuReadByteZeroData (++a, 1);
    }
    if (!('0' <= c && c <= '9')) {  //数字が1つもない
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;
      return;
    }
    int x = c - '0';  //値
    for (c = mmuReadByteZeroData (++a, 1); '0' <= c && c <= '9'; c = mmuReadByteZeroData (++a, 1)) {
      if (214748364 < x || x == 214748364 && n < c) {  //正のとき2147483647、負のとき2147483648より大きくなるときオーバーフロー
        XEiJ.regRn[8] = a;  //a0
        XEiJ.regCCR = XEiJ.REG_CCR_V | XEiJ.REG_CCR_C;
        return;
      }
      x = x * 10 + (c - '0');
    }
    if (n != '7') {  //負
      x = -x;
    }
    XEiJ.regRn[0] = x;  //d0
    XEiJ.regRn[8] = a;  //a0
    XEiJ.regCCR = 0;
  }  //fpkSTOL()

  //fpkLTOS ()
  //  $FE11  __LTOS
  //  32bit符号あり整数を10進数の文字列に変換する
  //  /^-?[1-9][0-9]*$/
  //  <d0.l:32bit符号あり整数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:10進数の文字列の直後('\0'の位置)
  public static void fpkLTOS () throws M68kException {
    int x = XEiJ.regRn[0];  //d0
    int a = XEiJ.regRn[8];  //a0
    if (x < 0) {  //負
      mmuWriteByteData (a++, '-', 1);
      x = -x;
    }
    long t = XEiJ.fmtBcd12 (0xffffffffL & x);  //符号は取り除いてあるがx=0x80000000の場合があるので(long)xは不可
    XEiJ.regRn[8] = a += Math.max (1, 67 - Long.numberOfLeadingZeros (t) >> 2);  //a0
    mmuWriteByteData (a, 0, 1);
    do {
      mmuWriteByteData (--a, '0' | (int) t & 15, 1);
    } while ((t >>>= 4) != 0L);
  }  //fpkLTOS()

  //fpkSTOH ()
  //  $FE12  __STOH
  //  16進数の文字列を32bit符号なし整数に変換する
  //  /^[0-9A-Fa-f]+/
  //  <a0.l:16進数の文字列の先頭
  //  >d0.l:32bit符号なし整数
  //  >a0.l:16進数の文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkSTOH () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    int c = mmuReadByteZeroData (a, 1);
    if (!('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f')) {  //数字が1つもない
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;
      return;
    }
    int x = c <= '9' ? c - '0' : c <= 'F' ? c - ('A' - 10) : c - ('a' - 10);  //値
    for (c = mmuReadByteZeroData (++a, 1); '0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f'; c = mmuReadByteZeroData (++a, 1)) {
      if (0x0fffffff < x) {  //0xffffffffより大きくなるときオーバーフロー
        XEiJ.regRn[8] = a;  //a0
        XEiJ.regCCR = XEiJ.REG_CCR_V | XEiJ.REG_CCR_C;
        return;
      }
      x = x << 4 | (c <= '9' ? c - '0' : c <= 'F' ? c - ('A' - 10) : c - ('a' - 10));
    }
    XEiJ.regRn[0] = x;  //d0
    XEiJ.regRn[8] = a;  //a0
    XEiJ.regCCR = 0;
  }  //fpkSTOH()

  //fpkHTOS ()
  //  $FE13  __HTOS
  //  32bit符号なし整数を16進数の文字列に変換する
  //  /^[1-9A-F][0-9A-F]*$/
  //  <d0.l:32bit符号なし整数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:16進数の文字列の直後('\0'の位置)
  public static void fpkHTOS () throws M68kException {
    int x = XEiJ.regRn[0];  //d0
    int a = XEiJ.regRn[8] += Math.max (1, 35 - Integer.numberOfLeadingZeros (x) >> 2);  //a0
    mmuWriteByteData (a, 0, 1);
    do {
      int t = x & 15;
      //     t             00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
      //   9-t             09 08 07 06 05 04 03 02 01 00 ff fe fd fc fb fa
      //   9-t>>4          00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff
      //   9-t>>4&7        00 00 00 00 00 00 00 00 00 00 07 07 07 07 07 07
      //   9-t>>4&7|48     30 30 30 30 30 30 30 30 30 30 37 37 37 37 37 37
      //  (9-t>>4&7|48)+t  30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46
      //                    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
      mmuWriteByteData (--a, (9 - t >> 4 & 7 | 48) + t, 1);
    } while ((x >>>= 4) != 0);
  }  //fpkHTOS()

  //fpkSTOO ()
  //  $FE14  __STOO
  //  8進数の文字列を32bit符号なし整数に変換する
  //  /^[0-7]+/
  //  <a0.l:8進数の文字列の先頭
  //  >d0.l:32bit符号なし整数
  //  >a0.l:8進数の文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkSTOO () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    int c = mmuReadByteZeroData (a, 1);
    if (!('0' <= c && c <= '7')) {  //数字が1つもない
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;
      return;
    }
    int x = c - '0';  //値
    for (c = mmuReadByteZeroData (++a, 1); '0' <= c && c <= '7'; c = mmuReadByteZeroData (++a, 1)) {
      if (0x1fffffff < x) {  //0xffffffffより大きくなるときオーバーフロー
        XEiJ.regRn[8] = a;  //a0
        XEiJ.regCCR = XEiJ.REG_CCR_V | XEiJ.REG_CCR_C;
        return;
      }
      x = x << 3 | c & 7;
    }
    XEiJ.regRn[0] = x;  //d0
    XEiJ.regRn[8] = a;  //a0
    XEiJ.regCCR = 0;
  }  //fpkSTOO()

  //fpkOTOS ()
  //  $FE15  __OTOS
  //  32bit符号なし整数を8進数の文字列に変換する
  //  /^[1-7][0-7]*$/
  //  <d0.l:32bit符号なし整数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:8進数の文字列の直後('\0'の位置)
  public static void fpkOTOS () throws M68kException {
    int x = XEiJ.regRn[0];  //d0
    //perl optdiv.pl 34 3
    //  x/3==x*43>>>7 (0<=x<=127) [34*43==1462]
    int a = XEiJ.regRn[8] += Math.max (1, (34 - Integer.numberOfLeadingZeros (x)) * 43 >>> 7);  //a0
    mmuWriteByteData (a, 0, 1);
    do {
      mmuWriteByteData (--a, '0' | x & 7, 1);
    } while ((x >>>= 3) != 0);
  }  //fpkOTOS()

  //fpkSTOB ()
  //  $FE16  __STOB
  //  2進数の文字列を32bit符号なし整数に変換する
  //  /^[01]+/
  //  <a0.l:2進数の文字列の先頭
  //  >d0.l:32bit符号なし整数
  //  >a0.l:2進数の文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkSTOB () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    int c = mmuReadByteZeroData (a, 1);
    if (!('0' <= c && c <= '1')) {  //数字が1つもない
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;
      return;
    }
    int x = c - '0';  //値
    for (c = mmuReadByteZeroData (++a, 1); '0' <= c && c <= '1'; c = mmuReadByteZeroData (++a, 1)) {
      if (x < 0) {  //オーバーフロー
        XEiJ.regRn[8] = a;  //a0
        XEiJ.regCCR = XEiJ.REG_CCR_V | XEiJ.REG_CCR_C;
        return;
      }
      x = x << 1 | c & 1;
    }
    XEiJ.regRn[0] = x;  //d0
    XEiJ.regRn[8] = a;  //a0
    XEiJ.regCCR = 0;
  }  //fpkSTOB()

  //fpkBTOS ()
  //  $FE17  __BTOS
  //  32bit符号なし整数を2進数の文字列に変換する
  //  /^1[01]*$/
  //  <d0.l:32bit符号なし整数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:2進数の文字列の直後('\0'の位置)
  public static void fpkBTOS () throws M68kException {
    int x = XEiJ.regRn[0];  //d0
    int a = XEiJ.regRn[8] += Math.max (1, 32 - Integer.numberOfLeadingZeros (x));  //a0
    mmuWriteByteData (a, 0, 1);
    do {
      mmuWriteByteData (--a, '0' | x & 1, 1);
    } while ((x >>>= 1) != 0);
  }  //fpkBTOS()

  //fpkIUSING ()
  //  $FE18  __IUSING
  //  32bit符号あり整数を文字数を指定して右詰めで10進数の文字列に変換する
  //  /^ *-?[1-9][0-9]*$/
  //  <d0.l:32bit符号あり整数
  //  <d1.b:文字数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:10進数の文字列の直後('\0'の位置)
  public static void fpkIUSING () throws M68kException {
    int x = XEiJ.regRn[0];  //d0
    int n = 0;  //符号の文字数
    if (x < 0) {  //負
      n = 1;
      x = -x;
    }
    long t = XEiJ.fmtBcd12 (0xffffffffL & x);  //符号は取り除いてあるがx=0x80000000の場合があるので(long)xは不可
    int l = n + Math.max (1, 67 - Long.numberOfLeadingZeros (t) >> 2);  //符号を含めた文字数
    int a = XEiJ.regRn[8];  //a0
    for (int i = (XEiJ.regRn[1] & 255) - l; i > 0; i--) {
      mmuWriteByteData (a++, ' ', 1);
    }
    XEiJ.regRn[8] = a += l;  //a0
    mmuWriteByteData (a, 0, 1);
    do {
      mmuWriteByteData (--a, '0' | (int) t & 15, 1);
    } while ((t >>>= 4) != 0L);
    if (n != 0) {
      mmuWriteByteData (--a, '-', 1);
    }
  }  //fpkIUSING()

  //fpkVAL ()
  //  $FE20  __VAL
  //  文字列を64bit浮動小数点数に変換する
  //  先頭の'\t'と' 'を読み飛ばす
  //  "&B"または"&b"で始まっているときは続きを2進数とみなして__STOBで32bit符号なし整数に変換してから__LTODで64bit浮動小数点数に変換する
  //  "&O"または"&o"で始まっているときは続きを8進数とみなして__STOOで32bit符号なし整数に変換してから__LTODで64bit浮動小数点数に変換する
  //  "&H"または"&h"で始まっているときは続きを16進数とみなして__STOHで32bit符号なし整数に変換してから__LTODで64bit浮動小数点数に変換する
  //  それ以外は__STODと同じ
  //  <a0.l:文字列の先頭
  //  >d0d1.d:64bit浮動小数点数
  //  >d2.l:(先頭が'&'でないとき)65535=64bit浮動小数点数をオーバーフローなしでintに変換できる,0=それ以外
  //  >d3.l:(先頭が'&'でないとき)d2.l==65535のとき64bit浮動小数点数をintに変換した値
  //  >a0.l:変換された文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkVAL () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    //先頭の空白を読み飛ばす
    int c = mmuReadByteSignData (a++, 1);
    while (c == ' ' || c == '\t') {
      c = mmuReadByteSignData (a++, 1);
    }
    if (c == '&') {  //&B,&O,&H
      c = mmuReadByteSignData (a++, 1) & 0xdf;
      XEiJ.regRn[8] = a;  //&?の直後
      if (c == 'B') {
        fpkSTOB ();
        FEFunction.fpkLTOD ();
      } else if (c == 'O') {
        fpkSTOO ();
        FEFunction.fpkLTOD ();
      } else if (c == 'H') {
        fpkSTOH ();
        FEFunction.fpkLTOD ();
      } else {
        XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;  //文法エラー
      }
    } else {  //&B,&O,&H以外
      fpkSTOD ();
    }
  }  //fpkVAL()

  //fpkUSING ()
  //  $FE21  __USING
  //  64bit浮動小数点数をアトリビュートを指定して文字列に変換する
  //  メモ
  //    bit1の'\\'とbit4の'+'を両方指定したときは'\\'が右側。先頭に"+\\"を付ける
  //    bit1の'\\'とbit2の','とbit4の'+'は整数部の桁数が足りないとき数字を右にずらして押し込まれる
  //    bit3で指数形式を指示しなければ指数部が極端に大きくても極端に小さくても指数形式にならない
  //    bit3で指数形式を指定したときbit1の'\\'とbit2の','は無効
  //    bit4とbit5とbit6はbit4>bit5>bit6の順位で1つだけ有効
  //    有効数字は14桁で15桁目以降はすべて0
  //    FLOAT2.Xは整数部の0でない最初の数字から256文字目までで打ち切られてしまう
  //    整数部の桁数に余裕があれば左側の空白は出力されるので文字列の全体が常に256バイトに収まるわけではない
  //      using 1234.5 5 0 0    " 1235."
  //      using 1234.5 5 1 0    " 1234.5"
  //      using 1234.5 5 2 0    " 1234.50"
  //      using 1234.5 6 2 1    "**1234.50"
  //      using 1234.5 6 2 2    " \\1234.50"
  //      using 1234.5 6 2 3    "*\\1234.50"
  //      using 1234.5 6 2 4    " 1,234.50"
  //      using 1234.5 4 2 4    "1,234.50"
  //      using 1234.5 4 2 5    "1,234.50"
  //      using 1234.5 4 2 6    "\\1,234.50"
  //      using 1234.5 4 2 7    "\\1,234.50"
  //      using 1234.5 4 2 16   "+1234.50"
  //      using 1234.5 4 2 22   "+\\1,234.50"
  //      using 1234.5 4 2 32   "1234.50+"
  //      using 1234.5 4 2 48   "+1234.50"
  //      using 1234.5 4 2 64   "1234.50 "
  //      using 1234.5 4 2 80   "+1234.50"
  //      using 1234.5 4 2 96   "1234.50+"
  //      using 12345678901234567890 10 1 0      "12345678901235000000.0"
  //      using 12345678901234567890e+10 10 1 0  "123456789012350000000000000000.0"
  //      using 0.3333 0 0 0    "."
  //      using 0.6666 0 0 0    "1."
  //      using 0.6666 0 3 0    ".667"
  //      using 0.6666 3 0 0    "  1."
  //      using 0.3333 0 0 2    "\\."
  //      using 0.3333 0 0 16   "+."
  //      using 0.3333 0 0 18   "+\\."
  //      using 1e-10 3 3 0     "  0.000"
  //    指数形式の出力は不可解で本来の動作ではないように思えるが、
  //    X-BASICのprint using命令が使っているのでFLOAT2.Xに合わせておいた方がよさそう
  //      print using "###.##";1.23         "  1.23"         整数部の桁数は3
  //      print using "+##.##";1.23         " +1.23"         整数部の桁数は3←
  //      print using "###.##^^^^^";1.23    " 12.30E-001"    整数部の桁数は3
  //      print using "+##.##^^^^^";1.23    "+12.30E-001"    整数部の桁数は2←
  //    FLOAT2.Xでは#NANと#INFは4桁の整数のように出力される。末尾に小数点が付くが小数部には何も出力されない
  //      using -#INF 7 3 23     "*-\\#,INF."
  //    FLOAT2.Xで#NANと#INFを指数形式にするとさらに不可解。これはバグと言ってよいと思う
  //      using #INF 10 10 8      " #INFE-005"
  //    ここでは#NANと#INFは整数部と小数点と小数部と指数部の全体を使って右寄せにする
  //  <d0d1.d:64bit浮動小数点数
  //  <d2.l:整数部の桁数
  //  <d3.l:小数部の桁数
  //  <d4.l:アトリビュート
  //    bit0  左側を'*'で埋める
  //    bit1  先頭に'\\'を付ける
  //    bit2  整数部を3桁毎に','で区切る
  //    bit3  指数形式
  //    bit4  先頭に符号('+'または'-')を付ける
  //    bit5  末尾に符号('+'または'-')を付ける
  //    bit6  末尾に符号(' 'または'-')を付ける
  //  <a0.l:文字列バッファの先頭
  //  a0は変化しない
  public static void fpkUSING () throws M68kException {
    fpkUSINGSub ((long) XEiJ.regRn[0] << 32 | 0xffffffffL & XEiJ.regRn[1]);  //64bit浮動小数点数
  }  //fpkUSING()
  public static void fpkUSINGSub (long l) throws M68kException {
    int len1 = Math.max (0, XEiJ.regRn[2]);  //整数部の桁数
    int len2 = Math.max (0, XEiJ.regRn[3]);  //小数部の桁数
    int attr = XEiJ.regRn[4];  //アトリビュート
    int a = XEiJ.regRn[8];  //文字列バッファの先頭
    boolean exp = (attr & 8) != 0;  //true=指数形式
    int spc = (attr & 1) != 0 ? '*' : ' ';  //先頭の空白を充填する文字
    int yen = (attr & 2) != 0 ? '\\' : 0;  //先頭の'\\'
    int cmm = !exp && (attr & 4) != 0 ? ',' : 0;  //3桁毎に入れる','
    //符号
    int sgn1 = 0;  //先頭の符号
    int sgn2 = 0;  //末尾の符号
    if (l < 0L) {  //負
      if ((attr & 32 + 64) == 0) {  //末尾に符号を付けない
        sgn1 = '-';  //先頭の符号
      } else {  //末尾に符号を付ける
        sgn2 = '-';  //末尾の符号
      }
      l &= 0x7fffffffffffffffL;  //符号bitを消しておく
    } else {  //正
      if ((attr & 16) != 0) {  //先頭に符号('+'または'-')を付ける
        sgn1 = '+';
      } else if ((attr & 16 + 32) == 32) {  //末尾に符号('+'または'-')を付ける
        sgn2 = '+';
      } else if ((attr & 16 + 32 + 64) == 64) {  //末尾に符号(' 'または'-')を付ける
        sgn2 = ' ';
      }
    }
    double x = Double.longBitsToDouble (l);  //絶対値
    int e = (int) (l >>> 52) - 1023;  //指数部。ゲタ0。符号bitは消してあるのでマスクは不要
    l &= 0x000fffffffffffffL;  //仮数部の小数部。正規化数のとき整数部の1が付いていないことに注意
    //±0,±Inf,NaN
    if (e == -1023) {  //±0,非正規化数
      if (l == 0L) {  //±0
        for (int i = len1 - ((sgn1 != 0 ? 1 : 0) +  //先頭の符号
                             (yen != 0 ? 1 : 0) +  //'\\'
                             1  //数字
                             ); 0 < i; i--) {
          mmuWriteByteData (a++, spc, 1);  //空白
        }
        if (sgn1 != 0) {
          mmuWriteByteData (a++, sgn1, 1);  //先頭の符号
        }
        if (yen != 0) {
          mmuWriteByteData (a++, yen, 1);  //'\\'
        }
        if (0 < len1) {
          mmuWriteByteData (a++, '0', 1);  //整数部
        }
        mmuWriteByteData (a++, '.', 1);  //小数点
        for (; 0 < len2; len2--) {
          mmuWriteByteData (a++, '0', 1);  //小数部
        }
        mmuWriteByteData (a, '\0', 1);
        return;
      }
      e -= Long.numberOfLeadingZeros (l) - 12;  //非正規化数の指数部を補正する
    } else if (e == 1024) {  //±Inf,NaN
      for (int i = len1 + 1 + len2 + (exp ? 5 : 0) -  //整数部と小数点と小数部と指数部の全体を使って右寄せにする
           ((sgn1 != 0 ? 1 : 0) +  //先頭の符号
            (yen != 0 ? 1 : 0) +  //'\\'
            4  //文字
            ); 0 < i; i--) {
        mmuWriteByteData (a++, spc, 1);  //空白
      }
      if (sgn1 != 0) {
        mmuWriteByteData (a++, sgn1, 1);  //先頭の符号
      }
      if (yen != 0) {
        mmuWriteByteData (a++, yen, 1);  //'\\'
      }
      mmuWriteByteData (a++, '#', 1);
      if (l == 0L) {  //±Inf
        mmuWriteByteData (a++, 'I', 1);
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'F', 1);
      } else {  //NaN
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'A', 1);
        mmuWriteByteData (a++, 'N', 1);
      }
      mmuWriteByteData (a, '\0', 1);
      return;
    }
    //10進数で表現したときの指数部を求める
    //  10^e<=x<10^(e+1)となるeを求める
    e = (int) Math.floor ((double) e * 0.30102999566398119521373889472);  //log10(2)
    //10^-eを掛けて1<=x<10にする
    //  非正規化数の最小値から正規化数の最大値まで処理できなければならない
    //  10^-eを計算してからまとめて掛ける方法はxが非正規化数のとき10^-eがオーバーフローしてしまうので不可
    //    doubleは非正規化数の逆数を表現できない
    if (0 < e) {  //10<=x
      x *= FEFunction.FPK_TEN_M16QR[e & 15];
      if (16 <= e) {
        x *= FEFunction.FPK_TEN_M16QR[16 + (e >> 4 & 15)];
        if (256 <= e) {
          x *= FEFunction.FPK_TEN_M16QR[33];  //FEFunction.FPK_TEN_M16QR[32 + (e >> 8)]
        }
      }
    } else if (e < 0) {  //x<1
      x *= FEFunction.FPK_TEN_P16QR[-e & 15];
      if (e <= -16) {
        x *= FEFunction.FPK_TEN_P16QR[16 + (-e >> 4 & 15)];
        if (e <= -256) {
          x *= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (-e >> 8)]
        }
      }
    }
    //整数部2桁、小数部16桁の10進数に変換する
    //  1<=x<10なのでw[1]が先頭になるはずだが誤差で前後にずれる可能性がある
    int[] w = new int[18];
    {
      int d = (int) x;
      int t = XEiJ.FMT_BCD4[d];
      w[0] = t >> 4;
      w[1] = t      & 15;
      for (int i = 2; i < 18; i += 4) {
        //xを10000倍して整数部dを引くことで小数部を残すが、このとき情報落ちが発生して誤差が蓄積する
        //Double-Doubleの乗算の要領で10000倍を正確に行い、誤差の蓄積を回避する
        //x = (x - (double) d) * 10000.0;
        double xh = x * 0x8000001p0;
        xh += x - xh;  //xの上半分
        x = (xh - (double) d) * 10000.0 + (x - xh) * 10000.0;
        d = (int) x;
        t = XEiJ.FMT_BCD4[d];
        w[i    ] = t >> 12;
        w[i + 1] = t >>  8 & 15;
        w[i + 2] = t >>  4 & 15;
        w[i + 3] = t       & 15;
      }
    }
    //先頭の位置を確認する
    //  w[h]が先頭(0でない最初の数字)の位置
    int h = w[0] != 0 ? 0 : w[1] != 0 ? 1 : 2;
    //14+1桁目を四捨五入する
    int o = h + 14;  //w[o]は四捨五入する桁の位置。w[]の範囲内
    if (5 <= w[o]) {
      int i = o;
      while (10 <= ++w[--i]) {
        w[i] = 0;
      }
      if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
        h--;  //先頭を左にずらす
        o--;  //末尾を左にずらす
      }
    }
    //先頭の位置に応じて指数部を更新する
    //  w[h]が整数部、w[h+1..13]が小数部。10^eの小数点はw[h]の右側。整数部の桁数はe+1桁
    e -= h - 1;
    //整数部の桁数を調節する
    int ee = !exp ? e : Math.max (0, sgn1 != 0 || sgn2 != 0 ? len1 : len1 - 1) - 1;  //整数部の桁数-1。整数部の桁数はee+1桁。指数部はe-ee
    //小数点以下len2+1桁目が先頭から14+1桁目よりも左側にあるときその桁で改めて四捨五入する
    //  あらかじめ14+1桁目で四捨五入しておかないと、
    //  1.5の5を四捨五入しなければならないときに誤差で1.499…になったまま4を四捨五入しようとして失敗することがある
    int s = h + ee + 1 + len2;  //w[s]は小数点以下len2+1桁目の位置。w.length<=sの場合があることに注意
    if (s < o) {
      o = s;  //w[o]は四捨五入する桁の位置。o<0の場合があることに注意
      if (0 <= o && 5 <= w[o]) {
        int i = o;
        while (10 <= ++w[--i]) {
          w[i] = 0;
        }
        if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
          h--;  //先頭を左にずらす
          if (!exp) {  //指数形式でないとき
            ee++;  //左に1桁伸ばす。全体の桁数が1桁増える
          } else {  //指数形式のとき
            e++;  //指数部を1増やす
            o--;  //末尾を左にずらす。全体の桁数は変わらない
          }
        }
      }
    }
    //文字列に変換する
    if (0 <= ee) {  //1<=x
      for (int i = len1 - ((sgn1 != 0 ? 1 : 0) +  //先頭の符号
                           (yen != 0 ? 1 : 0) +  //'\\'
                           (cmm != 0 ? ee / 3 : 0) +  //','
                           ee + 1  //数字
                           ); 0 < i; i--) {
        mmuWriteByteData (a++, spc, 1);  //空白
      }
      if (sgn1 != 0) {
        mmuWriteByteData (a++, sgn1, 1);  //先頭の符号
      }
      if (yen != 0) {
        mmuWriteByteData (a++, yen, 1);  //'\\'
      }
      for (int i = ee; 0 <= i; i--) {
        mmuWriteByteData (a++, h < o ? '0' + w[h] : '0', 1);  //整数部
        h++;
        if (cmm != 0 && 0 < i && i % 3 == 0) {
          mmuWriteByteData (a++, cmm, 1);  //','
        }
      }
      mmuWriteByteData (a++, '.', 1);  //小数点
      for (; 0 < len2; len2--) {
        mmuWriteByteData (a++, h < o ? '0' + w[h] : '0', 1);  //小数部
        h++;
      }
    } else {  //x<1
      for (int i = len1 - ((sgn1 != 0 ? 1 : 0) +  //先頭の符号
                           (yen != 0 ? 1 : 0) +  //'\\'
                           1  //数字
                           ); 0 < i; i--) {
        mmuWriteByteData (a++, spc, 1);  //空白
      }
      if (sgn1 != 0) {
        mmuWriteByteData (a++, sgn1, 1);  //先頭の符号
      }
      if (yen != 0) {
        mmuWriteByteData (a++, yen, 1);  //'\\'
      }
      if (0 < len1) {
        mmuWriteByteData (a++, '0', 1);  //整数部
      }
      mmuWriteByteData (a++, '.', 1);  //小数点
      for (int i = -1 - ee; 0 < len2 && 0 < i; len2--, i--) {
        mmuWriteByteData (a++, '0', 1);  //小数部の先頭の0の並び
      }
      for (; 0 < len2; len2--) {
        mmuWriteByteData (a++, h < o ? '0' + w[h] : '0', 1);  //小数部
        h++;
      }
    }
    if (exp) {
      e -= ee;
      mmuWriteByteData (a++, 'E', 1);  //指数部の始まり
      if (0 <= e) {
        mmuWriteByteData (a++, '+', 1);  //指数部の正符号。省略しない
      } else {
        mmuWriteByteData (a++, '-', 1);  //指数部の負符号
        e = -e;
      }
      e = XEiJ.FMT_BCD4[e];
      mmuWriteByteData (a++, '0' + (e >> 8     ), 1);  //指数部の100の位。0でも省略しない
      mmuWriteByteData (a++, '0' + (e >> 4 & 15), 1);  //指数部の10の位
      mmuWriteByteData (a++, '0' + (e      & 15), 1);  //指数部の1の位
    }
    if (sgn2 != 0) {
      mmuWriteByteData (a++, sgn2, 1);  //末尾の符号
    }
    mmuWriteByteData (a, '\0', 1);
  }  //fpkUSINGSub6(long)

  //fpkSTOD ()
  //  $FE22  __STOD
  //  文字列を64bit浮動小数点数に変換する
  //  先頭の'\t'と' 'を読み飛ばす
  //  "#INF"は無限大、"#NAN"は非数とみなす
  //  バグ
  //    FLOAT2.X 2.02/2.03は誤差が大きい
  //      "1.7976931348623E+308"=0x7fefffffffffffb0が0x7fefffffffffffb3になる
  //      "1.5707963267949"=0x3ff921fb54442d28が0x3ff921fb54442d26になる
  //      "4.9406564584125E-324"(非正規化数の最小値よりもわずかに大きい)がエラーになる
  //    FLOAT2.X 2.02/2.03は"-0"が+0になる
  //    FLOAT4.X 1.02は"-0"が+0になる(実機で確認済み)
  //    FLOAT2.X 2.02/2.03は"-#INF"が+Infになる
  //      print val("-#INF")で再現できる
  //      '-'を符号として解釈しておきながら結果の無限大に符号を付けるのを忘れている
  //    FLOAT2.X 2.02/2.03は".#INF"が+Infになる
  //      print val(".#INF")で再現できる
  //    FLOAT4.X 1.02は"#NAN","#INF","-#INF"を読み取ったときa0が文字列の直後ではなく最後の文字を指している
  //  <a0.l:文字列の先頭
  //  >d0d1.d:64bit浮動小数点数
  //  >d2.l:65535=64bit浮動小数点数をオーバーフローなしでintに変換できる,0=それ以外
  //  >d3.l:d2.l==65535のとき64bit浮動小数点数をintに変換した値
  //  >a0.l:変換された文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkSTOD () throws M68kException {
    long l = Double.doubleToLongBits (fpkSTODSub ());
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    XEiJ.regRn[0] = (int) (l >> 32);  //d0
    XEiJ.regRn[1] = (int) l;  //d1
  }  //fpkSTOD()
  public static double fpkSTODSub () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    //先頭の空白を読み飛ばす
    int c = mmuReadByteSignData (a, 1);
    while (c == ' ' || c == '\t') {
      c = mmuReadByteSignData (++a, 1);
    }
    //符号を読み取る
    double s = 1.0;  //仮数部の符号
    if (c == '+') {
      c = mmuReadByteSignData (++a, 1);
    } else if (c == '-') {
      s = -s;
      c = mmuReadByteSignData (++a, 1);
    }
    //#NANと#INFを処理する
    if (c == '#') {
      c = mmuReadByteSignData (a + 1, 1);
      if (c == 'N' || c == 'I') {  //小文字は不可
        c = c << 8 | mmuReadByteZeroData (a + 2, 1);
        if (c == ('N' << 8 | 'A') || c == ('I' << 8 | 'N')) {
          c = c << 8 | mmuReadByteZeroData (a + 3, 1);
          if (c == ('N' << 16 | 'A' << 8 | 'N') || c == ('I' << 16 | 'N' << 8 | 'F')) {
            XEiJ.regRn[2] = 0;  //d2
            XEiJ.regRn[3] = 0;  //d3
            XEiJ.regRn[8] = a + 4;  //a0。"#NAN"または"#INF"のときだけ直後まで進める。それ以外は'#'の位置で止める
            XEiJ.regCCR = 0;  //エラーなし。"#INF"はオーバーフローとみなされない
            return c == ('N' << 16 | 'A' << 8 | 'N') ? Double.NaN : s * Double.POSITIVE_INFINITY;
          }
        }
      }
      XEiJ.regRn[8] = a;  //a0。'#'の位置で止める
      XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;  //文法エラー
      return 0.0;
    }  //if c=='#'
    //仮数部を読み取る
    //  数字を1000個並べてからe-1000などと書いてあるとき途中でオーバーフローすると困るので、
    //  多すぎる数字の並びは先頭の有効数字だけ読み取って残りは桁数だけ数えて読み飛ばす
    long u = 0L;  //仮数部
    int n = 0;  //0以外の最初の数字から数えて何桁目か
    int e = 1;  //-小数部の桁数。1=整数部
    if (c == '.') {  //仮数部の先頭が小数点
      e = 0;  //小数部開始
      c = mmuReadByteSignData (++a, 1);
    }
    if (c < '0' || '9' < c) {  //仮数部に数字がない
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;  //文法エラー
      return 0.0;
    }
    double x = 0.0;
    do {
      if (0 < n || '0' < c) {  //0以外
        n++;  //0以外の最初の数字から数えて何桁目か
      }
      if (e <= 0 && n <= 18) {  //小数部で18桁目まで
        e--;  //-小数部の桁数
      }
      if (0 < n && n <= 18) {  //1桁目から18桁目まで
        u = u * 10L + (long) (c - '0');
      }
      c = mmuReadByteSignData (++a, 1);
      if (0 < e && c == '.') {  //整数部で小数点が出てきた
        e = 0;  //小数部開始
        c = mmuReadByteSignData (++a, 1);
      }
    } while ('0' <= c && c <= '9');
    if (0 < e) {  //小数点が出てこなかった
      e = 18 < n ? n - 18 : 0;  //整数部を読み飛ばした桁数が(-小数部の桁数)
    }
    //  1<=u<10^18  整数なので誤差はない
    //  0<e   小数点がなくて整数部が19桁以上あって末尾を読み飛ばした
    //  e==0  小数点がなくて整数部が18桁以内で末尾を読み飛ばさなかった
    //        小数点があって小数点で終わっていた
    //  e<0   小数点があって小数部が1桁以上あった
    //指数部を読み取る
    if (c == 'E' || c == 'e') {
      c = mmuReadByteSignData (++a, 1);
      int t = 1;  //指数部の符号
      if (c == '+') {
        c = mmuReadByteSignData (++a, 1);
      } else if (c == '-') {
        t = -t;
        c = mmuReadByteSignData (++a, 1);
      }
      if (c < '0' || '9' < c) {  //指数部に数字がない
        XEiJ.regRn[8] = a;  //a0
        XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;  //文法エラー
        return 0.0;
      }
      while (c == '0') {  //先頭の0を読み飛ばす
        c = mmuReadByteSignData (++a, 1);
      }
      int p = 0;
      for (int j = 0; '0' <= c && c <= '9' && j < 9; j++) {  //0以外の数字が出てきてから最大で9桁目まで読み取る。Human68kの環境では数字を1GBも並べることはできないのでオーバーフローの判定には9桁あれば十分
        p = p * 10 + (c - '0');
        c = mmuReadByteSignData (++a, 1);
      }
      e += t * p;
    }
    //符号と仮数部と指数部を合わせる
    //  x=s*x*10^e
    //  1<=u<10^18なのでeが範囲を大きく外れている場合を先に除外する
    if (e < -350) {
      XEiJ.regRn[2] = 65535;  //d2。-1ではない
      XEiJ.regRn[3] = 0;  //d3
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = 0;  //エラーなし。アンダーフローはエラーとみなされない
      return s < 0.0 ? -0.0 : 0.0;
    }
    if (350 < e) {
      XEiJ.regRn[2] = 0;  //d2
      XEiJ.regRn[3] = 0;  //d3
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_V | XEiJ.REG_CCR_C;  //オーバーフロー
      return s * Double.POSITIVE_INFINITY;
    }
    if (true) {
      QFP xx = new QFP (s < 0.0 ? -u : u);  //符号と仮数部
      if (0 < e) {
        xx.mul (QFP.QFP_TEN_P16QR[e & 15]);
        if (16 <= e) {
          xx.mul (QFP.QFP_TEN_P16QR[16 + (e >> 4 & 15)]);
          if (256 <= e) {
            xx.mul (QFP.QFP_TEN_P16QR[33]);
          }
        }
      } else if (e < 0) {
        xx.mul (QFP.QFP_TEN_M16QR[-e & 15]);
        if (e <= -16) {
          xx.mul (QFP.QFP_TEN_M16QR[16 + (-e >> 4 & 15)]);
          if (e <= -256) {
            xx.mul (QFP.QFP_TEN_M16QR[33]);
          }
        }
      }
      x = xx.getd ();
    } else {
      x = s * (double) u;  //符号と仮数部
      if (0 < e) {
        x *= FEFunction.FPK_TEN_P16QR[e & 15];
        if (16 <= e) {
          x *= FEFunction.FPK_TEN_P16QR[16 + (e >> 4 & 15)];
          if (256 <= e) {
            x *= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (e >> 8)]
          }
        }
      } else if (e < 0) {
        x /= FEFunction.FPK_TEN_P16QR[-e & 15];
        if (e <= -16) {
          x /= FEFunction.FPK_TEN_P16QR[16 + (-e >> 4 & 15)];
          if (e <= -256) {
            x /= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (-e >> 8)]
          }
        }
      }
    }
    if (Double.isInfinite (x)) {
      XEiJ.regRn[8] = a;  //a0
      XEiJ.regCCR = XEiJ.REG_CCR_V | XEiJ.REG_CCR_C;  //オーバーフロー
      return x;
    }
    //  アンダーフローで0になっている場合がある
    if (x == (double) ((int) x)) {  //intで表現できる。+0.0==-0.0==0なので±0.0を含む
      XEiJ.regRn[2] = 65535;  //d2。-1ではない
      XEiJ.regRn[3] = (int) x;  //d3
    } else {  //intで表現できない
      XEiJ.regRn[2] = 0;  //d2
      XEiJ.regRn[3] = 0;  //d3
    }
    XEiJ.regRn[8] = a;  //a0
    XEiJ.regCCR = 0;  //エラーなし
    return x;
  }  //fpkSTODSub()

  //fpkDTOS ()
  //  $FE23  __DTOS
  //  64bit浮動小数点数を文字列に変換する
  //  無限大は"#INF"、非数は"#NAN"になる
  //  指数形式の境目
  //    x<10^-4または10^14<=xのとき指数形式にする
  //    FLOAT2.X/FLOAT4.Xの場合
  //      3f2fffffffffff47  2.4414062499999E-004
  //      3f2fffffffffff48  0.000244140625
  //      42d6bcc41e8fffdf  99999999999999
  //      42d6bcc41e8fffe0  1E+014
  //  <d0d1.d:64bit浮動小数点数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:末尾の'\0'の位置
  public static void fpkDTOS () throws M68kException {
    fpkDTOSSub ((long) XEiJ.regRn[0] << 32 | 0xffffffffL & XEiJ.regRn[1]);  //64bit浮動小数点数
  }  //fpkDTOS()
  public static void fpkDTOSSub (long l) throws M68kException {
    final int len3 = 14;
    int a = XEiJ.regRn[8];  //文字列バッファの先頭
    //符号と指数部の処理
    //  ±0,±Inf,NaNはここで除外する
    if (l < 0L) {
      mmuWriteByteData (a++, '-', 1);  //負符号
      l &= 0x7fffffffffffffffL;  //符号bitを消しておく
    }
    double x = Double.longBitsToDouble (l);  //絶対値
    int e = (int) (l >>> 52) - 1023;  //指数部。ゲタ0。符号bitは消してあるのでマスクは不要
    l &= 0x000fffffffffffffL;  //仮数部の小数部。正規化数のとき整数部の1が付いていないことに注意
    if (e == -1023) {  //±0,非正規化数
      if (l == 0L) {  //±0
        mmuWriteByteData (a++, '0', 1);  //0
        mmuWriteByteData (a, '\0', 1);
        XEiJ.regRn[8] = a;  //末尾の'\0'の位置
        return;
      }
      e -= Long.numberOfLeadingZeros (l) - 12;  //非正規化数の指数部を補正する
    } else if (e == 1024) {  //±Inf,NaN
      mmuWriteByteData (a++, '#', 1);
      if (l == 0L) {  //±Inf
        mmuWriteByteData (a++, 'I', 1);
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'F', 1);
      } else {  //NaN
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'A', 1);
        mmuWriteByteData (a++, 'N', 1);
      }
      mmuWriteByteData (a, '\0', 1);
      XEiJ.regRn[8] = a;  //末尾の'\0'の位置
      return;
    }
    //10進数で表現したときの指数部を求める
    //  10^e<=x<10^(e+1)となるeを求める
    e = (int) Math.floor ((double) e * 0.30102999566398119521373889472);  //log10(2)
    //10^-eを掛けて1<=x<10にする
    //  非正規化数の最小値から正規化数の最大値まで処理できなければならない
    //  10^-eを計算してからまとめて掛ける方法はxが非正規化数のとき10^-eがオーバーフローしてしまうので不可
    //    doubleは非正規化数の逆数を表現できない
    if (0 < e) {  //10<=x
      x *= FEFunction.FPK_TEN_M16QR[e & 15];
      if (16 <= e) {
        x *= FEFunction.FPK_TEN_M16QR[16 + (e >> 4 & 15)];
        if (256 <= e) {
          x *= FEFunction.FPK_TEN_M16QR[33];  //FEFunction.FPK_TEN_M16QR[32 + (e >> 8)]
        }
      }
    } else if (e < 0) {  //x<1
      x *= FEFunction.FPK_TEN_P16QR[-e & 15];
      if (e <= -16) {
        x *= FEFunction.FPK_TEN_P16QR[16 + (-e >> 4 & 15)];
        if (e <= -256) {
          x *= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (-e >> 8)]
        }
      }
    }
    //整数部2桁、小数部16桁の10進数に変換する
    //  1<=x<10なのでw[1]が先頭になるはずだが誤差で前後にずれる可能性がある
    int[] w = new int[18];
    {
      int d = (int) x;
      int t = XEiJ.FMT_BCD4[d];
      w[0] = t >> 4;
      w[1] = t      & 15;
      for (int i = 2; i < 18; i += 4) {
        //xを10000倍して整数部dを引くことで小数部を残すが、このとき情報落ちが発生して誤差が蓄積する
        //Double-Doubleの乗算の要領で10000倍を正確に行い、誤差の蓄積を回避する
        //x = (x - (double) d) * 10000.0;
        double xh = x * 0x8000001p0;
        xh += x - xh;  //xの上半分
        x = (xh - (double) d) * 10000.0 + (x - xh) * 10000.0;
        d = (int) x;
        t = XEiJ.FMT_BCD4[d];
        w[i    ] = t >> 12;
        w[i + 1] = t >>  8 & 15;
        w[i + 2] = t >>  4 & 15;
        w[i + 3] = t       & 15;
      }
    }
    //先頭の位置を確認する
    //  w[h]が先頭(0でない最初の数字)の位置
    int h = w[0] != 0 ? 0 : w[1] != 0 ? 1 : 2;
    //14+1桁目を四捨五入する
    int o = h + 14;  //w[o]は四捨五入する桁の位置。w[]の範囲内
    if (5 <= w[o]) {
      int i = o;
      while (10 <= ++w[--i]) {
        w[i] = 0;
      }
      if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
        h--;  //先頭を左にずらす
        o--;  //末尾を左にずらす
      }
    }
    //先頭の位置に応じて指数部を更新する
    //  w[h]が整数部、w[h+1..o-1]が小数部。10^eの小数点はw[h]の右側。整数部の桁数はe+1桁
    e -= h - 1;
    //末尾の位置を確認する
    //  w[o-1]が末尾(0でない最後の数字)の位置
    while (w[o - 1] == 0) {  //全体は0ではないので必ず止まる。小数点よりも左側で止まる場合があることに注意
      o--;
    }
    //指数形式にするかどうか選択して文字列に変換する
    if (0 <= e && e < len3) {  //1<=x<10^len3。指数形式にしない
      do {
        mmuWriteByteData (a++, '0' + w[h++], 1);  //整数部。末尾の位置に関係なく1の位まで書く
      } while (0 <= --e);
      if (h < o) {  //小数部がある
        mmuWriteByteData (a++, '.', 1);  //小数部があるときだけ小数点を書く
        do {
          mmuWriteByteData (a++, '0' + w[h++], 1);  //小数部
        } while (h < o);
      }
    } else if (-4 <= e && e < 0) {  //10^-4<=x<1。指数形式にしない
      mmuWriteByteData (a++, '0', 1);  //整数部の0
      mmuWriteByteData (a++, '.', 1);  //小数点
      while (++e < 0) {
        mmuWriteByteData (a++, '0', 1);  //小数部の先頭の0の並び
      }
      do {
        mmuWriteByteData (a++, '0' + w[h++], 1);  //小数部
      } while (h < o);
    } else {  //x<10^-4または10^len3<=x。指数形式にする
      mmuWriteByteData (a++, '0' + w[h++], 1);  //整数部
      if (h < o) {  //小数部がある
        mmuWriteByteData (a++, '.', 1);  //小数部があるときだけ小数点を書く
        do {
          mmuWriteByteData (a++, '0' + w[h++], 1);  //小数部
        } while (h < o);
      }
      mmuWriteByteData (a++, 'E', 1);  //指数部の始まり
      if (0 <= e) {
        mmuWriteByteData (a++, '+', 1);  //指数部の正符号。省略しない
      } else {
        mmuWriteByteData (a++, '-', 1);  //指数部の負符号
        e = -e;
      }
      e = XEiJ.FMT_BCD4[e];
      mmuWriteByteData (a++, '0' + (e >> 8     ), 1);  //指数部の100の位。0でも省略しない
      mmuWriteByteData (a++, '0' + (e >> 4 & 15), 1);  //指数部の10の位
      mmuWriteByteData (a++, '0' + (e      & 15), 1);  //指数部の1の位
    }
    mmuWriteByteData (a, '\0', 1);
    XEiJ.regRn[8] = a;  //末尾の'\0'の位置
  }  //fpkDTOSSub6()

  //fpkECVT ()
  //  $FE24  __ECVT
  //  64bit浮動小数点数を全体の桁数を指定して文字列に変換する
  //  文字列に書くのは仮数部の数字のみ
  //  符号と小数点と指数部は文字列に書かず、小数点の位置と符号をレジスタに入れて返す
  //  桁数は255桁まで指定できるが、有効桁数は14桁まで
  //    有効桁数の次の桁で絶対値を四捨五入する
  //    15桁以上を指定しても14桁に丸められ、15桁目以降はすべて'0'になる
  //  無限大は"#INF"、非数は"#NAN"に変換する
  //    "#INF"と"#NAN"のとき小数点の位置は4になる
  //    "#INF"と"#NAN"で3桁以下のときは途中で打ち切る
  //    メモ
  //      FLOATn.Xは"#INF"と"#NAN"で1桁～3桁のとき文字列が"$","$0","$00"になってしまう
  //      文字数が少なすぎて"#INF"や"#NAN"が入り切らないのは仕方がないが、
  //      無意味な"$00"という文字列になるのは数字ではない文字列を四捨五入しようとするバグが原因
  //      例えば3桁のときは4桁目の'F'または'N'が'5'以上なので繰り上げて上の位をインクリメントする
  //      'N'+1='O'または'A'+1='B'が'9'よりも大きいので'0'を上書きして繰り上げて上の位をインクリメントする
  //      'I'+1='J'または'N'+1='O'も'9'よりも大きいので'0'を上書きして繰り上げて上の位をインクリメントする
  //      '#'+1='$'は'9'以下なので"$00"になる
  //      X-BASICでint i2,i3:print ecvt(val("#INF"),3,i2,i3)とすると再現できる
  //    "#INF"と"#NAN"で5桁以上のときは5桁目以降はすべて'\0'になる
  //    メモ
  //      FLOATn.Xは"#NAN"と"#INF"で15桁以上のとき5桁目から14桁目までは'\0'だが15桁目以降に'0'が書き込まれる
  //      通常は5桁目の'\0'で文字列は終了していると見なされるので実害はないが気持ち悪い
  //  メモ
  //    FLOAT2.X 2.02/2.03は0のとき小数点の位置が0になる
  //    FLOAT4.X 1.02は0のとき小数点の位置が1になる
  //    ここでは1にしている
  //  <d0d1.d:64bit浮動小数点数
  //  <d2.l:全体の桁数
  //  <a0.l:文字列バッファの先頭。末尾に'\0'を書き込むので桁数+1バイト必要
  //  >d0.l:先頭から小数点の位置までのオフセット
  //  >d1.l:符号(0=+,1=-)
  //  a0.lは変化しない
  public static void fpkECVT () throws M68kException {
    fpkECVTSub ((long) XEiJ.regRn[0] << 32 | 0xffffffffL & XEiJ.regRn[1]);  //64bit浮動小数点数
  }  //fpkECVT()
  public static void fpkECVTSub (long l) throws M68kException {
    int len3 = Math.max (0, XEiJ.regRn[2]);  //全体の桁数
    int a = XEiJ.regRn[8];  //文字列バッファの先頭
    int b = a + len3;  //文字列バッファの末尾+1。'\0'を書き込む位置
    //符号と指数部の処理
    //  ±0,±Inf,NaNはここで除外する
    if (0L <= l) {
      XEiJ.regRn[1] = 0;  //正符号
    } else {
      XEiJ.regRn[1] = 1;  //負符号
      l &= 0x7fffffffffffffffL;  //符号bitを消しておく
    }
    double x = Double.longBitsToDouble (l);  //絶対値
    int e = (int) (l >>> 52) - 1023;  //指数部。ゲタ0。符号bitは消してあるのでマスクは不要
    l &= 0x000fffffffffffffL;  //仮数部の小数部。正規化数のとき整数部の1が付いていないことに注意
    if (e == -1023) {  //±0,非正規化数
      if (l == 0L) {  //±0
        //指定された全体の桁数だけ'0'を並べる
        while (a < b) {
          mmuWriteByteData (a++, '0', 1);
        }
        mmuWriteByteData (a, '\0', 1);
        XEiJ.regRn[0] = 1;  //小数点の位置
        return;
      }
      e -= Long.numberOfLeadingZeros (l) - 12;  //非正規化数の指数部を補正する
    } else if (e == 1024) {  //±Inf,NaN
      for (int s = l != 0L ? '#' | 'N' << 8 | 'A' << 16 | 'N' << 24 : '#' | 'I' << 8 | 'N' << 16 | 'F' << 24; a < b && s != 0; s >>>= 8) {
        mmuWriteByteData (a++, s, 1);
      }
      while (a < b) {
        mmuWriteByteData (a++, '\0', 1);  //残りは'\0'
      }
      mmuWriteByteData (a, '\0', 1);
      XEiJ.regRn[0] = 4;  //小数点の位置
      return;
    }
    //10進数で表現したときの指数部を求める
    //  10^e<=x<10^(e+1)となるeを求める
    e = (int) Math.floor ((double) e * 0.30102999566398119521373889472);  //log10(2)
    //10^-eを掛けて1<=x<10にする
    //  非正規化数の最小値から正規化数の最大値まで処理できなければならない
    //  10^-eを計算してからまとめて掛ける方法はxが非正規化数のとき10^-eがオーバーフローしてしまうので不可
    //    doubleは非正規化数の逆数を表現できない
    if (0 < e) {  //10<=x
      x *= FEFunction.FPK_TEN_M16QR[e & 15];
      if (16 <= e) {
        x *= FEFunction.FPK_TEN_M16QR[16 + (e >> 4 & 15)];
        if (256 <= e) {
          x *= FEFunction.FPK_TEN_M16QR[33];  //FEFunction.FPK_TEN_M16QR[32 + (e >> 8)]
        }
      }
    } else if (e < 0) {  //x<1
      x *= FEFunction.FPK_TEN_P16QR[-e & 15];
      if (e <= -16) {
        x *= FEFunction.FPK_TEN_P16QR[16 + (-e >> 4 & 15)];
        if (e <= -256) {
          x *= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (-e >> 8)]
        }
      }
    }
    //整数部2桁、小数部16桁の10進数に変換する
    //  1<=x<10なのでw[1]が先頭になるはずだが誤差で前後にずれる可能性がある
    int[] w = new int[18];
    {
      int d = (int) x;
      int t = XEiJ.FMT_BCD4[d];
      w[0] = t >> 4;
      w[1] = t      & 15;
      for (int i = 2; i < 18; i += 4) {
        //xを10000倍して整数部dを引くことで小数部を残すが、このとき情報落ちが発生して誤差が蓄積する
        //Double-Doubleの乗算の要領で10000倍を正確に行い、誤差の蓄積を回避する
        //x = (x - (double) d) * 10000.0;
        double xh = x * 0x8000001p0;
        xh += x - xh;  //xの上半分
        x = (xh - (double) d) * 10000.0 + (x - xh) * 10000.0;
        d = (int) x;
        t = XEiJ.FMT_BCD4[d];
        w[i    ] = t >> 12;
        w[i + 1] = t >>  8 & 15;
        w[i + 2] = t >>  4 & 15;
        w[i + 3] = t       & 15;
      }
    }
    //先頭の位置を確認する
    //  w[h]が先頭(0でない最初の数字)の位置
    int h = w[0] != 0 ? 0 : w[1] != 0 ? 1 : 2;
    //14+1桁目を四捨五入する
    int o = h + 14;  //w[o]は四捨五入する桁の位置。w[]の範囲内
    if (5 <= w[o]) {
      int i = o;
      while (10 <= ++w[--i]) {
        w[i] = 0;
      }
      if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
        h--;  //先頭を左にずらす
        o--;  //末尾を左にずらす
      }
    }
    //先頭の位置に応じて指数部を更新する
    //  w[h]が整数部、w[h+1..o-1]が小数部。10^eの小数点はw[h]の右側。整数部の桁数はe+1桁
    e -= h - 1;
    //先頭からlen3+1桁目が先頭から14+1桁目よりも左側にあるときその桁で改めて四捨五入する
    //  あらかじめ14+1桁目で四捨五入しておかないと、
    //  1.5の5を四捨五入しなければならないときに誤差で1.499…になったまま4を四捨五入しようとして失敗することがある
    int s = h + len3;  //w[s]は先頭からlen3+1桁目の位置。w.length<=sの場合があることに注意
    if (s < o) {
      o = s;  //w[o]は四捨五入する桁の位置。o<0の場合があることに注意
      if (0 <= o && 5 <= w[o]) {
        int i = o;
        while (10 <= ++w[--i]) {
          w[i] = 0;
        }
        if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
          h--;  //先頭を左にずらす
          o--;  //末尾を左にずらす
          e++;  //指数部を1増やす
        }
      }
    }
    //文字列に変換する
    while (a < b && h < o) {
      mmuWriteByteData (a++, '0' + w[h++], 1);  //有効数字
    }
    while (a < b) {
      mmuWriteByteData (a++, '0', 1);  //残りは'0'
    }
    mmuWriteByteData (a, '\0', 1);
    XEiJ.regRn[0] = e + 1;  //小数点の位置
  }  //fpkECVTSub6()

  //fpkFCVT ()
  //  $FE25  __FCVT
  //  64bit浮動小数点数を小数点以下の桁数を指定して文字列に変換する
  //  メモ
  //    小数点の位置がpのとき[p]の左側に小数点がある
  //    全体の桁数が制限されないので指数部が大きいとき整数部が収まるサイズのバッファが必要
  //    0または1以上のとき
  //      整数部と小数点以下の指定された桁数までを小数部の0を省略せずに出力する
  //      整数部と小数点以下の指定された桁数が合わせて14桁を超えるときは15桁目が四捨五入されて15桁目以降は0になる
  //      小数点の位置は整数部の桁数に等しい
  //      print fcvt(0#,4,i2,i3),i2,i3
  //      0000     0       0
  //      print fcvt(2e+12/3#,4,i2,i3),i2,i3
  //      6666666666666700         12      0
  //                 ↑
  //    1未満のとき
  //      小数点以下の桁数の範囲内を先頭の0を省略して出力する
  //      小数点以下の桁数の範囲内がすべて0のときは""になる
  //      小数点の位置は指数部+1に等しい
  //      print fcvt(0.01,3,i2,i3),i2,i3                0.010
  //      10      -1       0                              <~~
  //      print fcvt(0.001,3,i2,i3),i2,i3               0.001
  //      1       -2       0                              <<~
  //      print fcvt(0.0001,3,i2,i3),i2,i3              0.0001
  //              -3       0                              <<<
  //      print fcvt(0.00001,3,i2,i3),i2,i3             0.00001
  //              -4       0                              <<<<
  //    #INFと#NAN
  //      小数点以下の桁数の指定に関係なく4文字出力して小数点の位置4を返す
  //      print fcvt(val("#INF"),2,i2,i3),i2,i3
  //      #INF     4       0
  //      print fcvt(val("#INF"),6,i2,i3),i2,i3
  //      #INF     4       0
  //  バグ
  //    FLOAT4.X 1.02は結果が整数部が大きいとき255文字で打ち切られる
  //    FLOAT4.X 1.02はFCVT(±0)の整数部が0桁ではなく1桁になる
  //  <d0d1.d:64bit浮動小数点数
  //  <d2.l:小数点以下の桁数
  //  <a0.l:文字列バッファの先頭
  //  >d0.l:先頭から小数点の位置までのオフセット
  //  >d1.l:符号(0=+,1=-)
  public static void fpkFCVT () throws M68kException {
    fpkFCVTSub ((long) XEiJ.regRn[0] << 32 | 0xffffffffL & XEiJ.regRn[1]);  //64bit浮動小数点数
  }  //fpkFCVT()
  public static void fpkFCVTSub (long l) throws M68kException {
    int len2 = Math.max (0, XEiJ.regRn[2]);  //小数部の桁数
    int a = XEiJ.regRn[8];  //文字列バッファの先頭
    //符号と指数部の処理
    //  ±0,±Inf,NaNはここで除外する
    if (0L <= l) {
      XEiJ.regRn[1] = 0;  //正符号
    } else {
      XEiJ.regRn[1] = 1;  //負符号
      l &= 0x7fffffffffffffffL;  //符号bitを消しておく
    }
    double x = Double.longBitsToDouble (l);  //絶対値
    int e = (int) (l >>> 52) - 1023;  //指数部。ゲタ0。符号bitは消してあるのでマスクは不要
    l &= 0x000fffffffffffffL;  //仮数部の小数部。正規化数のとき整数部の1が付いていないことに注意
    if (e == -1023) {  //±0,非正規化数
      if (l == 0L) {  //±0
        //指定された小数点以下の桁数だけ'0'を並べる
        while (len2-- > 0) {
          mmuWriteByteData (a++, '0', 1);
        }
        mmuWriteByteData (a, '\0', 1);
        XEiJ.regRn[0] = 0;  //小数点の位置
        return;
      }
      e -= Long.numberOfLeadingZeros (l) - 12;  //非正規化数の指数部を補正する
    } else if (e == 1024) {  //±Inf,NaN
      mmuWriteByteData (a++, '#', 1);
      if (l == 0L) {  //±Inf
        mmuWriteByteData (a++, 'I', 1);
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'F', 1);
      } else {  //NaN
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'A', 1);
        mmuWriteByteData (a++, 'N', 1);
      }
      mmuWriteByteData (a, '\0', 1);
      XEiJ.regRn[0] = 4;  //小数点の位置
      return;
    }
    //10進数で表現したときの指数部を求める
    //  10^e<=x<10^(e+1)となるeを求める
    e = (int) Math.floor ((double) e * 0.30102999566398119521373889472);  //log10(2)
    //10^-eを掛けて1<=x<10にする
    //  非正規化数の最小値から正規化数の最大値まで処理できなければならない
    //  10^-eを計算してからまとめて掛ける方法はxが非正規化数のとき10^-eがオーバーフローしてしまうので不可
    //    doubleは非正規化数の逆数を表現できない
    if (0 < e) {  //10<=x
      x *= FEFunction.FPK_TEN_M16QR[e & 15];
      if (16 <= e) {
        x *= FEFunction.FPK_TEN_M16QR[16 + (e >> 4 & 15)];
        if (256 <= e) {
          x *= FEFunction.FPK_TEN_M16QR[33];  //FEFunction.FPK_TEN_M16QR[32 + (e >> 8)]
        }
      }
    } else if (e < 0) {  //x<1
      x *= FEFunction.FPK_TEN_P16QR[-e & 15];
      if (e <= -16) {
        x *= FEFunction.FPK_TEN_P16QR[16 + (-e >> 4 & 15)];
        if (e <= -256) {
          x *= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (-e >> 8)]
        }
      }
    }
    //整数部2桁、小数部16桁の10進数に変換する
    //  1<=x<10なのでw[1]が先頭になるはずだが誤差で前後にずれる可能性がある
    int[] w = new int[18];
    {
      int d = (int) x;
      int t = XEiJ.FMT_BCD4[d];
      w[0] = t >> 4;
      w[1] = t      & 15;
      for (int i = 2; i < 18; i += 4) {
        //xを10000倍して整数部dを引くことで小数部を残すが、このとき情報落ちが発生して誤差が蓄積する
        //Double-Doubleの乗算の要領で10000倍を正確に行い、誤差の蓄積を回避する
        //x = (x - (double) d) * 10000.0;
        double xh = x * 0x8000001p0;
        xh += x - xh;  //xの上半分
        x = (xh - (double) d) * 10000.0 + (x - xh) * 10000.0;
        d = (int) x;
        t = XEiJ.FMT_BCD4[d];
        w[i    ] = t >> 12;
        w[i + 1] = t >>  8 & 15;
        w[i + 2] = t >>  4 & 15;
        w[i + 3] = t       & 15;
      }
    }
    //先頭の位置を確認する
    //  w[h]が先頭(0でない最初の数字)の位置
    int h = w[0] != 0 ? 0 : w[1] != 0 ? 1 : 2;
    //14+1桁目を四捨五入する
    int o = h + 14;  //w[o]は四捨五入する桁の位置。w[]の範囲内
    if (5 <= w[o]) {
      int i = o;
      while (10 <= ++w[--i]) {
        w[i] = 0;
      }
      if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
        h--;  //先頭を左にずらす
        o--;  //末尾を左にずらす
      }
    }
    //先頭の位置に応じて指数部を更新する
    //  w[h]が整数部、w[h+1..o-1]が小数部。10^eの小数点はw[h]の右側。整数部の桁数はe+1桁
    e -= h - 1;
    //小数点以下len2+1桁目が先頭から14+1桁目よりも左側にあるときその桁で改めて四捨五入する
    //  あらかじめ14+1桁目で四捨五入しておかないと、
    //  1.5の5を四捨五入しなければならないときに誤差で1.499…になったまま4を四捨五入しようとして失敗することがある
    int s = h + e + 1 + len2;  //w[s]は小数点以下len2+1桁目の位置。w.length<=sの場合があることに注意
    if (s < o) {
      o = s;  //w[o]は四捨五入する桁の位置。o<0の場合があることに注意
      if (0 <= o && 5 <= w[o]) {
        int i = o;
        while (10 <= ++w[--i]) {
          w[i] = 0;
        }
        if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
          h--;  //先頭を左にずらす
          o--;  //末尾を左にずらす
          e++;  //指数部を1増やす
        }
      }
    }
    //文字列に変換する
    while (h < o) {
      mmuWriteByteData (a++, '0' + w[h++], 1);  //有効数字
    }
    while (h++ < s) {
      mmuWriteByteData (a++, '0', 1);  //残りは'0'
    }
    mmuWriteByteData (a, '\0', 1);
    XEiJ.regRn[0] = e + 1;  //小数点の位置
  }  //fpkFCVTSub6()

  //fpkGCVT ()
  //  $FE26  __GCVT
  //  64bit浮動小数点数を全体の桁数を指定して文字列に変換する
  //  指定された桁数で表現できないときは指数表現になる
  //  メモ
  //    print gcvt(1e-1,10)
  //    0.1
  //    print gcvt(1e-8,10)
  //    0.00000001
  //    print gcvt(1.5e-8,10)
  //    1.5E-008
  //    print gcvt(1e-9,10)
  //    1.E-009                 小数点はあるが小数部がない
  //    print gcvt(2e-1/3#,10)
  //    6.666666667E-002
  //    print gcvt(2e+0/3#,10)
  //    0.6666666667
  //    print gcvt(2e+1/3#,10)
  //    6.666666667
  //    print gcvt(2e+9/3#,10)
  //    666666666.7
  //    print gcvt(2e+10/3#,10)
  //    6666666667
  //    print gcvt(2e+11/3#,10)
  //    6.666666667E+010
  //    print gcvt(0#,4)
  //    0.
  //    print gcvt(val("#INF"),4)
  //    #INF
  //    print gcvt(val("#INF"),3)
  //    $.E+003
  //    print gcvt(val("#INF"),2)
  //    $.E+003
  //    print gcvt(val("#INF"),1)
  //    $.E+003
  //    FLOAT2.XのGCVTは小数部がなくても桁数の範囲内であれば小数点を書く
  //    桁数ちょうどのときは小数点も指数部も付かないので、整数でないことを明確にするために小数点を書いているとも言い難い
  //    ここでは#NANと#INF以外は小数部がなくても小数点を書くことにする
  //  バグ
  //    FLOAT2.X 2.02/2.03は#NANと#INFにも小数点を付ける
  //    FLOAT2.X 2.02/2.03は#NANと#INFのとき桁数が足りないと指数形式にしようとして文字列が壊れる
  //    FLOAT4.X 1.02は#NANと#INFにも小数点を付ける
  //    FLOAT4.X 1.02は桁数の少ない整数には小数点を付けて桁数ちょうどの整数には小数点も指数部も付けない
  //  <d0d1.d:64bit浮動小数点数
  //  <d2.b:全体の桁数
  //  <a0.l:文字列バッファの先頭
  //  >a0.l:末尾の'\0'の位置
  public static void fpkGCVT () throws M68kException {
    fpkGCVTSub ((long) XEiJ.regRn[0] << 32 | 0xffffffffL & XEiJ.regRn[1]);  //64bit浮動小数点数
  }  //fpkGCVT()
  public static void fpkGCVTSub (long l) throws M68kException {
    int len3 = Math.max (0, XEiJ.regRn[2]);  //全体の桁数
    int a = XEiJ.regRn[8];  //文字列バッファの先頭
    //符号と指数部の処理
    //  ±0,±Inf,NaNはここで除外する
    if (l < 0L) {
      mmuWriteByteData (a++, '-', 1);  //負符号
      l &= 0x7fffffffffffffffL;  //符号bitを消しておく
    }
    double x = Double.longBitsToDouble (l);  //絶対値
    int e = (int) (l >>> 52) - 1023;  //指数部。ゲタ0。符号bitは消してあるのでマスクは不要
    l &= 0x000fffffffffffffL;  //仮数部の小数部。正規化数のとき整数部の1が付いていないことに注意
    if (e == -1023) {  //±0,非正規化数
      if (l == 0L) {  //±0
        mmuWriteByteData (a++, '0', 1);  //0
        mmuWriteByteData (a++, '.', 1);  //小数点
        mmuWriteByteData (a, '\0', 1);
        XEiJ.regRn[8] = a;  //末尾の'\0'の位置
        return;
      }
      e -= Long.numberOfLeadingZeros (l) - 12;  //非正規化数の指数部を補正する
    } else if (e == 1024) {  //±Inf,NaN
      mmuWriteByteData (a++, '#', 1);
      if (l == 0L) {  //±Inf
        mmuWriteByteData (a++, 'I', 1);
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'F', 1);
      } else {  //NaN
        mmuWriteByteData (a++, 'N', 1);
        mmuWriteByteData (a++, 'A', 1);
        mmuWriteByteData (a++, 'N', 1);
      }
      mmuWriteByteData (a, '\0', 1);
      XEiJ.regRn[8] = a;  //末尾の'\0'の位置
      return;
    }
    //10進数で表現したときの指数部を求める
    //  10^e<=x<10^(e+1)となるeを求める
    e = (int) Math.floor ((double) e * 0.30102999566398119521373889472);  //log10(2)
    //10^-eを掛けて1<=x<10にする
    //  非正規化数の最小値から正規化数の最大値まで処理できなければならない
    //  10^-eを計算してからまとめて掛ける方法はxが非正規化数のとき10^-eがオーバーフローしてしまうので不可
    //    doubleは非正規化数の逆数を表現できない
    if (0 < e) {  //10<=x
      x *= FEFunction.FPK_TEN_M16QR[e & 15];
      if (16 <= e) {
        x *= FEFunction.FPK_TEN_M16QR[16 + (e >> 4 & 15)];
        if (256 <= e) {
          x *= FEFunction.FPK_TEN_M16QR[33];  //FEFunction.FPK_TEN_M16QR[32 + (e >> 8)]
        }
      }
    } else if (e < 0) {  //x<1
      x *= FEFunction.FPK_TEN_P16QR[-e & 15];
      if (e <= -16) {
        x *= FEFunction.FPK_TEN_P16QR[16 + (-e >> 4 & 15)];
        if (e <= -256) {
          x *= FEFunction.FPK_TEN_P16QR[33];  //FEFunction.FPK_TEN_P16QR[32 + (-e >> 8)]
        }
      }
    }
    //整数部2桁、小数部16桁の10進数に変換する
    //  1<=x<10なのでw[1]が先頭になるはずだが誤差で前後にずれる可能性がある
    int[] w = new int[18];
    {
      int d = (int) x;
      int t = XEiJ.FMT_BCD4[d];
      w[0] = t >> 4;
      w[1] = t      & 15;
      for (int i = 2; i < 18; i += 4) {
        //xを10000倍して整数部dを引くことで小数部を残すが、このとき情報落ちが発生して誤差が蓄積する
        //Double-Doubleの乗算の要領で10000倍を正確に行い、誤差の蓄積を回避する
        //x = (x - (double) d) * 10000.0;
        double xh = x * 0x8000001p0;
        xh += x - xh;  //xの上半分
        x = (xh - (double) d) * 10000.0 + (x - xh) * 10000.0;
        d = (int) x;
        t = XEiJ.FMT_BCD4[d];
        w[i    ] = t >> 12;
        w[i + 1] = t >>  8 & 15;
        w[i + 2] = t >>  4 & 15;
        w[i + 3] = t       & 15;
      }
    }
    //先頭の位置を確認する
    //  w[h]が先頭(0でない最初の数字)の位置
    int h = w[0] != 0 ? 0 : w[1] != 0 ? 1 : 2;
    //14+1桁目を四捨五入する
    int o = h + 14;  //w[o]は四捨五入する桁の位置。w[]の範囲内
    if (5 <= w[o]) {
      int i = o;
      while (10 <= ++w[--i]) {
        w[i] = 0;
      }
      if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
        h--;  //先頭を左にずらす
        o--;  //末尾を左にずらす
      }
    }
    //先頭の位置に応じて指数部を更新する
    //  w[h]が整数部、w[h+1..o-1]が小数部。10^eの小数点はw[h]の右側。整数部の桁数はe+1桁
    e -= h - 1;
    //先頭からlen3+1桁目が先頭から14+1桁目よりも左側にあるときその桁で改めて四捨五入する
    //  あらかじめ14+1桁目で四捨五入しておかないと、
    //  1.5の5を四捨五入しなければならないときに誤差で1.499…になったまま4を四捨五入しようとして失敗することがある
    int s = h + len3;  //w[s]は先頭からlen3+1桁目の位置。w.length<=sの場合があることに注意
    if (s < o) {
      o = s;  //w[o]は四捨五入する桁の位置。o<0の場合があることに注意
      if (0 <= o && 5 <= w[o]) {
        int i = o;
        while (10 <= ++w[--i]) {
          w[i] = 0;
        }
        if (i < h) {  //先頭から繰り上がった。このとき新しい先頭は1でそれ以外はすべて0
          h--;  //先頭を左にずらす
          o--;  //末尾を左にずらす
          e++;  //指数部を1増やす
        }
      }
    }
    //末尾の位置を確認する
    //  w[o-1]が末尾(0でない最後の数字)の位置
    while (w[o - 1] == 0) {  //全体は0ではないので必ず止まる。小数点よりも左側で止まる場合があることに注意
      o--;
    }
    //指数形式にするかどうか選択して文字列に変換する
    if (0 <= e && e < len3) {  //1<=x<10^len3。指数形式にしない
      do {
        mmuWriteByteData (a++, '0' + w[h++], 1);  //整数部。末尾の位置に関係なく1の位まで書く
      } while (0 <= --e);
      mmuWriteByteData (a++, '.', 1);  //小数部がなくても小数点を書く
      while (h < o) {
        mmuWriteByteData (a++, '0' + w[h++], 1);  //小数部
      }
    } else if (-4 <= e && e < 0) {  //10^-4<=x<1。指数形式にしない
      mmuWriteByteData (a++, '0', 1);  //整数部の0
      mmuWriteByteData (a++, '.', 1);  //小数点
      while (++e < 0) {
        mmuWriteByteData (a++, '0', 1);  //小数部の先頭の0の並び
      }
      while (h < o) {
        mmuWriteByteData (a++, '0' + w[h++], 1);  //小数部
      }
    } else {  //x<10^-4または10^len3<=x。指数形式にする
      mmuWriteByteData (a++, '0' + w[h++], 1);  //整数部
      mmuWriteByteData (a++, '.', 1);  //小数部がなくても小数点を書く
      while (h < o) {
        mmuWriteByteData (a++, '0' + w[h++], 1);  //小数部
      }
      mmuWriteByteData (a++, 'E', 1);  //指数部の始まり
      if (0 <= e) {
        mmuWriteByteData (a++, '+', 1);  //指数部の正符号。省略しない
      } else {
        mmuWriteByteData (a++, '-', 1);  //指数部の負符号
        e = -e;
      }
      e = XEiJ.FMT_BCD4[e];
      mmuWriteByteData (a++, '0' + (e >> 8     ), 1);  //指数部の100の位。0でも省略しない
      mmuWriteByteData (a++, '0' + (e >> 4 & 15), 1);  //指数部の10の位
      mmuWriteByteData (a++, '0' + (e      & 15), 1);  //指数部の1の位
    }
    mmuWriteByteData (a, '\0', 1);
    XEiJ.regRn[8] = a;  //末尾の'\0'の位置
  }  //fpkGCVTSub6()

  //fpkFVAL ()
  //  $FE50  __FVAL
  //  文字列を32bit浮動小数点数に変換する
  //  __VALとほぼ同じ
  //  <a0.l:文字列の先頭
  //  >d0.s:32bit浮動小数点数
  //  >d2.l:(先頭が'&'でないとき)65535=32bit浮動小数点数をオーバーフローなしでintに変換できる,0=それ以外
  //  >d3.l:(先頭が'&'でないとき)d2.l==65535のとき32bit浮動小数点数をintに変換した値
  //  >a0.l:変換された文字列の直後('\0'とは限らない)
  //  >ccr:0=エラーなし,CCR_N|CCR_C=文法エラー,CCR_V|CCR_C=オーバーフロー
  public static void fpkFVAL () throws M68kException {
    int a = XEiJ.regRn[8];  //a0
    //先頭の空白を読み飛ばす
    int c = mmuReadByteSignData (a++, 1);
    while (c == ' ' || c == '\t') {
      c = mmuReadByteSignData (a++, 1);
    }
    if (c == '&') {  //&B,&O,&H
      c = mmuReadByteSignData (a++, 1) & 0xdf;
      XEiJ.regRn[8] = a;  //&?の直後
      if (c == 'B') {
        fpkSTOB ();
        FEFunction.fpkLTOF ();
      } else if (c == 'O') {
        fpkSTOO ();
        FEFunction.fpkLTOF ();
      } else if (c == 'H') {
        fpkSTOH ();
        FEFunction.fpkLTOF ();
      } else {
        XEiJ.regCCR = XEiJ.REG_CCR_N | XEiJ.REG_CCR_C;  //文法エラー
      }
    } else {  //&B,&O,&H以外
      FEFunction.fpkSTOF ();
    }
  }  //fpkFVAL()

  //fpkCLMUL ()
  //  $FEE0  __CLMUL
  //  32bit符号あり整数乗算
  //  <(a7).l:32bit符号あり整数。被乗数x
  //  <4(a7).l:32bit符号あり整数。乗数y
  //  >(a7).l:32bit符号あり整数。積x*y。オーバーフローのときは不定
  //  >ccr:cs=オーバーフロー。C以外は不定
  public static void fpkCLMUL () throws M68kException {
    int a7 = XEiJ.regRn[15];
    long l = (long) mmuReadLongData (a7, 1) * (long) mmuReadLongData (a7 + 4, 1);
    int h = (int) l;
    mmuWriteLongData (a7, h, 1);  //オーバーフローのときは積の下位32bit
    XEiJ.regCCR = (long) h == l ? 0 : XEiJ.REG_CCR_C;
  }  //fpkCLMUL()

  //fpkCLDIV ()
  //  $FEE1  __CLDIV
  //  32bit符号あり整数除算
  //  <(a7).l:32bit符号あり整数。被除数x
  //  <4(a7).l:32bit符号あり整数。除数y
  //  >(a7).l:32bit符号あり整数。商x/y。ゼロ除算のときは不定
  //  >ccr:cs=ゼロ除算。C以外は不定
  public static void fpkCLDIV () throws M68kException {
    int a7 = XEiJ.regRn[15];
    int h = mmuReadLongData (a7 + 4, 1);
    if (h == 0) {
      //(a7).lは変化しない
      XEiJ.regCCR = XEiJ.REG_CCR_C;
    } else {
      mmuWriteLongData (a7, mmuReadLongData (a7, 1) / h, 1);
      XEiJ.regCCR = 0;
    }
  }  //fpkCLDIV()

  //fpkCLMOD ()
  //  $FEE2  __CLMOD
  //  32bit符号あり整数剰余算
  //  <(a7).l:32bit符号あり整数。被除数x
  //  <4(a7).l:32bit符号あり整数。除数y
  //  >(a7).l:32bit符号あり整数。余りx%y。ゼロ除算のときは不定
  //  >ccr:cs=ゼロ除算。C以外は不定
  public static void fpkCLMOD () throws M68kException {
    int a7 = XEiJ.regRn[15];
    int h = mmuReadLongData (a7 + 4, 1);
    if (h == 0) {
      //(a7).lは変化しない
      XEiJ.regCCR = XEiJ.REG_CCR_C;
    } else {
      mmuWriteLongData (a7, mmuReadLongData (a7, 1) % h, 1);
      XEiJ.regCCR = 0;
    }
  }  //fpkCLMOD()

  //fpkCUMUL ()
  //  $FEE3  __CUMUL
  //  32bit符号なし整数乗算
  //  <(a7).l:32bit符号なし整数。被乗数x
  //  <4(a7).l:32bit符号なし整数。乗数y
  //  >(a7).l:32bit符号なし整数。積x*y。オーバーフローのときは不定
  //  >ccr:cs=オーバーフロー。C以外は不定
  public static void fpkCUMUL () throws M68kException {
    int a7 = XEiJ.regRn[15];
    long l = (0xffffffffL & mmuReadLongData (a7, 1)) * (0xffffffffL & mmuReadLongData (a7 + 4, 1));
    int h = (int) l;
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (0xffffffffL & h) == l ? 0 : XEiJ.REG_CCR_C;
  }  //fpkCUMUL()

  //fpkCUDIV ()
  //  $FEE4  __CUDIV
  //  32bit符号なし整数除算
  //  <(a7).l:32bit符号なし整数。被除数x
  //  <4(a7).l:32bit符号なし整数。除数y
  //  >(a7).l:32bit符号なし整数。商x/y。ゼロ除算のときは不定
  //  >ccr:cs=ゼロ除算。C以外は不定
  public static void fpkCUDIV () throws M68kException {
    int a7 = XEiJ.regRn[15];
    int h = mmuReadLongData (a7 + 4, 1);
    if (h == 0) {
      //(a7).lは変化しない
      XEiJ.regCCR = XEiJ.REG_CCR_C;
    } else {
      mmuWriteLongData (a7, (int) ((0xffffffffL & mmuReadLongData (a7, 1)) / (0xffffffffL & h)), 1);
      XEiJ.regCCR = 0;
    }
  }  //fpkCUDIV()

  //fpkCUMOD ()
  //  $FEE5  __CUMOD
  //  32bit符号なし整数剰余算
  //  <(a7).l:32bit符号なし整数。被除数x
  //  <4(a7).l:32bit符号なし整数。除数y
  //  >(a7).l:32bit符号なし整数。余りx%y。ゼロ除算のときは不定
  //  >ccr:cs=ゼロ除算。C以外は不定
  public static void fpkCUMOD () throws M68kException {
    int a7 = XEiJ.regRn[15];
    int h = mmuReadLongData (a7 + 4, 1);
    if (h == 0) {
      //(a7).lは変化しない
      XEiJ.regCCR = XEiJ.REG_CCR_C;
    } else {
      mmuWriteLongData (a7, (int) ((0xffffffffL & mmuReadLongData (a7, 1)) % (0xffffffffL & h)), 1);
      XEiJ.regCCR = 0;
    }
  }  //fpkCUMOD()

  //fpkCLTOD ()
  //  $FEE6  __CLTOD
  //  32bit符号あり整数を64bit浮動小数点数に変換する
  //  <(a7).l:32bit符号あり整数。x
  //  >(a7).d:64bit浮動小数点数。(double)x
  public static void fpkCLTOD () throws M68kException {
    //int→double→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    long l = Double.doubleToLongBits ((double) mmuReadLongData (a7, 1));
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
  }  //fpkCLTOD()

  //fpkCDTOL ()
  //  $FEE7  __CDTOL
  //  64bit浮動小数点数を32bit符号あり整数に変換する
  //  <(a7).d:64bit浮動小数点数。x
  //  >(a7).l:32bit符号あり整数。(int)x
  //  >ccr:cs=オーバーフロー。C以外は不定
  public static void fpkCDTOL () throws M68kException {
    //[int,int]→[long]→double→int
    int a7 = XEiJ.regRn[15];
    double d = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    mmuWriteLongData (a7, (int) d, 1);  //オーバーフローのときは最小値または最大値
    XEiJ.regCCR = (double) Integer.MIN_VALUE - 1.0 < d && d < (double) Integer.MAX_VALUE + 1.0 ? 0 : XEiJ.REG_CCR_C;  //NaN,±Infはエラー
  }  //fpkCDTOL()

  //fpkCLTOF ()
  //  $FEE8  __CLTOF
  //  32bit符号あり整数を32bit浮動小数点数に変換する
  //  <(a7).l:32bit符号あり整数。x
  //  >(a7).s:32bit浮動小数点数。(float)x
  public static void fpkCLTOF () throws M68kException {
    //int→float→[int]
    int a7 = XEiJ.regRn[15];
    mmuWriteLongData (a7, Float.floatToIntBits ((float) mmuReadLongData (a7, 1)), 1);
  }  //fpkCLTOF()

  //fpkCFTOL ()
  //  $FEE9  __CFTOL
  //  32bit浮動小数点数を32bit符号あり整数に変換する
  //  <(a7).s:32bit浮動小数点数。x
  //  >(a7).l:32bit符号あり整数。(int)x
  //  >ccr:cs=オーバーフロー。C以外は不定
  public static void fpkCFTOL () throws M68kException {
    //[int]→float→int
    int a7 = XEiJ.regRn[15];
    float f = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    mmuWriteLongData (a7, (int) f, 1);
    XEiJ.regCCR = (float) Integer.MIN_VALUE - 1.0F < f && f < (float) Integer.MAX_VALUE + 1.0F ? 0 : XEiJ.REG_CCR_C;  //NaN,±Infはエラー
  }  //fpkCFTOL()

  //fpkCFTOD ()
  //  $FEEA  __CFTOD
  //  32bit浮動小数点数を64bit浮動小数点数に変換する
  //  <(a7).s:32bit浮動小数点数。x
  //  >(a7).d:64bit浮動小数点数。(double)x
  public static void fpkCFTOD () throws M68kException {
    //[int]→float→double→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    long l = Double.doubleToLongBits ((double) Float.intBitsToFloat (mmuReadLongData (a7, 1)));
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
  }  //fpkCFTOD()

  //fpkCDTOF ()
  //  $FEEB  __CDTOF
  //  64bit浮動小数点数を32bit浮動小数点数に変換する
  //  <(a7).d:64bit浮動小数点数。x
  //  >(a7).s:32bit浮動小数点数。(float)x
  //  >ccr:cs=オーバーフロー。C以外は不定
  public static void fpkCDTOF () throws M68kException {
    //[int,int]→[long]→double→float→[int]
    int a7 = XEiJ.regRn[15];
    double d = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    int h = Float.floatToIntBits ((float) d);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (Double.isNaN (d) || Double.isInfinite (d) ||
           Math.abs (d) < (double) Float.MAX_VALUE + 0.5 * (double) Math.ulp (Float.MAX_VALUE) ? 0 : XEiJ.REG_CCR_C);  //アンダーフローはエラーなし
  }  //fpkCDTOF()

  //fpkCDCMP ()
  //  $FEEC  __CDCMP
  //  64bit浮動小数点数の比較
  //  x<=>y
  //  <(a7).d:64bit浮動小数点数。x
  //  <8(a7).d:64bit浮動小数点数。y
  //  >ccr:lt=x<y,eq=x==y,gt=x>y
  public static void fpkCDCMP () throws M68kException {
    //([int,int]→[long]→double)<=>([int,int]→[long]→double)
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double yd = Double.longBitsToDouble ((long) mmuReadLongData (a7 + 8, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 12, 1));
    XEiJ.regCCR = xd < yd ? XEiJ.REG_CCR_N | XEiJ.REG_CCR_C : xd == yd ? XEiJ.REG_CCR_Z : 0;  //どちらかがNaNのときは0
  }  //fpkCDCMP()

  //fpkCDADD ()
  //  $FEED  __CDADD
  //  64bit浮動小数点数の加算
  //  <(a7).d:64bit浮動小数点数。被加算数x
  //  <8(a7).d:64bit浮動小数点数。加算数y
  //  >(a7).d:64bit浮動小数点数。和x+y
  //  >ccr:0=エラーなし,CCR_C=アンダーフロー,CCR_V|CCR_C=オーバーフロー
  public static void fpkCDADD () throws M68kException {
    //([int,int]→[long]→double)+([int,int]→[long]→double)→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double yd = Double.longBitsToDouble ((long) mmuReadLongData (a7 + 8, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 12, 1));
    double zd = xd + yd;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = (Double.isNaN (xd) || Double.isNaN (yd) ? 0 :  //引数がNaN
           Double.isNaN (zd) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(+Inf)+(-Inf)=NaN
           Double.isInfinite (xd) || Double.isInfinite (yd) ? 0 :  //引数が±Inf
           Double.isInfinite (zd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCDADD()

  //fpkCDSUB ()
  //  $FEEE  __CDSUB
  //  64bit浮動小数点数の減算
  //  <(a7).d:64bit浮動小数点数。被減算数x
  //  <8(a7).d:64bit浮動小数点数。減算数y
  //  >(a7).d:64bit浮動小数点数。差x-y
  //  >ccr:cs=エラー,vs=オーバーフロー
  public static void fpkCDSUB () throws M68kException {
    //([int,int]→[long]→double)-([int,int]→[long]→double)→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double yd = Double.longBitsToDouble ((long) mmuReadLongData (a7 + 8, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 12, 1));
    double zd = xd - yd;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = (Double.isNaN (xd) || Double.isNaN (yd) ? 0 :  //引数がNaN
           Double.isNaN (zd) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(+Inf)-(+Inf)=NaN
           Double.isInfinite (xd) || Double.isInfinite (yd) ? 0 :  //引数が±Inf
           Double.isInfinite (zd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCDSUB()

  //fpkCDMUL ()
  //  $FEEF  __CDMUL
  //  64bit浮動小数点数の乗算
  //  <(a7).d:64bit浮動小数点数。被乗数x
  //  <8(a7).d:64bit浮動小数点数。乗数y
  //  >(a7).d:64bit浮動小数点数。積x*y
  //  >ccr:cs=エラー,vs=オーバーフロー
  public static void fpkCDMUL () throws M68kException {
    //([int,int]→[long]→double)*([int,int]→[long]→double)→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double yd = Double.longBitsToDouble ((long) mmuReadLongData (a7 + 8, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 12, 1));
    double zd = xd * yd;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = (Double.isNaN (xd) || Double.isNaN (yd) ? 0 :  //引数がNaN
           Double.isNaN (zd) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(±0)*(±Inf)=NaN
           Double.isInfinite (xd) || Double.isInfinite (yd) ? 0 :  //引数が±Inf
           Double.isInfinite (zd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCDMUL()

  //fpkCDDIV ()
  //  $FEF0  __CDDIV
  //  64bit浮動小数点数の除算
  //  <(a7).d:64bit浮動小数点数。被除数x
  //  <8(a7).d:64bit浮動小数点数。除数y
  //  >(a7).d:64bit浮動小数点数。商x/y。ゼロ除算のときは不定
  //  >ccr:cs=エラー,eq=ゼロ除算,vs=オーバーフロー
  public static void fpkCDDIV () throws M68kException {
    //([int,int]→[long]→double)/([int,int]→[long]→double)→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double yd = Double.longBitsToDouble ((long) mmuReadLongData (a7 + 8, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 12, 1));
    double zd = xd / yd;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = (Double.isNaN (xd) || Double.isNaN (yd) ? 0 :  //引数がNaN
           Double.isNaN (zd) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(±0)/(±0)=NaN
           Double.isInfinite (xd) || Double.isInfinite (yd) ? 0 :  //引数が±Inf。(±Inf)/(±0)=(±Inf)
           yd == 0.0 ? XEiJ.REG_CCR_Z | XEiJ.REG_CCR_C :  //除数が±0のときはゼロ除算
           Double.isInfinite (zd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCDDIV()

  //fpkCDMOD ()
  //  $FEF1  __CDMOD
  //  64bit浮動小数点数の剰余算
  //  <(a7).d:64bit浮動小数点数。被除数x
  //  <8(a7).d:64bit浮動小数点数。除数y
  //  >(a7).d:64bit浮動小数点数。余りx%y。ゼロ除算のときは不定
  //  >ccr:cs=エラー,eq=ゼロ除算
  public static void fpkCDMOD () throws M68kException {
    //([int,int]→[long]→double)%([int,int]→[long]→double)→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double yd = Double.longBitsToDouble ((long) mmuReadLongData (a7 + 8, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 12, 1));
    double zd = xd % yd;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = (Double.isNaN (xd) || Double.isNaN (yd) ? 0 :  //引数がNaN
           yd == 0.0 ? XEiJ.REG_CCR_Z | XEiJ.REG_CCR_C :  //除数が0のときはゼロ除算。(±Inf)%(±0)=NaN, x%(±0)=(±Inf)
           Double.isNaN (zd) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(±Inf)%y=NaN
           Double.isInfinite (xd) || Double.isInfinite (yd) ? 0 :  //引数が±Inf
           Double.isInfinite (zd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCDMOD()

  //fpkCFCMP ()
  //  $FEF2  __CFCMP
  //  32bit浮動小数点数の比較
  //  x<=>y
  //  <(a7).s:32bit浮動小数点数。x
  //  <(a7).s:32bit浮動小数点数。y
  //  >ccr:lt=x<y,eq=x==y,gt=x>y
  public static void fpkCFCMP () throws M68kException {
    //([int]→float)<=>([int]→float)
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float yf = Float.intBitsToFloat (mmuReadLongData (a7 + 4, 1));
    XEiJ.regCCR = xf < yf ? XEiJ.REG_CCR_N | XEiJ.REG_CCR_C : xf == yf ? XEiJ.REG_CCR_Z : 0;  //どちらかがNaNのときは0
  }  //fpkCFCMP()

  //fpkCFADD ()
  //  $FEF3  __CFADD
  //  32bit浮動小数点数の加算
  //  <(a7).s:32bit浮動小数点数。被加算数x
  //  <4(a7).s:32bit浮動小数点数。加算数y
  //  >(a7).s:32bit浮動小数点数。和x+y
  //  >ccr:cs=エラー,vs=オーバーフロー
  public static void fpkCFADD () throws M68kException {
    //([int]→float)+([int]→float)→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float yf = Float.intBitsToFloat (mmuReadLongData (a7 + 4, 1));
    float zf = xf + yf;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (Float.isNaN (xf) || Float.isNaN (yf) ? 0 :  //引数がNaN
           Float.isNaN (zf) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(+Inf)+(-Inf)=NaN
           Float.isInfinite (xf) || Float.isInfinite (yf) ? 0 :  //引数が±Inf
           Float.isInfinite (zf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCFADD()

  //fpkCFSUB ()
  //  $FEF4  __CFSUB
  //  32bit浮動小数点数の減算
  //  <(a7).s:32bit浮動小数点数。被減算数x
  //  <4(a7).s:32bit浮動小数点数。減算数y
  //  >(a7).s:32bit浮動小数点数。差x-y
  //  >ccr:cs=エラー,vs=オーバーフロー
  public static void fpkCFSUB () throws M68kException {
    //([int]→float)-([int]→float)→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float yf = Float.intBitsToFloat (mmuReadLongData (a7 + 4, 1));
    float zf = xf - yf;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (Float.isNaN (xf) || Float.isNaN (yf) ? 0 :  //引数がNaN
           Float.isNaN (zf) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(+Inf)-(+Inf)=NaN
           Float.isInfinite (xf) || Float.isInfinite (yf) ? 0 :  //引数が±Inf
           Float.isInfinite (zf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCFSUB()

  //fpkCFMUL ()
  //  $FEF5  __CFMUL
  //  32bit浮動小数点数の乗算
  //  <(a7).s:32bit浮動小数点数。被乗数x
  //  <4(a7).s:32bit浮動小数点数。乗数y
  //  >(a7).s:32bit浮動小数点数。積x*y
  //  >ccr:0=エラーなし,CCR_C=アンダーフロー,CCR_V|CCR_C=オーバーフロー
  public static void fpkCFMUL () throws M68kException {
    //([int]→float)*([int]→float)→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float yf = Float.intBitsToFloat (mmuReadLongData (a7 + 4, 1));
    float zf = xf * yf;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (Float.isNaN (xf) || Float.isNaN (yf) ? 0 :  //引数がNaN
           Float.isNaN (zf) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(±0)*(±Inf)=NaN
           Float.isInfinite (xf) || Float.isInfinite (yf) ? 0 :  //引数が±Inf
           Float.isInfinite (zf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCFMUL()

  //fpkCFDIV ()
  //  $FEF6  __CFDIV
  //  32bit浮動小数点数の除算
  //  <(a7).s:32bit浮動小数点数。被除数x
  //  <4(a7).s:32bit浮動小数点数。除数y
  //  >(a7).s:32bit浮動小数点数。商x/y。ゼロ除算のときは不定
  //  >ccr:cs=エラー,eq=ゼロ除算,vs=オーバーフロー
  public static void fpkCFDIV () throws M68kException {
    //([int]→float)/([int]→float)→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float yf = Float.intBitsToFloat (mmuReadLongData (a7 + 4, 1));
    float zf = xf / yf;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (Float.isNaN (xf) || Float.isNaN (yf) ? 0 :  //引数がNaN
           Float.isNaN (zf) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(±0)/(±0)=NaN
           Float.isInfinite (xf) || Float.isInfinite (yf) ? 0 :  //引数が±Inf。(±Inf)/(±0)=(±Inf)
           yf == 0.0F ? XEiJ.REG_CCR_Z | XEiJ.REG_CCR_C :  //除数が±0のときはゼロ除算
           Float.isInfinite (zf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCFDIV()

  //fpkCFMOD ()
  //  $FEF7  __CFMOD
  //  32bit浮動小数点数の剰余算
  //  <(a7).s:32bit浮動小数点数。被除数x
  //  <4(a7).s:32bit浮動小数点数。除数y
  //  >(a7).s:32bit浮動小数点数。余りx%y。ゼロ除算のときは不定
  //  >ccr:cs=エラー,eq=ゼロ除算
  public static void fpkCFMOD () throws M68kException {
    //([int]→float)%([int]→float)→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float yf = Float.intBitsToFloat (mmuReadLongData (a7 + 4, 1));
    float zf = xf % yf;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = (Float.isNaN (xf) || Float.isNaN (yf) ? 0 :  //引数がNaN
           yf == 0.0F ? XEiJ.REG_CCR_Z | XEiJ.REG_CCR_C :  //除数が0のときはゼロ除算。(±Inf)%(±0)=NaN, x%(±0)=(±Inf)
           Float.isNaN (zf) ? XEiJ.REG_CCR_C :  //引数がNaNでないのに結果がNaNのときはエラー。(±Inf)%y=NaN
           Float.isInfinite (xf) || Float.isInfinite (yf) ? 0 :  //引数が±Inf
           Float.isInfinite (zf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C :  //引数が±Infでないのに結果が±Infのときはオーバーフロー
           0);
  }  //fpkCFMOD()

  //fpkCDTST ()
  //  $FEF8  __CDTST
  //  64bit浮動小数点数と0の比較
  //  x<=>0
  //  <(a7).d:64bit浮動小数点数。x
  //  >ccr:lt=x<0,eq=x==0,gt=x>0
  public static void fpkCDTST () throws M68kException {
    if (true) {
      int a7 = XEiJ.regRn[15];
      long l = (long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1);
      XEiJ.regCCR = l << 1 == 0L ? XEiJ.REG_CCR_Z : 0L <= l ? 0 : XEiJ.REG_CCR_N;  //NaNのときは0
    } else {
      //[int,int]→[long]→double
      int a7 = XEiJ.regRn[15];
      double d = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
      XEiJ.regCCR = d < 0.0 ? XEiJ.REG_CCR_N : d == 0.0 ? XEiJ.REG_CCR_Z : 0;  //NaNのときは0
    }
  }  //fpkCDTST()

  //fpkCFTST ()
  //  $FEF9  __CFTST
  //  32bit浮動小数点数と0の比較
  //  x<=>0
  //  <(a7).s:32bit浮動小数点数。x
  //  >ccr:lt=x<0,eq=x==0,gt=x>0
  public static void fpkCFTST () throws M68kException {
    //[int]→float
    if (true) {
      int h = mmuReadLongData (XEiJ.regRn[15], 1);
      XEiJ.regCCR = h << 1 == 0 ? XEiJ.REG_CCR_Z : 0 <= h ? 0 : XEiJ.REG_CCR_N;  //NaNのときは0
    } else {
      //([int]→float)<=>0
      float f = Float.intBitsToFloat (mmuReadLongData (XEiJ.regRn[15], 1));
      XEiJ.regCCR = f < 0.0F ? XEiJ.REG_CCR_N : f == 0.0F ? XEiJ.REG_CCR_Z : 0;  //NaNのときは0
    }
  }  //fpkCFTST()

  //fpkCDINC ()
  //  $FEFA  __CDINC
  //  64bit浮動小数点数に1を加える
  //  <(a7).d:64bit浮動小数点数。x
  //  >(a7).d:64bit浮動小数点数。x+1
  public static void fpkCDINC () throws M68kException {
    //([int,int]→[long]→double)+1→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double zd = xd + 1.0;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = Double.isInfinite (zd) && !Double.isInfinite (xd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C : 0;  //結果が±Infだが引数が±Infでないときはオーバーフロー
  }  //fpkCDINC()

  //fpkCFINC ()
  //  $FEFB  __CFINC
  //  32bit浮動小数点数に1を加える
  //  <(a7).s:32bit浮動小数点数。x
  //  >(a7).s:32bit浮動小数点数。x+1
  public static void fpkCFINC () throws M68kException {
    //([int]→float)+1→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float zf = xf + 1.0F;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = Double.isInfinite (zf) && !Float.isInfinite (xf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C : 0;  //結果が±Infだが引数が±Infでないときはオーバーフロー
  }  //fpkCFINC()

  //fpkCDDEC ()
  //  $FEFC  __CDDEC
  //  64bit浮動小数点数から1を引く
  //  <(a7).d:64bit浮動小数点数。x
  //  >(a7).d:64bit浮動小数点数。x-1
  public static void fpkCDDEC () throws M68kException {
    //([int,int]→[long]→double)-1→[long]→[int,int]
    int a7 = XEiJ.regRn[15];
    double xd = Double.longBitsToDouble ((long) mmuReadLongData (a7, 1) << 32 | 0xffffffffL & mmuReadLongData (a7 + 4, 1));
    double zd = xd - 1.0;
    long l = Double.doubleToLongBits (zd);
    if (FEFunction.FPK_FPCP_NAN && l == 0x7ff8000000000000L) {
      l = 0x7fffffffffffffffL;
    }
    mmuWriteLongData (a7, (int) (l >>> 32), 1);
    mmuWriteLongData (a7 + 4, (int) l, 1);
    XEiJ.regCCR = Double.isInfinite (zd) && !Double.isInfinite (xd) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C : 0;  //結果が±Infだが引数が±Infでないときはオーバーフロー
  }  //fpkCDDEC()

  //fpkCFDEC ()
  //  $FEFD  __CFDEC
  //  32bit浮動小数点数から1を引く
  //  <(a7).s:32bit浮動小数点数。x
  //  >(a7).s:32bit浮動小数点数。x-1
  public static void fpkCFDEC () throws M68kException {
    //([int]→float)-1→[int]
    int a7 = XEiJ.regRn[15];
    float xf = Float.intBitsToFloat (mmuReadLongData (a7, 1));
    float zf = xf - 1.0F;
    int h = Float.floatToIntBits (zf);
    if (FEFunction.FPK_FPCP_NAN && h == 0x7fc00000) {
      h = 0x7fffffff;
    }
    mmuWriteLongData (a7, h, 1);
    XEiJ.regCCR = Double.isInfinite (zf) && !Float.isInfinite (xf) ? XEiJ.REG_CCR_V | XEiJ.REG_CCR_C : 0;  //結果が±Infだが引数が±Infでないときはオーバーフロー
  }  //fpkCFDEC()



  //========================================================================================
  //$$MMU メモリ管理ユニット

  public static final boolean MMU_DEBUG_COMMAND = false;
  public static final boolean MMU_DEBUG_TRANSLATION = false;
  public static final boolean MMU_NOT_ALLOCATE_CACHE = false;  //true=アドレス変換キャッシュをアロケートしない

  //--------------------------------------------------------------------------------
  //論理アドレスと物理アドレス
  //
  //  ページサイズが4KBの場合
  //              ┌──  7 ──┬──  7 ──┬── 6──┬─────12─────┐
  //               31          2524          1817        1211                     0
  //              ┏━━━━━━┯━━━━━━┯━━━━━┯━━━━━━━━━━━┓
  //        論理  ┃   ルート   │  ポインタ  │  ページ  │        ページ        ┃
  //      アドレス┃インデックス│インデックス インデックス       オフセット      ┃
  //              ┗━━↓━━━┷━━↓━━━┷━━↓━━┷━━━━━↓━━━━━┛
  //          ┌────┘            │            └────┐      └──────┐
  //          │    ルートテーブル    │   ポインタテーブル   │    ページテーブル  │
  //        ┌┼→┏━━━━━━━┓┌┼→┏━━━━━━━┓┌┼→┏━━━━━━━┓│
  //        ││ 0┃              ┃││ 0┃              ┃││ 0┃              ┃│
  //        ││  ┃              ┃││  ┃              ┃│└→┠───────┨│
  //        │└→┠───────┨││  ┃              ┃│    ┃    ページ    ┃│
  //      ルート  ┃    ルート    ┃│└→┠───────┨│┌─←ディスクリプタ┃│
  //     ポインタ ┃ディスクリプタ→┘    ┃   ポインタ   ┃││  ┠───────┨│
  //              ┠───────┨      ┃ディスクリプタ→┘│63┃              ┃│
  //              ┃              ┃      ┠───────┨  │  ┗━━━━━━━┛│
  //           127┃              ┃   127┃              ┃  │                    │
  //              ┗━━━━━━━┛      ┗━━━━━━━┛  │                    │
  //                                  ┌───────────┘      ┌──────┘
  //              ┏━━━━━━━━━↓━━━━━━━━━┯━━━━━↓━━━━━┓
  //        物理  ┃              物理ページ              │        ページ        ┃
  //      アドレス┃               アドレス               │      オフセット      ┃
  //              ┗━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━┛
  //               31                                    1211                     0
  //              └─────────20─────────┴─────12─────┘
  //
  //  ページサイズが8KBの場合
  //              ┌──  7 ──┬──  7 ──┬─  5 ─┬───── 13 ─────┐
  //               31          2524          1817      1312                       0
  //              ┏━━━━━━┯━━━━━━┯━━━━┯━━━━━━━━━━━━┓
  //        論理  ┃   ルート   │  ポインタ  │ ページ │         ページ         ┃
  //      アドレス┃インデックス│インデックスインデックス       オフセット       ┃
  //              ┗━━↓━━━┷━━↓━━━┷━━↓━┷━━━━━━↓━━━━━┛
  //          ┌────┘            │            └────┐      └──────┐
  //          │    ルートテーブル    │   ポインタテーブル   │    ページテーブル  │
  //        ┌┼→┏━━━━━━━┓┌┼→┏━━━━━━━┓┌┼→┏━━━━━━━┓│
  //        ││ 0┃              ┃││ 0┃              ┃││ 0┃              ┃│
  //        ││  ┃              ┃││  ┃              ┃│└→┠───────┨│
  //        │└→┠───────┨││  ┃              ┃│    ┃    ページ    ┃│
  //      ルート  ┃    ルート    ┃│└→┠───────┨│┌─←ディスクリプタ┃│
  //     ポインタ ┃ディスクリプタ→┘    ┃   ポインタ   ┃││  ┠───────┨│
  //              ┠───────┨      ┃ディスクリプタ→┘│31┃              ┃│
  //              ┃              ┃      ┠───────┨  │  ┗━━━━━━━┛│
  //           127┃              ┃   127┃              ┃  │                    │
  //              ┗━━━━━━━┛      ┗━━━━━━━┛  │                    │
  //                                  ┌───────────┘      ┌──────┘
  //              ┏━━━━━━━━━↓━━━━━━━━┯━━━━━━↓━━━━━┓
  //        物理  ┃             物理ページ             │         ページ         ┃
  //      アドレス┃              アドレス              │       オフセット       ┃
  //              ┗━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━┛
  //               31                                  1312                       0
  //              └──────── 19 ────────┴───── 13 ─────┘
  //
  public static final int MMU_ROOT_INDEX_BIT0       = 25;
  public static final int MMU_POINTER_INDEX_BIT0    = 18;
  public static final int MMU_PAGE_INDEX_BIT0_4KB   = 12;
  public static final int MMU_PAGE_INDEX_BIT0_8KB   = 13;
  public static final int MMU_PAGE_SIZE_4KB         = 1 << MMU_PAGE_INDEX_BIT0_4KB;
  public static final int MMU_PAGE_SIZE_8KB         = 1 << MMU_PAGE_INDEX_BIT0_8KB;
  //                                                    33222222_22221111_111111
  //                                                    10987654_32109876_54321098_76543210
  public static final int MMU_ROOT_INDEX_MASK       = 0b11111110_00000000_00000000_00000000;
  public static final int MMU_POINTER_INDEX_MASK    = 0b00000001_11111100_00000000_00000000;
  public static final int MMU_PAGE_INDEX_MASK_4KB   = 0b00000000_00000011_11110000_00000000;
  public static final int MMU_PAGE_INDEX_MASK_8KB   = 0b00000000_00000011_11100000_00000000;
  public static final int MMU_PAGE_OFFSET_MASK_4KB  = 0b00000000_00000000_00001111_11111111;
  public static final int MMU_PAGE_OFFSET_MASK_8KB  = 0b00000000_00000000_00011111_11111111;
  public static final int MMU_PAGE_ADDRESS_MASK_4KB = 0b11111111_11111111_11110000_00000000;
  public static final int MMU_PAGE_ADDRESS_MASK_8KB = 0b11111111_11111111_11100000_00000000;

  //--------------------------------------------------------------------------------
  //透過変換レジスタ
  //
  //  DTT0  データ透過変換レジスタ0
  //  DTT1  データ透過変換レジスタ1
  //  ITT0  命令透過変換レジスタ0
  //  ITT1  命令透過変換レジスタ1
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┯━┯━┯━┯━━━━━┯━┯━┯━┯━━━┯━━━┯━┯━━━┓
  //    ┃      論理アドレスベース      │      論理アドレスマスク      │ E│IS│US│     0    │U1│U0│ 0│  CM  │   0  │ W│   0  ┃
  //    ┗━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┷━┷━┷━┷━━━━━┷━┷━┷━┷━━━┷━━━┷━┷━━━┛
  public static final int MMU_TTR_BASE            = 255 << 24;  //x  Logical Address Base
  public static final int MMU_TTR_MASK            = 255 << 16;  //x  Logical Address Mask
  public static final int MMU_TTR_ENABLE          =   1 << 15;  //x  E   Enable
  public static final int MMU_TTR_IGNORE_FC2      =   1 << 14;  //x  IS  Ignore FC2 when matching
  public static final int MMU_TTR_USER_SUPERVISOR =   1 << 13;  //x  US  User or Supervisor when IS=0
  public static final int MMU_TTR_US_USER         =   0 << 13;  //         Match only if FC2=0 (user mode access)
  public static final int MMU_TTR_US_SUPERVISOR   =   1 << 13;  //         Match only if FC2=1 (supervisor mode access)
  public static final int MMU_TTR_WRITE_PROTECT   =   1 <<  2;  //x  W   Write Protect
  public static int mmuDTT0;  //DTT0
  public static int mmuDTT1;  //DTT1
  public static int mmuITT0;  //ITT0
  public static int mmuITT1;  //ITT1
  //  透過変換マップ
  //    インデックス
  //      a >>> 24
  //    値
  //      -1  透過変換あり,ライトプロテクトあり → リードのときアドレス変換なし、ライトのときアクセスフォルト
  //       0  透過変換なし                      → アドレス変換あり
  //       1  透過変換あり,ライトプロテクトなし → アドレス変換なし
  public static int[] mmuUserDataTransparent;  //ユーザデータ透過変換マップ
  public static int[] mmuUserCodeTransparent;  //ユーザ命令透過変換マップ
  public static int[] mmuSuperDataTransparent;  //スーパーバイザデータ透過変換マップ
  public static int[] mmuSuperCodeTransparent;  //スーパーバイザ命令透過変換マップ
  public static int[] mmuUserDataDifference;  //ユーザデータ透過変換差分マップ
  public static int[] mmuUserCodeDifference;  //ユーザ命令透過変換差分マップ
  public static int[] mmuSuperDataDifference;  //スーパーバイザデータ透過変換差分マップ
  public static int[] mmuSuperCodeDifference;  //スーパーバイザ命令透過変換差分マップ

  //d = mmuGetDTT0 ()
  //  DTT0を読む
  public static int mmuGetDTT0 () {
    return mmuDTT0;
  }  //mmuGetDTT0()

  //d = mmuGetDTT1 ()
  //  DTT1を読む
  public static int mmuGetDTT1 () {
    return mmuDTT1;
  }  //mmuGetDTT1()

  //d = mmuGetITT0 ()
  //  ITT0を読む
  public static int mmuGetITT0 () {
    return mmuITT0;
  }  //mmuGetITT0()

  //d = mmuGetITT1 ()
  //  ITT1を読む
  public static int mmuGetITT1 () {
    return mmuITT1;
  }  //mmuGetITT1()

  //mmuSetDTT0 (d)
  //  DTT0に書く
  public static void mmuSetDTT0 (int d) {
    mmuSetDataTransparent (d, mmuDTT1);
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetDTT0(0x%08x)\n", XEiJ.regPC0, mmuDTT0);
    }
  }  //mmuSetDTT0(int)

  //mmuSetDTT1 (d)
  //  DTT1に書く
  public static void mmuSetDTT1 (int d) {
    mmuSetDataTransparent (mmuDTT0, d);
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetDTT1(0x%08x)\n", XEiJ.regPC0, mmuDTT1);
    }
  }  //mmuSetDTT1(int)

  //mmuSetDataTransparent (d0, d1)
  //  DTT0,DTT1に書く
  //  データ透過変換マップを更新する
  //  DTT0とDTT1の両方がヒットするときDTT0を用いるため、DTT1の変換を展開してからDTT0の変換を上書きする
  //  DTT1でライトプロテクトされていてもDTT0でライトプロテクトされていなければ書き込める
  public static void mmuSetDataTransparent (int d0, int d1) {
    mmuDTT0 = d0 & 0xffffe364;
    mmuDTT1 = d1 & 0xffffe364;
    //透過変換マップと透過変換差分マップを入れ換える
    {
      int[] t = mmuUserDataDifference;
      mmuUserDataDifference = mmuUserDataTransparent;
      mmuUserDataTransparent = t;
      t = mmuSuperDataDifference;
      mmuSuperDataDifference = mmuSuperDataTransparent;
      mmuSuperDataTransparent = t;
    }
    //透過変換マップを構築する
    Arrays.fill (mmuUserDataTransparent, 0);  //透過変換なし
    Arrays.fill (mmuSuperDataTransparent, 0);  //透過変換なし
    if ((short) mmuDTT1 < 0) {  //(mmuDTT1 & MMU_TTR_ENABLE) != 0。有効
      int mask = ~mmuDTT1 >>> 16 & 255;
      int base = mmuDTT1 >>> 24 & mask;
      int writeProtect = (mmuDTT1 & MMU_TTR_WRITE_PROTECT) != 0 ? -1 : 1;  //-1=ライトプロテクトあり,1=ライトプロテクトなし
      if ((mmuDTT1 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuDTT1 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_USER) {  //ユーザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuDTT1) & ~mmuDTT1 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuUserDataTransparent[block] = writeProtect;
          }
        }
      }
      if ((mmuDTT1 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuDTT1 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_SUPERVISOR) {  //スーパーバイザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuDTT1) & ~mmuDTT1 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuSuperDataTransparent[block] = writeProtect;
          }
        }
      }
    }
    if ((short) mmuDTT0 < 0) {  //(mmuDTT0 & MMU_TTR_ENABLE) != 0。有効
      int mask = ~mmuDTT0 >>> 16 & 255;
      int base = mmuDTT0 >>> 24 & mask;
      int writeProtect = (mmuDTT0 & MMU_TTR_WRITE_PROTECT) != 0 ? -1 : 1;  //-1=ライトプロテクトあり,1=ライトプロテクトなし
      if ((mmuDTT0 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuDTT0 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_USER) {  //ユーザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuDTT0) & ~mmuDTT0 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuUserDataTransparent[block] = writeProtect;
          }
        }
      }
      if ((mmuDTT0 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuDTT0 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_SUPERVISOR) {  //スーパーバイザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuDTT0) & ~mmuDTT0 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuSuperDataTransparent[block] = writeProtect;
          }
        }
      }
    }
    //透過変換差分マップを作る
    int difference = 0;
    for (int block = 0; block < 256; block++) {
      difference |= mmuUserDataDifference[block] -= mmuUserDataTransparent[block];
      difference |= mmuSuperDataDifference[block] -= mmuSuperDataTransparent[block];
    }
    //透過変換の状態が変化したブロックのエントリを無効化する
    if (difference != 0) {
      for (int i = 0; i < 4 * MMU_CACHE_WAYS * MMU_HASH_SIZE; i += 4) {
        int logicalPage = mmuUserDataCache[i];
        if (logicalPage != 1 &&  //有効なエントリで
            mmuUserDataDifference[logicalPage >>> 24] != 0) {  //透過変換の状態が変化した
          mmuUserDataCache[i] = mmuUserDataCache[i + 1] = mmuUserDataCache[i + 2] = mmuUserDataCache[i + 3] = 1;  //無効化する
        }
        logicalPage = mmuSuperDataCache[i];
        if (logicalPage != 1 &&  //有効なエントリで
            mmuSuperDataDifference[logicalPage >>> 24] != 0) {  //透過変換の状態が変化した
          mmuSuperDataCache[i] = mmuSuperDataCache[i + 1] = mmuSuperDataCache[i + 2] = mmuSuperDataCache[i + 3] = 1;  //無効化する
        }
      }
    }
  }  //mmuSetDataTransparent(int,int)

  //mmuSetITT0 (d)
  //  ITT0に書く
  public static void mmuSetITT0 (int d) {
    mmuSetCodeTransparent (d, mmuITT1);
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetITT0(0x%08x)\n", XEiJ.regPC0, mmuITT0);
    }
  }  //mmuSetITT0(int)

  //mmuSetITT1 (d)
  //  ITT1に書く
  public static void mmuSetITT1 (int d) {
    mmuSetCodeTransparent (mmuITT0, d);
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetITT1(0x%08x)\n", XEiJ.regPC0, mmuITT1);
    }
  }  //mmuSetITT1(int)

  //mmuSetCodeTransparent (d0, d1)
  //  ITT0,ITT1に書く
  //  命令透過変換マップを更新する
  //  ITT0とITT1の両方がヒットするときITT0を用いるため、ITT1の変換を展開してからITT0の変換を上書きする
  public static void mmuSetCodeTransparent (int d0, int d1) {
    mmuITT0 = d0 & 0xffffe364;
    mmuITT1 = d1 & 0xffffe364;
    //透過変換マップと透過変換差分マップを入れ換える
    {
      int[] t = mmuUserCodeDifference;
      mmuUserCodeDifference = mmuUserCodeTransparent;
      mmuUserCodeTransparent = t;
      t = mmuSuperCodeDifference;
      mmuSuperCodeDifference = mmuSuperCodeTransparent;
      mmuSuperCodeTransparent = t;
    }
    //透過変換マップを構築する
    Arrays.fill (mmuUserCodeTransparent, 0);  //透過変換なし
    Arrays.fill (mmuSuperCodeTransparent, 0);  //透過変換なし
    if ((short) mmuITT1 < 0) {  //(mmuITT1 & MMU_TTR_ENABLE) != 0。有効
      int mask = ~mmuITT1 >>> 16 & 255;
      int base = mmuITT1 >>> 24 & mask;
      int writeProtect = (mmuITT1 & MMU_TTR_WRITE_PROTECT) != 0 ? -1 : 1;  //-1=ライトプロテクトあり,1=ライトプロテクトなし
      if ((mmuITT1 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuITT1 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_USER) {  //ユーザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuITT1) & ~mmuITT1 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuUserCodeTransparent[block] = writeProtect;
          }
        }
      }
      if ((mmuITT1 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuITT1 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_SUPERVISOR) {  //スーパーバイザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuITT1) & ~mmuITT1 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuSuperCodeTransparent[block] = writeProtect;
          }
        }
      }
    }
    if ((short) mmuITT0 < 0) {  //(mmuITT0 & MMU_TTR_ENABLE) != 0。有効
      int mask = ~mmuITT0 >>> 16 & 255;
      int base = mmuITT0 >>> 24 & mask;
      int writeProtect = (mmuITT0 & MMU_TTR_WRITE_PROTECT) != 0 ? -1 : 1;  //-1=ライトプロテクトあり,1=ライトプロテクトなし
      if ((mmuITT0 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuITT0 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_USER) {  //ユーザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuITT0) & ~mmuITT0 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuUserCodeTransparent[block] = writeProtect;
          }
        }
      }
      if ((mmuITT0 & MMU_TTR_IGNORE_FC2) != 0 ||
          (mmuITT0 & MMU_TTR_USER_SUPERVISOR) == MMU_TTR_US_SUPERVISOR) {  //スーパーバイザモードで有効
        for (int block = 0; block < 256; block++) {
          //if (((block << 24 ^ mmuITT0) & ~mmuITT0 << 8) >>> 24 == 0) {
          if ((block & mask) == base) {
            mmuSuperCodeTransparent[block] = writeProtect;
          }
        }
      }
    }
    //透過変換差分マップを作る
    int difference = 0;
    for (int block = 0; block < 256; block++) {
      difference |= mmuUserCodeDifference[block] -= mmuUserCodeTransparent[block];
      difference |= mmuSuperCodeDifference[block] -= mmuSuperCodeTransparent[block];
    }
    //透過変換の状態が変化したブロックのエントリを無効化する
    if (difference != 0) {
      for (int i = 0; i < 4 * MMU_CACHE_WAYS * MMU_HASH_SIZE; i += 4) {
        int logicalPage = mmuUserCodeCache[i];
        if (logicalPage != 1 &&  //有効なエントリで
            mmuUserCodeDifference[logicalPage >>> 24] != 0) {  //透過変換の状態が変化した
          mmuUserCodeCache[i] = mmuUserCodeCache[i + 1] = mmuUserCodeCache[i + 2] = mmuUserCodeCache[i + 3] = 1;  //無効化する
        }
        logicalPage = mmuSuperCodeCache[i];
        if (logicalPage != 1 &&  //有効なエントリで
            mmuSuperCodeDifference[logicalPage >>> 24] != 0) {  //透過変換の状態が変化した
          mmuSuperCodeCache[i] = mmuSuperCodeCache[i + 1] = mmuSuperCodeCache[i + 2] = mmuSuperCodeCache[i + 3] = 1;  //無効化する
        }
      }
    }
  }  //mmuSetCodeTransparent(int,int)

  //--------------------------------------------------------------------------------
  //変換制御レジスタ
  //
  //  TCR  変換制御レジスタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━┯━┯━┯━┯━┯━┯━━━┯━━━┯━┯━━━┯━━━┯━┓
  //    ┃                               0                              │ E│ P NAD NAI FOTC FITC  DCO │  DUO │DWO   DCI │  DUI │ 0┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━┷━┷━┷━┷━┷━┷━━━┷━━━┷━┷━━━┷━━━┷━┛
  public static final int MMU_TCR_ENABLE    = 1 << 15;  //x  E     Enable
  public static final int MMU_TCR_PAGE_SIZE = 1 << 14;  //x  P     Page Size
  public static final int MMU_TCR_P_4KB     = 0 << 14;  //           4KB
  public static final int MMU_TCR_P_8KB     = 1 << 14;  //           8KB
  public static final int MMU_TCR_NAD       = 1 << 13;  //x  NAD   No Allocate Mode (Data ATC)。データATCはヒットするが更新されない
  public static final int MMU_TCR_NAI       = 1 << 12;  //x  NAI   No Allocate Mode (Instruction ATC)。命令ATCはヒットするが更新されない
  public static final int MMU_TCR_FOTC      = 1 << 11;  //   FOTC  1/2-Cache Mode (Data ATC)。データATCは0=64エントリ,1=32エントリ
  public static final int MMU_TCR_FITC      = 1 << 10;  //   FITC  1/2-Cache Mode (Instruction ATC)。命令ATCは0=64エントリ,1=32エントリ
  public static final int MMU_TCR_DCO       = 3 <<  8;  //   DCO   Default Cache Mode (Data Cache)。デフォルトデータキャッシュモード
  public static final int MMU_TCR_DUO       = 3 <<  6;  //   DUO   Default UPA bits (Data Cache)。デフォルトデータUPA
  public static final int MMU_TCR_DWO       = 1 <<  5;  //   DWO   Default Write Protect (Data Cache)。デフォルトライトプロテクト
  public static final int MMU_TCR_DCI       = 3 <<  3;  //   DCI   Default Cache Mode (Instruction Cache)。デフォルト命令キャッシュモード
  public static final int MMU_TCR_DUI       = 3 <<  1;  //   DUI   Default UPA bits (Instruction Cache)。デフォルト命令UPA
  public static int mmuTCR;  //TCR
  public static boolean mmuEnabled;  //true=アドレス変換有効
  public static boolean mmu4KB;  //false=8KB,true=4KB
  public static boolean mmuNotAllocateData;  //true=データアドレス変換キャッシュをアロケートしない
  public static boolean mmuNotAllocateCode;  //true=命令アドレス変換キャッシュをアロケートしない
  public static int mmuPageSize;  //ページサイズ
  public static int mmuPageAddressMask;  //ページアドレスのマスク
  public static int mmuPageOffsetMask;  //ページオフセットのマスク
  public static int mmuPageIndexMask;  //ページインデックスのマスク
  public static int mmuPageIndexBit2;  //ページインデックスのbit番号-2
  public static int mmuPageTableMask;  //ページテーブルの先頭アドレスのマスク

  //d = mmuGetTCR ()
  //  TCRを読む
  public static int mmuGetTCR () {
    return mmuTCR;
  }  //mmuGetTCR()

  //mmuSetTCR (d)
  //  TCRに書く
  public static void mmuSetTCR (int d) {
    mmuInvalidateAllCache ();  //高速化のためアドレス変換していないときもキャッシュに乗せているので、アドレス変換を有効にしたときキャッシュを初期化する必要がある
    mmuTCR = d & 0x0000fffe;
    mmuEnabled = (short) d < 0;  //(d & MMU_TCR_ENABLE) != 0
    mmu4KB = (d & MMU_TCR_PAGE_SIZE) == MMU_TCR_P_4KB;
    mmuNotAllocateData = (d & MMU_TCR_NAD) != 0;
    mmuNotAllocateCode = (d & MMU_TCR_NAI) != 0;
    if (mmu4KB) {  //4KB
      mmuPageSize = MMU_PAGE_SIZE_4KB;
      mmuPageAddressMask = MMU_PAGE_ADDRESS_MASK_4KB;
      mmuPageOffsetMask = MMU_PAGE_OFFSET_MASK_4KB;
      mmuPageIndexMask = MMU_PAGE_INDEX_MASK_4KB;
      mmuPageIndexBit2 = MMU_PAGE_INDEX_BIT0_4KB - 2;
      mmuPageTableMask = MMU_DESCRIPTOR_PAGE_TABLE_ADDRESS_4KB;
    } else {  //8KB
      mmuPageSize = MMU_PAGE_SIZE_8KB;
      mmuPageAddressMask = MMU_PAGE_ADDRESS_MASK_8KB;
      mmuPageOffsetMask = MMU_PAGE_OFFSET_MASK_8KB;
      mmuPageIndexMask = MMU_PAGE_INDEX_MASK_8KB;
      mmuPageIndexBit2 = MMU_PAGE_INDEX_BIT0_8KB - 2;
      mmuPageTableMask = MMU_DESCRIPTOR_PAGE_TABLE_ADDRESS_8KB;
    }
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetTCR(0x%08x)\n", XEiJ.regPC0, mmuTCR);
      System.out.printf ("  mmuEnabled=%b\n", mmuEnabled);
      System.out.printf ("  mmu4KB=%b\n", mmu4KB);
      System.out.printf ("  mmuPageSize=0x%08x\n", mmuPageSize);
      System.out.printf ("  mmuPageAddressMask=0x%08x\n", mmuPageAddressMask);
      System.out.printf ("  mmuPageOffsetMask=0x%08x\n", mmuPageOffsetMask);
      System.out.printf ("  mmuPageIndexMask=0x%08x\n", mmuPageIndexMask);
      System.out.printf ("  mmuPageIndexBit2=%d\n", mmuPageIndexBit2);
      System.out.printf ("  mmuPageTableMask=%d\n", mmuPageTableMask);
    }
  }  //mmuSetTCR(int)

  //--------------------------------------------------------------------------------
  //アドレス変換テーブル

  //  URP  ユーザルートポインタ
  //  SRP  スーパーバイザルートポインタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┓
  //    ┃                                  ルートテーブルアドレス                                  │                 0                ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┛
  public static int mmuURP;  //URP
  public static int mmuSRP;  //SRP

  //d = mmuGetURP ()
  //  URPを読む
  public static int mmuGetURP () {
    return mmuURP;
  }  //mmuGetURP()

  //d = mmuGetSRP ()
  //  SRPを読む
  public static int mmuGetSRP () {
    return mmuSRP;
  }  //mmuGetSRP()

  //mmuSetURP (d)
  //  URPに書く
  public static void mmuSetURP (int d) throws M68kException {
    mmuURP = d &= 0xfffffe00;
    Arrays.fill (mmuUserDataCache, 1);
    Arrays.fill (mmuUserCodeCache, 1);
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetURP(0x%08x)\n", XEiJ.regPC0, mmuURP);
    }
    if (RootPointerList.RTL_ON) {
      RootPointerList.rtlSetRootPointer (d, false);
    }
  }  //mmuSetURP(int)

  //mmuSetSRP (d)
  //  SRPに書く
  public static void mmuSetSRP (int d) {
    mmuSRP = d &= 0xfffffe00;
    Arrays.fill (mmuSuperDataCache, 1);
    Arrays.fill (mmuSuperCodeCache, 1);
    if (MMU_DEBUG_COMMAND) {
      System.out.printf ("%08x mmuSetSRP(0x%08x)\n", XEiJ.regPC0, mmuSRP);
    }
    if (RootPointerList.RTL_ON) {
      RootPointerList.rtlSetRootPointer (d, true);
    }
  }  //mmuSetSRP(int)

  //  ディスクリプタ
  //
  //    ルートテーブルディスクリプタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━┯━┯━┯━━━┓
  //    ┃                                 ポインタテーブルアドレス                                 │         X        │ U│ W│  UDT ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━┷━┷━┷━━━┛
  //
  //    4KBポインタテーブルディスクリプタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━┯━┯━┯━━━┓
  //    ┃                                        ページテーブルアドレス                                        │   X  │ U│ W│  UDT ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━┷━┷━┷━━━┛
  //
  //    8KBポインタテーブルディスクリプタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━┯━┯━┯━━━┓
  //    ┃                                          ページテーブルアドレス                                          │ X│ U│ W│  UDT ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━┷━┷━┷━━━┛
  //
  //    4KBページテーブルディスクリプタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━┯━┯━┯━┯━┯━━━┯━┯━┯━┯━━━┓
  //    ┃                              物理ページアドレス                              │UR│ G│U1│U0│ S│  CM  │ M│ U│ W│  PDT ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━┷━┷━┷━┷━┷━━━┷━┷━┷━┷━━━┛
  //
  //    8KBページテーブルディスクリプタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━┯━┯━┯━┯━┯━┯━━━┯━┯━┯━┯━━━┓
  //    ┃                            物理ページアドレス                            │UR│UR│ G│U1│U0│ S│  CM  │ M│ U│ W│  PDT ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━┷━┷━┷━┷━┷━┷━━━┷━┷━┷━┷━━━┛
  //
  //    間接ページテーブルディスクリプタ
  //      31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  //    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━┓
  //    ┃                                             ページディスクリプタアドレス                                             │  PDT ┃
  //    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━┛
  public static final int MMU_DESCRIPTOR_POINTER_TABLE_ADDRESS  = -1 <<  9;  //x  Pointer Table Address
  public static final int MMU_DESCRIPTOR_PAGE_TABLE_ADDRESS_4KB = -1 <<  6;  //x  Page Table Address (4KB)
  public static final int MMU_DESCRIPTOR_PAGE_TABLE_ADDRESS_8KB = -1 <<  5;  //x  Page Table Address (8KB)
  public static final int MMU_DESCRIPTOR_GLOBAL                 =  1 << 10;  //x  G    Global
  public static final int MMU_DESCRIPTOR_SUPERVISOR_PROTECTED   =  1 <<  7;  //x  S    Supervisor Protected
  public static final int MMU_DESCRIPTOR_MODIFIED               =  1 <<  4;  //x  M    Modified
  public static final int MMU_DESCRIPTOR_USED                   =  1 <<  3;  //x  U    Used
  public static final int MMU_DESCRIPTOR_WRITE_PROTECTED        =  1 <<  2;  //x  W    Write Protected
  public static final int MMU_DESCRIPTOR_UDT                    =  2 <<  0;  //x  UDT  Upper Level Descriptor Type
  public static final int MMU_DESCRIPTOR_PDT                    =  3 <<  0;  //x  PDT  Page Descriptor Type
  public static final int MMU_DESCRIPTOR_TYPE_INVALID           =  0 <<  0;  //          Invalid
  public static final int MMU_DESCRIPTOR_TYPE_INDIRECT          =  2 <<  0;  //          Indirect
  public static final int MMU_DESCRIPTOR_INDIRECT_ADDRESS       = -1 <<  2;  //x  Descriptor Address

  //--------------------------------------------------------------------------------
  //アドレス変換キャッシュ
  //
  //  構造
  //    ユーザモード
  //      ライン0
  //        エントリ0
  //          [0]  論理ページアドレス。リード用。1=無効
  //          [1]  論理ページアドレス。ライト用。修正済みかつライトプロテクトされていないときだけ有効。1=無効
  //          [2]  物理ページアドレス。1=無効
  //          [3]  グローバルフラグ。-1=Global,0=NonGlobal,1=無効
  //        エントリ1
  //        エントリ2
  //        エントリ3
  //      ライン1
  //          :
  //      ライン63
  //    スーパーバイザモード
  //      ライン0
  //        エントリ0
  //          [0]  論理ページアドレス。リード用。1=無効
  //          [1]  論理ページアドレス。ライト用。修正済みかつライトプロテクトされていないときだけ有効。1=無効
  //          [2]  物理ページアドレス。1=無効
  //          [3]  グローバルフラグ。-1=Global,0=NonGlobal,1=無効
  //        エントリ1
  //        エントリ2
  //        エントリ3
  //      ライン1
  //          :
  //      ライン63
  //
  //  ハッシュ関数
  //    次の関数で32bitの論理ページアドレスを6bitのライン番号に変換する
  //      a * 0x5efc103f >>> 26
  //    32bitの中に幅6bit以内で6bitまでセットする組み合わせは1+1+2+4+8+16+32*27=896通りあるが、
  //    それらをa*x>>>26で0～63になるべく均一に分散させる係数を2^32通りの中から探して以下の24個を得た
  //      0x5efbf041  0x5efc0fc1  0x5efc103f  0x5f03efc1  0x5f03f03f  0x5f040fbf
  //      0x60fbf041  0x60fc0fc1  0x60fc103f  0x6103efc1  0x6103f03f  0x61040fbf
  //      0x9efbf041  0x9efc0fc1  0x9efc103f  0x9f03efc1  0x9f03f03f  0x9f040fbf
  //      0xa0fbf041  0xa0fc0fc1  0xa0fc103f  0xa103efc1  0xa103f03f  0xa1040fbf
  //    この中で(0..63)<<12と(0..63)<<13がそれぞれすべて分離するのは
  //      0x5efc103f
  //      0x60fc103f
  //      0x9efc103f
  //      0xa0fc103f
  //    この4個はほぼ同じパターンなので0x5efc103fを係数として用いることにする
  //      perl -e "for$x(0x5efc103f){printf'  //        0x%x%c',$x,10;for$b(7..15){@c=(0)x64;for$n(0..63){$a=$n<<$b;$c[$a*$x>>26&63]++;}printf'  //        %2d %s%c',$b,join('',@c),10;}}"
  //      0x5efc103f
  //       7 2111111111111111111111111111111101111111111111111111111111111111
  //       8 1111111111111111111111111111111111111111111111111111111111111111
  //       9 1111111111111111111111111111111111111111111111111111111111111111
  //      10 1111111111111111111111111111111111111111111111111111111111111111
  //      11 1111111111111111111111111111111111111111111111111111111111111111
  //      12 1111111111111111111111111111111111111111111111111111111111111111
  //      13 1111111111111111111111111111111111111111111111111111111111111111
  //      14 1111111111111111111111111111111111111111111111111111111111111111
  //      15 2011111111111111111111111111111111111111111111111111111111111111
  //    ページサイズが2^8=256バイトから2^14=16384バイトまで、それぞれ先頭の64ページがすべて異なるハッシュ値を持つことがわかる
  //
  //  1wayセットアソシアティブ
  //    ハッシュ値が衝突したときの速度低下を抑えるため4waysにしてみたが効果がなさそうなので1wayに戻してある
  //    ハッシュ関数を工夫してあるので4waysにしてもほとんどの場合は1番目でヒットするか4番目まですべてミスするかのどちらかになる
  //    1wayを4waysにするとミスしたときの条件分岐が1回から4回に増えてテーブルサーチの開始が遅れる
  //    2ways以上では参照するときに1番目に比較するエントリとアロケートするときに押し出すエントリを適切に選択するための仕組みが必要
  //
  //  LRU(least recently used)方式(2ways以上の場合)
  //    アロケートはラインの中で最も古いエントリを切り捨てて最も新しいエントリを追加する方法で行う
  //    アドレス変換キャッシュは最も新しいエントリが繰り返しアクセスされる場合が多く、ハッシュ関数で十分に分散させられているので、
  //    ここではエントリを常に新しい順にソートしておく方法を用いる
  //    2番目以降のエントリがヒットしたときエントリを並べ替えなければならないので遅くなるが、1番目のヒット率が十分に高ければ問題ない
  //
  //  グローバルフラグ
  //    関連する命令
  //      PFLUSHA       アドレス変換キャッシュのすべてのエントリを無効化する
  //      PFLUSHAN      アドレス変換キャッシュのNonGlobalなエントリを無効化する
  //      PFLUSH (An)   アドレス変換キャッシュの、DFC=1またはDFC=2ならばユーザモード、DFC=5またはDFC=6ならばスーパーバイザモードの、
  //                    論理ページアドレスがAnのエントリを無効化する
  //      PFLUSHN (An)  アドレス変換キャッシュの、DFC=1またはDFC=2ならばユーザモード、DFC=5またはDFC=6ならばスーパーバイザモードの、
  //                    論理ページアドレスがAnかつNonGlobalのエントリを無効化する
  //    グローバルフラグはこれらの命令の動作を変更する以外の機能を持たない
  //
  public static final int MMU_HASH_BITS = 6;
  public static final int MMU_HASH_SIZE = 1 << MMU_HASH_BITS;
  public static final int MMU_HASH_COEFF = 0x5efc103f;  //ハッシュ関数の係数
  public static final int MMU_CACHE_WAYS = 1;  //1=1way,4=4waysセットアソシアティブ
  public static final int[] mmuUserDataCache = new int[4 * MMU_CACHE_WAYS * MMU_HASH_SIZE];
  public static final int[] mmuUserCodeCache = new int[4 * MMU_CACHE_WAYS * MMU_HASH_SIZE];
  public static final int[] mmuSuperDataCache = new int[4 * MMU_CACHE_WAYS * MMU_HASH_SIZE];
  public static final int[] mmuSuperCodeCache = new int[4 * MMU_CACHE_WAYS * MMU_HASH_SIZE];

  //mmuInvalidateAllCache ()
  //  PFLUSHA
  //  アドレス変換キャッシュのすべてのエントリを無効化する
  public static void mmuInvalidateAllCache () {
    Arrays.fill (mmuUserDataCache, 1);
    Arrays.fill (mmuUserCodeCache, 1);
    Arrays.fill (mmuSuperDataCache, 1);
    Arrays.fill (mmuSuperCodeCache, 1);
  }  //mmuInvalidateAllCache()

  //mmuInvalidateAllNonGlobalCache ()
  //  PFLUSHAN
  //  アドレス変換キャッシュのNonGlobalなエントリを無効化する
  public static void mmuInvalidateAllNonGlobalCache () {
    for (int i = 0; i < 4 * MMU_CACHE_WAYS * MMU_HASH_SIZE; i += 4) {
      if (mmuUserDataCache[i + 3] == 0) {  //エントリが有効かつNonGlobal
        mmuUserDataCache[i] = mmuUserDataCache[i + 1] = mmuUserDataCache[i + 2] = mmuUserDataCache[i + 3] = 1;
      }
      if (mmuUserCodeCache[i + 3] == 0) {  //エントリが有効かつNonGlobal
        mmuUserCodeCache[i] = mmuUserCodeCache[i + 1] = mmuUserCodeCache[i + 2] = mmuUserCodeCache[i + 3] = 1;
      }
      if (mmuSuperDataCache[i + 3] == 0) {  //エントリが有効かつNonGlobal
        mmuSuperDataCache[i] = mmuSuperDataCache[i + 1] = mmuSuperDataCache[i + 2] = mmuSuperDataCache[i + 3] = 1;
      }
      if (mmuSuperCodeCache[i + 3] == 0) {  //エントリが有効かつNonGlobal
        mmuSuperCodeCache[i] = mmuSuperCodeCache[i + 1] = mmuSuperCodeCache[i + 2] = mmuSuperCodeCache[i + 3] = 1;
      }
    }
  }  //mmuInvalidateAllNonGlobalCache()

  //mmuInvalidateCache (a)
  //  PFLUSH (An)
  //  アドレス変換キャッシュの、DFC=1またはDFC=2ならばユーザモード、DFC=5またはDFC=6ならばスーパーバイザモードの、
  //  論理ページアドレスがAnのエントリを無効化する
  public static void mmuInvalidateCache (int a) {
    int logicalPage = a & mmuPageAddressMask;
    boolean supervisor = (0b10011111 << 24 << XEiJ.mpuDFC) < 0;
    boolean instruction = (0b00101010 << 24 << XEiJ.mpuDFC) < 0;
    int[] cache = (supervisor ?
                   instruction ? mmuSuperCodeCache : mmuSuperDataCache :
                   instruction ? mmuUserCodeCache : mmuUserDataCache);
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (MMU_CACHE_WAYS == 1) {  //1way
      if (cache[head] == logicalPage) {  //エントリが有効かつ論理ページアドレスがAn
        cache[head] = cache[head + 1] = cache[head + 2] = cache[head + 3] = 1;  //末尾を空ける
        return;
      }
    } else {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head; i <= tail; i += 4) {
        if (cache[i] == logicalPage) {  //エントリが有効かつ論理ページアドレスがAn
          for (int j = i; j < tail; j += 4) {  //後ろを詰める
            cache[j    ] = cache[j + 4];
            cache[j + 1] = cache[j + 5];
            cache[j + 2] = cache[j + 6];
            cache[j + 3] = cache[j + 7];
          }
          cache[tail] = cache[tail + 1] = cache[tail + 2] = cache[tail + 3] = 1;  //末尾を空ける
          return;
        }
      }
    }
  }  //mmuInvalidateCache(int)

  //mmuInvalidateNonGlobalCache (a)
  //  PFLUSHN (An)
  //  アドレス変換キャッシュの、DFC=1またはDFC=2ならばユーザモード、DFC=5またはDFC=6ならばスーパーバイザモードの、
  //  論理ページアドレスがAnかつNonGlobalのエントリを無効化する
  public static void mmuInvalidateNonGlobalCache (int a) {
    int logicalPage = a & mmuPageAddressMask;
    boolean supervisor = (0b10011111 << 24 << XEiJ.mpuDFC) < 0;
    boolean instruction = (0b00101010 << 24 << XEiJ.mpuDFC) < 0;
    int[] cache = (supervisor ?
                   instruction ? mmuSuperCodeCache : mmuSuperDataCache :
                   instruction ? mmuUserCodeCache : mmuUserDataCache);
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (MMU_CACHE_WAYS == 1) {  //1way
      if (cache[head] == logicalPage) {  //エントリが有効かつ論理ページアドレスがAn
        if (cache[head + 3] == 0) {  //エントリが有効かつNonGlobal
          cache[head] = cache[head + 1] = cache[head + 2] = cache[head + 3] = 1;  //末尾を空ける
        }
        return;  //論理ページアドレスがAnのエントリは1つだけなのでそれがNonGlobalでなければ何もしないで終了する
      }
    } else {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head; i <= tail; i += 4) {
        if (cache[i] == logicalPage) {  //エントリが有効かつ論理ページアドレスがAn
          if (cache[i + 3] == 0) {  //エントリが有効かつNonGlobal
            for (int j = i; j < tail; j += 4) {  //後ろを詰める
              cache[j    ] = cache[j + 4];
              cache[j + 1] = cache[j + 5];
              cache[j + 2] = cache[j + 6];
              cache[j + 3] = cache[j + 7];
            }
            cache[tail] = cache[tail + 1] = cache[tail + 2] = cache[tail + 3] = 1;  //末尾を空ける
          }
          return;  //論理ページアドレスがAnのエントリは1つだけなのでそれがNonGlobalでなければ何もしないで終了する
        }
      }
    }
  }  //mmuInvalidateNonGlobalCache(int)

  //--------------------------------------------------------------------------------
  //初期化

  //mmuInit ()
  //  初期化
  public static void mmuInit () {
    mmuUserDataTransparent = new int[256];
    mmuUserCodeTransparent = new int[256];
    mmuSuperDataTransparent = new int[256];
    mmuSuperCodeTransparent = new int[256];
    mmuUserDataDifference = new int[256];
    mmuUserCodeDifference = new int[256];
    mmuSuperDataDifference = new int[256];
    mmuSuperCodeDifference = new int[256];
    mmuReset ();
  }  //mmuInit()

  //mmuReset ()
  //  リセット
  public static void mmuReset () {
    mmuSetDataTransparent (0, 0);
    mmuSetCodeTransparent (0, 0);
    mmuSetTCR (0);
  }  //mmuReset()

  //--------------------------------------------------------------------------------
  //バスアクセス
  //
  //    ByteSign  byte  バイト符号拡張
  //    ByteZero  int   バイトゼロ拡張
  //    WordSign  int   ワード符号拡張
  //    WordZero  int   ワードゼロ拡張
  //    Long      int   ロング
  //    Quad      long  クワッド
  //
  //    Data    データ  1  先頭
  //    Second  データ  1  2番目
  //    Even    データ  2  先頭
  //    Four    データ  4  先頭
  //    Code    コード  2  先頭
  //    Opword  コード  2  先頭(命令ワード)
  //    Exword  コード  2  2番目(拡張ワード)
  //
  //  バイト
  //       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //    ┏━┓
  //    ┃ B┃
  //    ┗━┛
  //        0
  //
  //  ワード
  //    偶数
  //       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //    ┏━━━┓
  //    ┃   W  ┃
  //    ┗━━━┛
  //            0
  //    奇数
  //      -1   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //        ┏━┳━┓
  //        ┃ B┃ B┃
  //        ┗━┻━┛
  //            8   0
  //
  //  ロング
  //    4の倍数
  //       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //    ┏━━━━━━━┓
  //    ┃       L      ┃
  //    ┗━━━━━━━┛
  //                    0
  //    4の倍数+1
  //      -1   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //        ┏━┳━━━┳━┓
  //        ┃ B┃   W  ┃ B┃
  //        ┗━┻━━━┻━┛
  //           24       8   0
  //    4の倍数+2
  //      -2  -1   0   1   2   3   4   5   6   7   8   9  10  11  12  13
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //            ┏━━━┳━━━┓
  //            ┃   W  ┃   W  ┃
  //            ┗━━━┻━━━┛
  //                   16       0
  //    4の倍数+3
  //      -3  -2  -1   0   1   2   3   4   5   6   7   8   9  10  11  12
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //                ┏━┳━━━┳━┓
  //                ┃ B┃   W  ┃ B┃
  //                ┗━┻━━━┻━┛
  //                   24       8   0
  //
  //  クワッド
  //    4の倍数
  //       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //    ┏━━━━━━━┳━━━━━━━┓
  //    ┃       L      ┃       L      ┃
  //    ┗━━━━━━━┻━━━━━━━┛
  //                   32               0
  //    4の倍数+1
  //      -1   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //        ┏━┳━━━┳━━━━━━━┳━┓
  //        ┃ B┃   W  ┃       L      ┃ B┃
  //        ┗━┻━━━┻━━━━━━━┻━┛
  //           56      40               8   0
  //    4の倍数+2
  //      -2  -1   0   1   2   3   4   5   6   7   8   9  10  11  12  13
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //            ┏━━━┳━━━━━━━┳━━━┓
  //            ┃   W  ┃       L      ┃   W  ┃
  //            ┗━━━┻━━━━━━━┻━━━┛
  //                   48              16       0
  //    4の倍数+3
  //      -3  -2  -1   0   1   2   3   4   5   6   7   8   9  10  11  12
  //    ┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳━┯━┯━┯━┳
  //    ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃  │  │  │  ┃
  //    ┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻━┷━┷━┷━┻
  //                ┏━┳━━━━━━━┳━━━┳━┓
  //                ┃ B┃       L      ┃   W  ┃ B┃
  //                ┗━┻━━━━━━━┻━━━┻━┛
  //                   56              24       8   0
  //

  //--------------------------------------------------------------------------------
  //ピーク
  //  デバッガ用
  //  エラーや副作用なしでリードする
  //  アドレス変換はピーク
  //  ページフォルトやバスエラーのときは-1をキャストした値を返す

  //d = mmuPeekByteSign (a, f)
  //  ピークバイト符号拡張
  public static byte mmuPeekByteSign (int a, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //SFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      return (a ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0) : -1;
    } else if (f != 7) {  //SFC=0,3,4。アドレス変換なし
      return mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a);
    } else {
      return -1;
    }
  }  //mmuPeekByteSign(int,int)

  //d = mmuPeekByteZero (a, f)
  //  ピークバイトゼロ拡張
  public static int mmuPeekByteZero (int a, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //SFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      return (a ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a0) : 0xff;
      //                                                        ^        ^^^^
    } else if (f != 7) {  //SFC=0,3,4。アドレス変換なし
      return mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a);
      //                                       ^
    } else {
      return 0xff;
      //     ^^^^
    }
  }  //mmuPeekByteZero(int,int)

  //d = mmuPeekByteSignData (a, supervisor)
  //  ピークバイト符号拡張(データ)
  public static byte mmuPeekByteSignData (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);
    return (a ^ a0) == 1 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0);
  }  //mmuPeekByteSignData(int,int)

  //d = mmuPeekByteSignCode (a, supervisor)
  //  ピークバイト符号拡張(コード)
  public static byte mmuPeekByteSignCode (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 1);
    return (a ^ a0) == 1 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0);
  }  //mmuPeekByteSignCode(int,int)

  //d = mmuPeekByteZeroData (a, supervisor)
  //  ピークバイトゼロ拡張(データ)
  public static int mmuPeekByteZeroData (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);
    return (a ^ a0) == 1 ? 255 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a0);
  }  //mmuPeekByteZeroData(int,int)

  //d = mmuPeekByteZeroCode (a, supervisor)
  //  ピークバイトゼロ拡張(コード)
  public static int mmuPeekByteZeroCode (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 1);
    return (a ^ a0) == 1 ? 255 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a0);
  }  //mmuPeekByteZeroCode(int,int)

  //d = mmuPeekWordSign (a, f)
  //  ピークワード符号拡張
  public static int mmuPeekWordSign (int a, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //SFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      if ((a & 1) == 0) {  //偶数
        return (a ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0) : -1;
      } else {  //奇数
        int a1 = mmuTranslatePeek (a + 1, f & 4, f & 2);
        return (((a     ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0) :  -1) << 8 |
                ((a + 1 ^ a1) != 1 ? mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a1) : 255));
      }
    } else if (f != 7) {  //SFC=0,3,4。アドレス変換なし
      if ((a & 1) == 0) {  //偶数
        return mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPws (a);
      } else {  //奇数
        return (mm[a     >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a    ) << 8 |
                mm[a + 1 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a + 1));
      }
    } else {
      return -1;
    }
  }  //mmuPeekWordSign(int,int)

  //d = mmuPeekWordSignData (a, supervisor)
  //  ピークワード符号拡張(データ)
  public static int mmuPeekWordSignData (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);  //a+1が必要なので上書き不可
    if ((a & 1) == 0) {  //偶数
      return (a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0);
    } else {  //奇数
      int a1 = mmuTranslatePeek (a + 1, supervisor, 0);
      return (((a0 & 1) == 0 ?  -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0)) << 8 |
              ((a1 & 1) != 0 ? 255 : mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a1)));
    }
  }  //mmuPeekWordSignData(int,int)

  //d = mmuPeekWordSignEven (a, supervisor)
  //  ピークワード符号拡張(偶数)
  public static int mmuPeekWordSignEven (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    a = mmuTranslatePeek (a, supervisor, 0);
    return (a & 1) != 0 ? -1 : mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPws (a);
  }  //mmuPeekWordSignEven(int,int)

  //d = mmuPeekWordSignCode (a, supervisor)
  //  ピークワード符号拡張(コード)
  public static int mmuPeekWordSignCode (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    a = mmuTranslatePeek (a, supervisor, 1);
    return (a & 1) != 0 ? -1 : mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPws (a);
  }  //mmuPeekWordSignCode(int,int)

  //d = mmuPeekWordZeroData (a, supervisor)
  //  ピークワードゼロ拡張(データ)
  public static int mmuPeekWordZeroData (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);  //a+1が必要なので上書き不可
    if ((a & 1) == 0) {  //偶数
      return (a0 & 1) != 0 ? 65535 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a0);
    } else {  //奇数
      int a1 = mmuTranslatePeek (a + 1, supervisor, 0);
      return (((a0 & 1) == 0 ? 255 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a0)) << 8 |
              ((a1 & 1) != 0 ? 255 : mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a1)));
    }
  }  //mmuPeekWordZeroData(int,int)

  //d = mmuPeekWordZeroEven (a, supervisor)
  //  ピークワードゼロ拡張(偶数)
  public static int mmuPeekWordZeroEven (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    a = mmuTranslatePeek (a, supervisor, 0);
    return (a & 1) != 0 ? 65535 : mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a);
  }  //mmuPeekWordZeroEven(int,int)

  //d = mmuPeekWordZeroCode (a, supervisor)
  //  ピークワードゼロ拡張(コード)
  public static int mmuPeekWordZeroCode (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    a = mmuTranslatePeek (a, supervisor, 1);
    return (a & 1) != 0 ? 65535 : mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a);
  }  //mmuPeekWordZeroCode(int,int)

  //d = mmuPeekLong (a, f)
  //  ピークロング
  public static int mmuPeekLong (int a, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //SFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      if ((a & 3) == 0) {  //4の倍数
        return (a ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0) : -1;
      } else if ((a & 1) == 0) {  //4の倍数ではない偶数
        int a2 = mmuTranslatePeek (a + 2, f & 4, f & 2);
        return (((a     ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0) :    -1) << 16 |
                ((a + 2 ^ a2) != 1 ? mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a2) : 65535));
      } else {  //奇数
        int a1 = mmuTranslatePeek (a + 1, f & 4, f & 2);
        int a3 = mmuTranslatePeek (a + 3, f & 4, f & 2);
        return (((a     ^ a0) != 1 ? mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0) :    -1) << 24 |
                ((a + 1 ^ a1) != 1 ? mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a1) : 65535) <<  8 |
                ((a + 3 ^ a3) != 1 ? mm[a3 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a3) :   255));
      }
    } else if (f != 7) {  //SFC=0,3,4。アドレス変換なし
      if ((a & 3) == 0) {  //4の倍数
        return mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPls (a);
      } else if ((a & 1) == 0) {  //4の倍数ではない偶数
        return (mm[a     >>> XEiJ.BUS_PAGE_BITS].mmdPws (a    ) << 16 |
                mm[a + 2 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a + 2));
      } else {  //奇数
        return (mm[a     >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a    ) << 24 |
                mm[a + 1 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a + 1) <<  8 |
                mm[a + 3 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a + 3));
      }
    } else {
      return -1;
    }
  }  //mmuPeekLong(int,int)

  //d = mmuPeekLongData (a, supervisor)
  //  ピークロング(データ)
  public static int mmuPeekLongData (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);  //a+1,a+2,a+3が必要なので上書き不可
    if ((a & 3) == 0) {  //4の倍数
      return (a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0);
    } else if ((a & 1) == 0) {  //4の倍数+2
      int a2 = mmuTranslatePeek (a + 2, supervisor, 0);
      return (((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0)) << 16 |
              ((a2 & 1) != 0 ? 65535 : mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a2)));
    } else {  //奇数
      int a1 = mmuTranslatePeek (a + 1, supervisor, 0);
      int a3 = mmuTranslatePeek (a + 3, supervisor, 0);
      return (((a0 & 1) == 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0)) << 24 |
              ((a1 & 1) != 0 ? 65535 : mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a1)) << 16 |
              ((a3 & 1) != 0 ?   255 : mm[a3 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a3)));
    }
  }  //mmuPeekLongData(int,int)

  //d = mmuPeekLongEven (a, supervisor)
  //  ピークロング(偶数)
  public static int mmuPeekLongEven (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);  //a+2が必要なので上書き不可
    if ((a & 2) == 0) {  //4の倍数
      return (a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0);
    } else {  //4の倍数+2
      int a2 = mmuTranslatePeek (a + 2, supervisor, 0);
      return (((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0)) << 16 |
              ((a2 & 1) != 0 ? 65535 : mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a2)));
    }
  }  //mmuPeekLongEven(int,int)

  //d = mmuPeekLongFour (a, supervisor)
  //  ピークロング(4の倍数)
  public static int mmuPeekLongFour (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    a = mmuTranslatePeek (a, supervisor, 0);
    return (a & 1) != 0 ? -1 : mm[a >>> XEiJ.BUS_PAGE_BITS].mmdPls (a);
  }  //mmuPeekLongFour(int,int)

  //d = mmuPeekLongCode (a, supervisor)
  //  ピークロング(コード)
  public static int mmuPeekLongCode (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 1);  //a+2が必要なので上書き不可
    if ((a & 2) == 0) {  //4の倍数
      return (a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0);
    } else {  //4の倍数+2
      int a2 = mmuTranslatePeek (a + 2, supervisor, 1);
      return (((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0)) << 16 |
              ((a2 & 1) != 0 ? 65535 : mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a2)));
    }
  }  //mmuPeekLongCode(int,int)

  //d = mmuPeekQuad (a, f)
  //  ピーククワッド
  public static long mmuPeekQuad (int a, int f) {
    return (long) mmuPeekLong (a, f) << 32 | mmuPeekLong (a + 4, f) & 0xffffffffL;
  }  //mmuPeekQuad(int,int)

  //d = mmuPeekQuadData (a, supervisor)
  //  ピーククワッド(データ)
  public static long mmuPeekQuadData (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
    if ((a & 3) == 0) {  //4の倍数
      int a4 = mmuTranslatePeek (a + 4, supervisor, 0);  //4の倍数
      return ((long) ((a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0)) << 32 |
              (long) ((a4 & 1) != 0 ? -1 : mm[a4 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a4)) & 0x00000000ffffffffL);
    } else if ((a & 1) == 0) {  //4の倍数+2
      int a2 = mmuTranslatePeek (a + 2, supervisor, 0);  //4の倍数
      int a6 = mmuTranslatePeek (a + 6, supervisor, 0);  //4の倍数
      return ((long) ((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0)) << 48 |
              (long) ((a2 & 1) != 0 ?    -1 : mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a2)) << 16 & 0x0000ffffffff0000L |
              (long) ((a6 & 1) != 0 ? 65535 : mm[a6 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a6)));
    } else if ((a & 3) == 1) {  //4の倍数+1
      int a1 = mmuTranslatePeek (a + 1, supervisor, 0);  //4の倍数+2
      int a3 = mmuTranslatePeek (a + 3, supervisor, 0);  //4の倍数
      int a7 = mmuTranslatePeek (a + 7, supervisor, 0);  //4の倍数
      return ((long) ((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0)) << 56 |
              (long) ((a1 & 1) != 0 ? 65535 : mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a1)) << 40 |
              (long) ((a3 & 1) != 0 ?    -1 : mm[a3 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a3)) <<  8 & 0x000000ffffffff00L |
              (long) ((a7 & 1) != 0 ?   255 : mm[a7 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a7)));
    } else {  //4の倍数+3
      int a1 = mmuTranslatePeek (a + 1, supervisor, 0);  //4の倍数
      int a5 = mmuTranslatePeek (a + 5, supervisor, 0);  //4の倍数
      int a7 = mmuTranslatePeek (a + 7, supervisor, 0);  //4の倍数+2
      return ((long) ((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPbs (a0)) << 56 |
              (long) ((a1 & 1) != 0 ?    -1 : mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a1)) << 24 & 0x00ffffffff000000L |
              (long) ((a5 & 1) != 0 ? 65535 : mm[a5 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a5)) <<  8 |
              (long) ((a7 & 1) != 0 ?   255 : mm[a7 >>> XEiJ.BUS_PAGE_BITS].mmdPbz (a7)));
    }
  }  //mmuPeekQuadData(int,int)

  //d = mmuPeekQuadEven (a, supervisor)
  //  ピーククワッド(偶数)
  public static long mmuPeekQuadEven (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);  //a+2,a+4,a+6が必要なので上書き不可
    if ((a & 2) == 0) {  //4の倍数
      int a4 = mmuTranslatePeek (a + 4, supervisor, 0);  //4の倍数
      return ((long) ((a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0)) << 32 |
              (long) ((a4 & 1) != 0 ? -1 : mm[a4 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a4)) & 0x00000000ffffffffL);
    } else {  //4の倍数+2
      int a2 = mmuTranslatePeek (a + 2, supervisor, 0);  //4の倍数
      int a6 = mmuTranslatePeek (a + 6, supervisor, 0);  //4の倍数
      return ((long) ((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0)) << 48 |
              (long) ((a2 & 1) != 0 ?    -1 : mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a2)) << 16 & 0x0000ffffffff0000L |
              (long) ((a6 & 1) != 0 ? 65535 : mm[a6 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a6)));
    }
  }  //mmuPeekQuadEven(int,int)

  //d = mmuPeekQuadFour (a, supervisor)
  //  ピーククワッド(4の倍数)
  public static long mmuPeekQuadFour (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a    , supervisor, 0);  //4の倍数。a+4が必要なので上書き不可
    int a4 = mmuTranslatePeek (a + 4, supervisor, 0);  //4の倍数
    return ((long) ((a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0)) << 32 |
            (long) ((a4 & 1) != 0 ? -1 : mm[a4 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a4)) & 0x00000000ffffffffL);
  }  //mmuPeekQuadFour(int,int)

  //d = mmuPeekQuadCode (a, supervisor)
  //  ピーククワッド(コード)
  public static long mmuPeekQuadCode (int a, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 1);  //a+2,a+4,a+6が必要なので上書き不可
    if ((a & 2) == 0) {  //4の倍数
      int a4 = mmuTranslatePeek (a + 4, supervisor, 1);
      return ((long) ((a0 & 1) != 0 ? -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a0)) << 32 |
              (long) ((a4 & 1) != 0 ? -1 : mm[a4 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a4)) & 0x00000000ffffffffL);
    } else {  //4の倍数+2
      int a2 = mmuTranslatePeek (a + 2, supervisor, 1);  //4の倍数
      int a6 = mmuTranslatePeek (a + 6, supervisor, 1);  //4の倍数
      return ((long) ((a0 & 1) != 0 ?    -1 : mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdPws (a0)) << 48 |
              (long) ((a2 & 1) != 0 ?    -1 : mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdPls (a2)) << 16 & 0x0000ffffffff0000L |
              (long) ((a6 & 1) != 0 ? 65535 : mm[a6 >>> XEiJ.BUS_PAGE_BITS].mmdPwz (a6)));
    }
  }  //mmuPeekQuadCode(int,int)

  //mmuPeekExtended (a, b, f)
  //  ピークエクステンデッド
  public static void mmuPeekExtended (int a, byte[] b, int f) {
    for (int i = 0; i < 12; i++) {
      b[i] = mmuPeekByteSign (a + i, f);
    }
  }  //mmuPeekExtended(int,int,byte[])

  //len = mmuPeekStrlen (a, l)
  public static int mmuPeekStrlen (int a, int l, int supervisor) {
    for (int i = 0; i < l; i++) {
      if (mmuPeekByteZeroData (a + i, supervisor) == 0) {
        return i;
      }
    }
    return l;
  }  //mmuPeekStrlen(int,int,int)

  //bool = mmuPeekEquals (a, str)
  //  アドレスaから始まるSJISの文字列とstrをSJISに変換してエスケープシーケンスを展開した文字列を比較する
  //  終端の\0まで比較するときはstrに\0を含めること
  //  \x??で任意のSJISの文字を書ける
  //  SJISに変換できない文字は'※'とみなす
  //  スーパーバイザモード比較する
  public static boolean mmuPeekEquals (int a, String str) {
    int len = str.length ();
    for (int i = 0; i < len; i++) {
      int c = str.charAt (i);
      if (c == '\\') {  //エスケープシーケンス。SJIS変換を省略する
        int d = i + 1 < len ? str.charAt (i + 1) : -1;  //2文字目
        if ((d & -4) == '0') {  // \[0-3][0-7]{0,2}
          c = d & 7;
          d = i + 2 < len ? str.charAt (i + 2) : -1;  //3文字目
          if ((d & -8) == '0') {
            c = c << 3 | (d & 7);
            d = i + 3 < len ? str.charAt (i + 3) : -1;  //4文字目
            if ((d & -8) == '0') {
              c = c << 3 | (d & 7);
              i++;  //4文字
            }
            i++;  //3文字
          }
          i++;  //2文字
        } else if ((d & -4) == '4') {  // \[4-7][0-7]?
          c = d & 7;
          d = i + 2 < len ? str.charAt (i + 2) : -1;  //3文字目
          if ((d & -8) == '0') {
            c = c << 3 | (d & 7);
            i++;  //3文字
          }
          i++;  //2文字
        } else if (d == 'b') {  // \b
          c = 0x08;  //BS
          i++;  //2文字
        } else if (d == 't') {  // \t
          c = 0x09;  //HT
          i++;  //2文字
        } else if (d == 'n') {  // \n
          c = 0x0a;  //LF
          i++;  //2文字
        } else if (d == 'v') {  // \v
          c = 0x0b;  //VT
          i++;  //2文字
        } else if (d == 'f') {  // \f
          c = 0x0c;  //FF
          i++;  //2文字
        } else if (d == 'r') {  // \r
          c = 0x0d;  //CR
          i++;  //2文字
        } else if (d == 'x' &&
                   i + 3 < len &&
                   CharacterCode.chrIsXdigit (str.charAt (i + 2)) &&
                   CharacterCode.chrIsXdigit (str.charAt (i + 3))) {  // \x[0-9A-Fa-f]{2}
          c = (CharacterCode.chrDigit (str.charAt (i + 2)) << 4 |
               CharacterCode.chrDigit (str.charAt (i + 3)));
          i += 3;  //4文字
        } else if ('!' <= d && d <= '~') {
          c = d;
          i++;  //2文字
        }
        if (mmuPeekByteZeroData (a++, 1) != c) {
          return false;
        }
      } else {  //エスケープシーケンス以外
        int s = CharacterCode.chrCharToSJIS[c];
        if (s == 0 && c != 0) {
          s = 0x81a6;  //'※'
        }
        if (s >> 8 != 0) {  //2バイトコード
          if (mmuPeekByteZeroData (a++, 1) != s >> 8) {
            return false;
          }
        }
        if (mmuPeekByteZeroData (a++, 1) != (s & 0xff)) {
          return false;
        }
      }
    }  //for
    return true;
  }  //mmuPeekEquals

  //s = mmuPeekStringL (a, l, supervisor)
  //sb = mmuPeekStringL (sb, a, l, supervisor)
  //  ピークストリング(長さ指定)
  //  文字列を読み出す
  //  対応する文字がないときは'.'または'※'になる
  //  制御コードは'.'になる
  public static String mmuPeekStringL (int a, int l, int supervisor) {
    return mmuPeekStringL (new StringBuilder (), a, l, supervisor).toString ();
  }  //mmuPeekStringL(int,int,int)
  public static StringBuilder mmuPeekStringL (StringBuilder sb, int a, int l, int supervisor) {
    for (int i = 0; i < l; i++) {
      int s = mmuPeekByteZeroData (a + i, supervisor);
      char c;
      if (0x81 <= s && s <= 0x9f || 0xe0 <= s && s <= 0xef) {  //SJISの2バイトコードの1バイト目
        int t = i + 1 < l ? mmuPeekByteZeroData (a + i + 1, supervisor) : 0;
        if (0x40 <= t && t != 0x7f && t <= 0xfc) {  //SJISの2バイトコードの2バイト目
          c = CharacterCode.chrSJISToChar[s << 8 | t];  //2バイトで変換する
          if (c == 0) {  //対応する文字がない
            c = '※';
          }
          i++;
        } else {  //SJISの2バイトコードの2バイト目ではない
          c = '.';  //SJISの2バイトコードの1バイト目ではなかった
        }
      } else {  //SJISの2バイトコードの1バイト目ではない
        c = CharacterCode.chrSJISToChar[s];  //1バイトで変換する
        if (c < 0x20 || c == 0x7f) {  //対応する文字がないまたは制御コード
          c = '.';
        }
      }
      sb.append (c);
    }
    return sb;
  }  //mmuPeekString(StringBuilder,int,int,int)

  //s = mmuPeekStringZ (a, f)
  //sb = mmuPeekStringZ (sb, a, f)
  //  ピークストリング
  //  文字列をSJISからUTF-16に変換しながらメモリから読み出す
  //  '\0'の手前まで読み出す
  //  UTF-16に変換できない文字は'\ufffd'になる
  public static String mmuPeekStringZ (int a, int f) {
    return mmuPeekStringZ (new StringBuilder (), a, f).toString ();
  }  //mmuPeekStringZ(int,int)
  public static StringBuilder mmuPeekStringZ (StringBuilder sb, int a, int f) {
    for (;;) {
      int s = mmuPeekByteSign (a++, f) & 255;
      if (s == 0) {
        break;
      }
      int u;
      if (0x81 <= s && s <= 0x9f || 0xe0 <= s && s <= 0xef) {  //SJISの2バイトコードの1バイト目
        int t = mmuPeekByteSign (a++, f) & 255;
        if (t == 0) {
          sb.append ('\ufffd');
          break;
        }
        if (0x40 <= t && t != 0x7f && t <= 0xfc) {  //SJISの2バイトコードの2バイト目
          t |= s << 8;
          u = CharacterCode.chrSJISToChar[t];  //2バイトで変換する
          if (u == 0) {  //変換できない
            u = 0xfffd;
          }
        } else {  //SJISの2バイトコードの2バイト目ではない
          u = 0xfffd;
        }
      } else {  //SJISの2バイトコードの1バイト目ではない
        u = CharacterCode.chrSJISToChar[s];  //1バイトで変換する
        if (u == 0) {  //変換できない
          u = 0xfffd;
        }
      }
      sb.append ((char) u);
    }
    return sb;
  }  //mmuPeekStringZ(StringBuilder,int,int)

  //--------------------------------------------------------------------------------
  //リード
  //  アドレス変換はリード
  //  FSLWのRead and WriteはRead

  //d = mmuReadByteSignData (a, supervisor)
  //  リードバイト符号拡張(データ)
  public static byte mmuReadByteSignData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
    }
  }  //mmuReadByteSignData(int,int)

  //d = mmuReadByteZeroData (a, supervisor)
  //  リードバイトゼロ拡張(データ)
  public static int mmuReadByteZeroData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
    }
  }  //mmuReadByteZeroData(int,int)

  //d = mmuReadByteSignExword (a, supervisor)
  //  リードバイト符号拡張(拡張ワード)
  public static byte mmuReadByteSignExword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_CODE;
      int a0 = mmuTranslateReadSuperCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_CODE;
      int a0 = mmuTranslateReadUserCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
    }
  }  //mmuReadByteSignExword(int,int)

  //d = mmuReadByteZeroExword (a, supervisor)
  //  リードバイトゼロ拡張(拡張ワード)
  public static int mmuReadByteZeroExword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_CODE;
      int a0 = mmuTranslateReadSuperCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_CODE;
      int a0 = mmuTranslateReadUserCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
    }
  }  //mmuReadByteZeroExword(int,int)

  //d = mmuReadWordSignData (a, supervisor)
  //  リードワード符号拡張(データ)
  public static int mmuReadWordSignData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadSuperData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadUserData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    }
  }  //mmuReadWordSignData(int,int)

  //d = mmuReadWordZeroData (a, supervisor)
  //  リードワードゼロ拡張(データ)
  public static int mmuReadWordZeroData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadSuperData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadUserData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    }
  }  //mmuReadWordZeroData(int,int)

  //d = mmuReadWordSignEven (a, supervisor)
  //  リードワード符号拡張(偶数)
  public static int mmuReadWordSignEven (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateReadSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateReadUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    }
  }  //mmuReadWordSignEven(int,int)

  //d = mmuReadWordZeroEven (a, supervisor)
  //  リードワードゼロ拡張(偶数)
  public static int mmuReadWordZeroEven (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateReadSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateReadUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    }
  }  //mmuReadWordZeroEven(int,int)

  //d = mmuReadWordSignExword (a, supervisor)
  //  リードワード符号拡張(拡張ワード)
  public static int mmuReadWordSignExword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_CODE;
      a = mmuTranslateReadSuperCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_CODE;
      a = mmuTranslateReadUserCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    }
  }  //mmuReadWordSignExword(int,int)

  //d = mmuReadWordZeroExword (a, supervisor)
  //  リードワードゼロ拡張(拡張ワード)
  public static int mmuReadWordZeroExword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_CODE;
      a = mmuTranslateReadSuperCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_CODE;
      a = mmuTranslateReadUserCode (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    }
  }  //mmuReadWordZeroExword(int,int)

  //d = mmuReadWordSignOpword (a, supervisor)
  //  リードワード符号拡張(命令ワード)
  public static int mmuReadWordSignOpword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_OPWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_CODE;
      a = mmuTranslateReadSuperCode (a);
      return (InstructionBreakPoint.IBP_ON ? InstructionBreakPoint.ibpOp1SuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_OPWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_CODE;
      a = mmuTranslateReadUserCode (a);
      return (InstructionBreakPoint.IBP_ON ? InstructionBreakPoint.ibpOp1UserMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    }
  }  //mmuReadWordSignOpword(int,int)

  //d = mmuReadWordZeroOpword (a, supervisor)
  //  リードワードゼロ拡張(命令ワード)
  public static int mmuReadWordZeroOpword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_OPWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_CODE;
      a = mmuTranslateReadSuperCode (a);
      return (InstructionBreakPoint.IBP_ON ? InstructionBreakPoint.ibpOp1SuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_OPWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_CODE;
      a = mmuTranslateReadUserCode (a);
      return (InstructionBreakPoint.IBP_ON ? InstructionBreakPoint.ibpOp1UserMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    }
  }  //mmuReadWordZeroOpword(int,int)

  //d = mmuReadLongData (a, supervisor)
  //  リードロング(データ)
  public static int mmuReadLongData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);  //a+1,a+2,a+3が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateReadSuperData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadSuperData (a + 1);  //偶数
        int a3 = mmuTranslateReadSuperData (a + 3);  //偶数
        return (d0 << 24 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a3));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);  //a+1,a+2,a+3が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateReadUserData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadUserData (a + 1);  //偶数
        int a3 = mmuTranslateReadUserData (a + 3);  //偶数
        return (d0 << 24 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a3));
      }
    }
  }  //mmuReadLongData(int,int)

  //d = mmuReadLongEven (a, supervisor)
  //  リードロング(偶数)
  public static int mmuReadLongEven (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateReadSuperData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateReadUserData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      }
    }
  }  //mmuReadLongEven(int,int)

  //d = mmuReadLongExword (a, supervisor)
  //  リードロング(拡張ワード)
  public static int mmuReadLongExword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_CODE;
      int a0 = mmuTranslateReadSuperData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else {  //4の倍数+2
        int a2 = mmuTranslateReadSuperData (a + 2);  //偶数
        return ((DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0) << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_CODE;
      int a0 = mmuTranslateReadUserData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else {  //4の倍数+2
        int a2 = mmuTranslateReadUserData (a + 2);  //偶数
        return ((DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0) << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      }
    }
  }  //mmuReadLongExword(int,int)

  //d = mmuReadLongFour (a, supervisor)
  //  リードロング(4の倍数)
  public static int mmuReadLongFour (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateReadSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRls (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateReadUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRls (a);
    }
  }  //mmuReadLongFour(int,int)

  //l = mmuReadQuadData (a, supervisor)
  //  リードクワッド(データ)
  public static long mmuReadQuadData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        int a4 = mmuTranslateReadSuperData (a + 4);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0) << 32 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a4 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a4) & 0x00000000ffffffffL);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateReadSuperData (a + 2);  //4の倍数
        int a6 = mmuTranslateReadSuperData (a + 6);  //4の倍数
        return ((long) d0 << 48 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a2) << 16 & 0x0000ffffffff0000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a6 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a6));
      } else if ((a & 3) == 1) {  //4の倍数+1
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadSuperData (a + 1);  //4の倍数+2
        int a3 = mmuTranslateReadSuperData (a + 3);  //4の倍数
        int a7 = mmuTranslateReadSuperData (a + 7);  //4の倍数
        return ((long) d0 << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 40 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a3) << 8 & 0x000000ffffffff00L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      } else {  //  //4の倍数+3
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadSuperData (a + 1);  //4の倍数
        int a5 = mmuTranslateReadSuperData (a + 5);  //4の倍数
        int a7 = mmuTranslateReadSuperData (a + 7);  //4の倍数+2
        return ((long) d0 << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a1) << 24 & 0x00ffffffff000000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a5 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a5) << 8 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        int a4 = mmuTranslateReadUserData (a + 4);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0) << 32 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a4 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a4) & 0x00000000ffffffffL);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateReadUserData (a + 2);  //4の倍数
        int a6 = mmuTranslateReadUserData (a + 6);  //4の倍数
        return ((long) d0 << 48 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a2) << 16 & 0x0000ffffffff0000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a6 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a6));
      } else if ((a & 3) == 1) {  //4の倍数+1
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadUserData (a + 1);  //4の倍数+2
        int a3 = mmuTranslateReadUserData (a + 3);  //4の倍数
        int a7 = mmuTranslateReadUserData (a + 7);  //4の倍数
        return ((long) d0 << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 40 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a3) << 8 & 0x000000ffffffff00L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      } else {  //  //4の倍数+3
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateReadUserData (a + 1);  //4の倍数
        int a5 = mmuTranslateReadUserData (a + 5);  //4の倍数
        int a7 = mmuTranslateReadUserData (a + 7);  //4の倍数+2
        return ((long) d0 << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a1) << 24 & 0x00ffffffff000000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a5 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a5) << 8 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      }
    }
  }  //mmuReadQuadData(int,int)

  //l = mmuReadQuadSecond (a, supervisor)
  //  リードクワッド(2番目)
  //  エクステンデッドとラインの2番目で使う
  public static long mmuReadQuadSecond (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_SECOND | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateReadSuperData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        int a4 = mmuTranslateReadSuperData (a + 4);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0) << 32 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a4 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a4) & 0x00000000ffffffffL);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int a2 = mmuTranslateReadSuperData (a + 2);  //4の倍数
        int a6 = mmuTranslateReadSuperData (a + 6);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0) << 48 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a2) << 16 & 0x0000ffffffff0000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a6 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a6));
      } else if ((a & 3) == 1) {  //4の倍数+1
        int a1 = mmuTranslateReadSuperData (a + 1);  //4の倍数+2
        int a3 = mmuTranslateReadSuperData (a + 3);  //4の倍数
        int a7 = mmuTranslateReadSuperData (a + 7);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0) << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 40 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a3) << 8 & 0x000000ffffffff00L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      } else {  //  //4の倍数+3
        int a1 = mmuTranslateReadSuperData (a + 1);  //4の倍数
        int a5 = mmuTranslateReadSuperData (a + 5);  //4の倍数
        int a7 = mmuTranslateReadSuperData (a + 7);  //4の倍数+2
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0) << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a1) << 24 & 0x00ffffffff000000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a5 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a5) << 8 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_SECOND | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateReadUserData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        int a4 = mmuTranslateReadUserData (a + 4);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0) << 32 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a4 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a4) & 0x00000000ffffffffL);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int a2 = mmuTranslateReadUserData (a + 2);  //4の倍数
        int a6 = mmuTranslateReadUserData (a + 6);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0) << 48 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a2) << 16 & 0x0000ffffffff0000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a6 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a6));
      } else if ((a & 3) == 1) {  //4の倍数+1
        int a1 = mmuTranslateReadUserData (a + 1);  //4の倍数+2
        int a3 = mmuTranslateReadUserData (a + 3);  //4の倍数
        int a7 = mmuTranslateReadUserData (a + 7);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0) << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 40 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a3) << 8 & 0x000000ffffffff00L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      } else {  //  //4の倍数+3
        int a1 = mmuTranslateReadUserData (a + 1);  //4の倍数
        int a5 = mmuTranslateReadUserData (a + 5);  //4の倍数
        int a7 = mmuTranslateReadUserData (a + 7);  //4の倍数+2
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0) << 56 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a1) << 24 & 0x00ffffffff000000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a5 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a5) << 8 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a7 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a7));
      }
    }
  }  //mmuReadQuadSecond(int,int)

  //l = mmuReadQuadExword (a, supervisor)
  //  リードクワッド(拡張ワード)
  //  イミディエイトで使う
  public static long mmuReadQuadExword (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_SUPER_CODE;
      int a0 = mmuTranslateReadSuperData (a);  //a+2,a+4,a+6が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        int a4 = mmuTranslateReadSuperData (a + 4);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0) << 32 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a4 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a4) & 0x00000000ffffffffL);
      } else {  //4の倍数+2
        int a2 = mmuTranslateReadSuperData (a + 2);  //4の倍数
        int a6 = mmuTranslateReadSuperData (a + 6);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0) << 48 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a2) << 16 & 0x0000ffffffff0000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a6 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a6));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_EXWORD | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_USER_CODE;
      int a0 = mmuTranslateReadUserData (a);  //a+2,a+4,a+6が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        int a4 = mmuTranslateReadUserData (a + 4);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0) << 32 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a4 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a4) & 0x00000000ffffffffL);
      } else {  //4の倍数+2
        int a2 = mmuTranslateReadUserData (a + 2);  //4の倍数
        int a6 = mmuTranslateReadUserData (a + 6);  //4の倍数
        return ((long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0) << 48 |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a2) << 16 & 0x0000ffffffff0000L |
                (long) (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a6 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a6));
      }
    }
  }  //mmuReadQuadExword(int,int)

  //mmuReadByteArray (address, array, offset, length, supervisor)
  //  リードバイト配列
  public static void mmuReadByteArray (int address, byte[] array, int offset, int length, int supervisor) throws M68kException {
    if (false) {  //1バイトずつアドレス変換する
      for (int index = 0; index < length; index++) {
        array[offset + index] = mmuReadByteSignData (address + index, supervisor);
      }
    } else {  //1ページずつアドレス変換する
      int pageSize = Math.min (XEiJ.BUS_PAGE_SIZE, mmuPageSize);
      if (supervisor != 0) {  //スーパーバイザモード
        if (false) {  //1バイトずつ転送する
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
        }
        MemoryMappedDevice[] mm = DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap;
        while (0 < length) {
          int l = Math.min (pageSize - (address & (pageSize - 1)), length);  //今回転送する長さ
          int t = mmuTranslateReadSuperData (address);
          MemoryMappedDevice d = mm[t >>> XEiJ.BUS_PAGE_BITS];
          if (false) {  //1バイトずつ転送する
            for (int i = 0; i < l; i++) {
              array[offset + i] = d.mmdRbs (t + i);
            }
          } else {  //4バイトずつ転送する。ウェイトサイクルを減らす
            int o = offset;
            int z = t + l;
            if ((t & 1) != 0 && t < z) {  //2n+1で残り1以上。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
              array[o++] = d.mmdRbs (t++);
            }
            if ((t & 2) != 0 && t + 1 < z) {  //4n+2で残り2以上。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
              int x = d.mmdRws (t);
              array[o    ] = (byte) (x >> 8);
              array[o + 1] = (byte)  x;
              t += 2;
              o += 2;
            }
            if (t + 3 < z) {  //4nで残り4以上。4バイトずつ転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
              do {
                int x = d.mmdRls (t);
                array[o    ] = (byte) (x >> 24);
                array[o + 1] = (byte) (x >> 16);
                array[o + 2] = (byte) (x >>  8);
                array[o + 3] = (byte)  x;
                t += 4;
                o += 4;
              } while (t + 3 < z);
            }
            if (t + 1 < z) {  //4nで残り2または3。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
              int x = d.mmdRws (t);
              array[o    ] = (byte) (x >> 8);
              array[o + 1] = (byte)  x;
              t += 2;
              o += 2;
            }
            if (t < z) {  //4nで残り1。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
              array[o++] = d.mmdRbs (t++);
            }
          }  //if 1バイトずつ/4バイトずつ
          address += l;
          offset += l;
          length -= l;
        }  //while 0<length
      } else {  //ユーザモード
        if (false) {  //1バイトずつ転送する
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
        }
        MemoryMappedDevice[] mm = DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
        while (0 < length) {
          int l = Math.min (pageSize - (address & (pageSize - 1)), length);  //今回転送する長さ
          int t = mmuTranslateReadUserData (address);
          MemoryMappedDevice d = mm[t >>> XEiJ.BUS_PAGE_BITS];
          if (false) {  //1バイトずつ転送する
            for (int i = 0; i < l; i++) {
              array[offset + i] = d.mmdRbs (t + i);
            }
          } else {  //4バイトずつ転送する。ウェイトサイクルを減らす
            int o = offset;
            int z = t + l;
            if ((t & 1) != 0 && t < z) {  //2n+1で残り1以上。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
              array[o++] = d.mmdRbs (t++);
            }
            if ((t & 2) != 0 && t + 1 < z) {  //4n+2で残り2以上。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
              int x = d.mmdRws (t);
              array[o    ] = (byte) (x >> 8);
              array[o + 1] = (byte)  x;
              t += 2;
              o += 2;
            }
            if (t + 3 < z) {  //4nで残り4以上。4バイトずつ転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
              do {
                int x = d.mmdRls (t);
                array[o    ] = (byte) (x >> 24);
                array[o + 1] = (byte) (x >> 16);
                array[o + 2] = (byte) (x >>  8);
                array[o + 3] = (byte)  x;
                t += 4;
                o += 4;
              } while (t + 3 < z);
            }
            if (t + 1 < z) {  //4nで残り2または3。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
              int x = d.mmdRws (t);
              array[o    ] = (byte) (x >> 8);
              array[o + 1] = (byte)  x;
              t += 2;
              o += 2;
            }
            if (t < z) {  //4nで残り1。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
              array[o++] = d.mmdRbs (t++);
            }
          }  //if 1バイトずつ/4バイトずつ
          address += l;
          offset += l;
          length -= l;
        }  //while 0<length
      }  //if スーパーバイザモード/ユーザモード
    }  //if 1バイトずつ/1ページずつ
  }  //mmuReadByteArray(int,byte[],int,int,int)

  //--------------------------------------------------------------------------------
  //リードモディファイライトのリード
  //  アドレス変換はライト
  //  FSLWのRead and WriteはRead-Modify-Write

  //d = mmuModifyByteSignData (a, supervisor)
  //  リードモディファイライトのリードバイト符号拡張(データ)
  public static byte mmuModifyByteSignData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateWriteSuperData (a);
      return (a ^ a0) == 1 ? -1 : (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateWriteUserData (a);
      return (a ^ a0) == 1 ? -1 : (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
    }
  }  //mmuModifyByteSignData(int,int)

  //d = mmuModifyByteZeroData (a, supervisor)
  //  リードモディファイライトのリードバイトゼロ拡張(データ)
  public static int mmuModifyByteZeroData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateWriteSuperData (a);
      return (a ^ a0) == 1 ? 255 : (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateWriteUserData (a);
      return (a ^ a0) == 1 ? 255 : (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
    }
  }  //mmuModifyByteZeroData(int,int)

  //d = mmuModifyWordSignData (a, supervisor)
  //  リードモディファイライトのリードワード符号拡張(データ)
  public static int mmuModifyWordSignData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateWriteSuperData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateWriteSuperData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateWriteUserData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateWriteUserData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    }
  }  //mmuModifyWordSignData(int,int)

  //d = mmuModifyWordZeroData (a, supervisor)
  //  リードモディファイライトのリードワードゼロ拡張(データ)
  public static int mmuModifyWordZeroData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateWriteSuperData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateWriteSuperData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateWriteUserData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a0);
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateWriteUserData (a + 1);  //偶数
        return (d0 << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a1));
      }
    }
  }  //mmuModifyWordZeroData(int,int)

  //d = mmuModifyWordSignEven (a, supervisor)
  //  リードモディファイライトのリードワード符号拡張(偶数)
  public static int mmuModifyWordSignEven (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateWriteSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateWriteUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRws (a);
    }
  }  //mmuModifyWordSignEven(int,int)

  //d = mmuModifyWordZeroEven (a, supervisor)
  //  リードモディファイライトのリードワードゼロ拡張(偶数)
  public static int mmuModifyWordZeroEven (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateWriteSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateWriteUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a);
    }
  }  //mmuModifyWordZeroEven(int,int)

  //d = mmuModifyLongData (a, supervisor)
  //  リードモディファイライトのリードロング(データ)
  public static int mmuModifyLongData (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateWriteSuperData (a);  //a+1,a+2,a+3が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateWriteSuperData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateWriteSuperData (a + 1);  //偶数
        int a3 = mmuTranslateWriteSuperData (a + 3);  //偶数
        return (d0 << 24 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a3));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateWriteUserData (a);  //a+1,a+2,a+3が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else if ((a & 1) == 0) {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateWriteUserData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      } else {  //奇数
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRbs (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a1 = mmuTranslateWriteUserData (a + 1);  //偶数
        int a3 = mmuTranslateWriteUserData (a + 3);  //偶数
        return (d0 << 24 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a1 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a1) << 8 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a3 >>> XEiJ.BUS_PAGE_BITS].mmdRbz (a3));
      }
    }
  }  //mmuModifyLongData(int,int)

  //d = mmuModifyLongEven (a, supervisor)
  //  リードモディファイライトのリードロング(偶数)
  public static int mmuModifyLongEven (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int a0 = mmuTranslateWriteSuperData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateWriteSuperData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      int a0 = mmuTranslateWriteUserData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRls (a0);
      } else {  //4の倍数+2
        int d0 = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a0 >>> XEiJ.BUS_PAGE_BITS].mmdRws (a0);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        int a2 = mmuTranslateWriteUserData (a + 2);  //偶数
        return (d0 << 16 |
                (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a2 >>> XEiJ.BUS_PAGE_BITS].mmdRwz (a2));
      }
    }
  }  //mmuModifyLongEven(int,int)

  //d = mmuModifyLongFour (a, supervisor)
  //  リードモディファイライトのリードロング(4の倍数)
  public static int mmuModifyLongFour (int a, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateWriteSuperData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRls (a);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_MODIFY | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateWriteUserData (a);
      return (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdRls (a);
    }
  }  //mmuModifyLongFour(int,int)

  //--------------------------------------------------------------------------------
  //ポーク
  //  デバッガ用
  //  エラーや副作用なしでライトする

  //mmuPokeByte (a, x, f)
  //  ポークバイト
  public static void mmuPokeByte (int a, int x, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //DFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      if ((a ^ a0) != 1) {
        mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a0, x);
      }
    } else if (f != 7) {  //DFC=0,3,4。アドレス変換なし
      mm[a >>> XEiJ.BUS_PAGE_BITS].mmdVb (a, x);
    }
  }  //mmuPokeByte(int,int,int)

  //mmuPokeByteData (a, d, supervisor)
  //  ポークバイト(データ)
  public static void mmuPokeByteData (int a, int d, int supervisor) {
    MemoryMappedDevice[] mm = supervisor != 0 ? DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap : DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
    int a0 = mmuTranslatePeek (a, supervisor, 0);
    if ((a ^ a0) != 1) {
      //mm[a >>> XEiJ.BUS_PAGE_BITS].mmdVb (a0, d);
      XEiJ.busVb (a0, d);
    }
  }  //mmuPokeByteData(int,int,int)

  //mmuPokeWord (a, x, f)
  //  ポークワード
  public static void mmuPokeWord (int a, int x, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //DFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      if ((a & 1) == 0) {  //偶数
        if ((a ^ a0) != 1) {
          mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdVw (a0, x);
        }
      } else {  //奇数
        int a1 = mmuTranslatePeek (a + 1, f & 4, f & 2);
        if ((a     ^ a0) != 1) {
          mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a0, x >> 8);
        }
        if ((a + 1 ^ a1) != 1) {
          mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a1, x     );
        }
      }
    } else if (f != 7) {  //DFC=0,3,4。アドレス変換なし
      if ((a & 1) == 0) {  //偶数
        mm[a >>> XEiJ.BUS_PAGE_BITS].mmdVw (a, x);
      } else {  //奇数
        mm[a     >>> XEiJ.BUS_PAGE_BITS].mmdVb (a    , x >> 8);
        mm[a + 1 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a + 1, x     );
      }
    }
  }  //mmuPokeWord(int,int,int)

  //mmuPokeWordData (a, d, supervisor)
  //  ポークワード(データ)
  public static void mmuPokeWordData (int a, int d, int supervisor) {
    mmuPokeByteData (a, d >> 8, supervisor);
    mmuPokeByteData (a + 1, d, supervisor);
  }  //mmuPokeWordData(int,int,int)

  //mmuPokeLong (a, x, f)
  //  ポークロング
  public static void mmuPokeLong (int a, int x, int f) {
    f = f == -1 ? XEiJ.regSRS != 0 ? 5 : 1 : f & 7;
    MemoryMappedDevice[] mm = (DataBreakPoint.DBP_ON ?
                               (f & 4) != 0 ? DataBreakPoint.dbpSuperMap : DataBreakPoint.dbpUserMap :
                               (f & 4) != 0 ? XEiJ.busSuperMap : XEiJ.busUserMap);
    //    01234567
    if (0b01100110 << 24 << f < 0) {  //DFC=1,2,5,6。アドレス変換あり
      int a0 = mmuTranslatePeek (a, f & 4, f & 2);
      if ((a & 3) == 0) {  //4の倍数
        if ((a ^ a0) != 1) {
          mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdVl (a0, x);
        }
      } else if ((a & 1) == 0) {  //4の倍数ではない偶数
        int a2 = mmuTranslatePeek (a + 2, f & 4, f & 2);
        if ((a     ^ a0) != 1) {
          mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdVw (a0, x >> 16);
        }
        if ((a + 2 ^ a2) != 1) {
          mm[a2 >>> XEiJ.BUS_PAGE_BITS].mmdVw (a2, x);
        }
      } else {  //奇数
        int a1 = mmuTranslatePeek (a + 1, f & 4, f & 2);
        int a3 = mmuTranslatePeek (a + 3, f & 4, f & 2);
        if ((a     ^ a0) != 1) {
          mm[a0 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a0, x >> 24);
        }
        if ((a + 1 ^ a1) != 1) {
          mm[a1 >>> XEiJ.BUS_PAGE_BITS].mmdVw (a1, x >>  8);
        }
        if ((a + 3 ^ a3) != 1) {
          mm[a3 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a3, x);
        }
      }
    } else if (f != 7) {  //DFC=0,3,4。アドレス変換なし
      if ((a & 3) == 0) {  //4の倍数
        mm[a >>> XEiJ.BUS_PAGE_BITS].mmdVl (a, x);
      } else if ((a & 1) == 0) {  //4の倍数ではない偶数
        mm[a     >>> XEiJ.BUS_PAGE_BITS].mmdVw (a    , x >> 16);
        mm[a + 2 >>> XEiJ.BUS_PAGE_BITS].mmdVw (a + 2, x      );
      } else {  //奇数
        mm[a     >>> XEiJ.BUS_PAGE_BITS].mmdVb (a,     x >> 24);
        mm[a + 1 >>> XEiJ.BUS_PAGE_BITS].mmdVw (a + 1, x >>  8);
        mm[a + 3 >>> XEiJ.BUS_PAGE_BITS].mmdVb (a + 3, x      );
      }
    }
  }  //mmuPokeLong(int,int,int)

  //mmuPokeLongData (a, d, supervisor)
  //  ポークロング(データ)
  public static void mmuPokeLongData (int a, int d, int supervisor) {
    mmuPokeByteData (a, d >> 24, supervisor);
    mmuPokeByteData (a + 1, d >> 16, supervisor);
    mmuPokeByteData (a + 2, d >> 8, supervisor);
    mmuPokeByteData (a + 3, d, supervisor);
  }  //mmuPokeLongData(int,int,int)

  //mmuPokeQuad (a, x, f)
  //  ポーククワッド
  public static void mmuPokeQuad (int a, long x, int f) {
    mmuPokeLong (a    , (int) (x >> 32), f);
    mmuPokeLong (a + 4, (int)  x       , f);
  }  //mmuPokeQuad(int,long,int)

  //mmuPokeExtended (a, b, f)
  public static void mmuPokeExtended (int a, byte[] b, int f) {
    for (int i = 0; i < 12; i++) {
      mmuPokeByte (a + i, b[i], f);
    }
  }  //mmuPokeQuad(int,long,int)

  //a = mmuPokeStringZ (a, str, f)
  //  ポークストリング
  //  文字列をUTF-16からSJISに変換しながらメモリに書き込む
  //  文字列に'\0'が含まれるときはその手前まで書き込む
  //  SJISに変換できない文字は'※'になる
  //  最後に'\0'を書き込む
  //  '\0'を含まない書き込んだ文字列を返す
  public static String mmuPokeStringZ (int a, String str, int f) {
    StringBuilder sb = new StringBuilder ();
    int l = str.length ();
    for (int i = 0; i < l; i++) {
      int u = str.charAt (i);
      if (u == '\0') {
        break;
      }
      int s = CharacterCode.chrCharToSJIS[u];  //SJISに変換する
      if (s == 0) {  //変換できない
        s = 0x81a6;  //'※'
      }
      if (s >> 8 != 0) {
        mmuPokeByte (a++, s >> 8, f);
      }
      mmuPokeByte (a++, s, f);
      u = CharacterCode.chrSJISToChar[s];  //UTF-16に変換する
      if (u == 0) {  //変換できない
        u = 0xfffd;
      }
      sb.append ((char) u);
    }
    mmuPokeByte (a, 0, f);  //'\0'
    return sb.toString ();
  }  //mmuPokeStringZ(int,String,int)

  //--------------------------------------------------------------------------------
  //ライト
  //  アドレス変換はライト
  //  FSLWのRead and WriteはWrite

  //mmuWriteByteData (a, d, supervisor)
  //  ライトバイト符号拡張(データ)
  public static void mmuWriteByteData (int a, int d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int t = mmuTranslateWriteSuperData (a);
      (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
      int t = mmuTranslateWriteUserData (a);
      (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d);
    }
  }  //mmuWriteByteData(int,int,int)

  //mmuWriteWordData (a, d, supervisor)
  //  ライトワード符号拡張(データ)
  public static void mmuWriteWordData (int a, int d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int t = mmuTranslateWriteSuperData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d);
      } else {  //奇数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d >> 8);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 1);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d);
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      int t = mmuTranslateWriteUserData (a);  //a+1が必要なので上書き不可
      if ((a & 1) == 0) {  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d);
      } else {  //奇数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d >> 8);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 1);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d);
      }
    }
  }  //mmuWriteWordData(int,int,int)

  //mmuWriteWordEven (a, d, supervisor)
  //  ライトワード符号拡張(偶数)
  public static void mmuWriteWordEven (int a, int d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateWriteSuperData (a);
      (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdWw (a, d);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateWriteUserData (a);
      (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdWw (a, d);
    }
  }  //mmuWriteWordEven(int,int,int)

  //mmuWriteLongData (a, d, supervisor)
  //  ライトロング(データ)
  public static void mmuWriteLongData (int a, int d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int t = mmuTranslateWriteSuperData (a);  //a+1,a+2,a+3が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, d);
      } else if ((a & 1) == 0) {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d >> 16);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 2);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d);
      } else {  //奇数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d >> 24);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 1);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d >> 8);
        t = mmuTranslateWriteSuperData (a + 3);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d);
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      int t = mmuTranslateWriteUserData (a);  //a+1,a+2,a+3が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, d);
      } else if ((a & 1) == 0) {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d >> 16);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 2);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d);
      } else {  //奇数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d >> 24);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 1);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d >> 8);
        t = mmuTranslateWriteUserData (a + 3);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, d);
      }
    }
  }  //mmuWriteLongData(int,int,int)

  //mmuWriteLongEven (a, d, supervisor)
  //  ライトロング(偶数)
  public static void mmuWriteLongEven (int a, int d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int t = mmuTranslateWriteSuperData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, d);
      } else {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d >> 16);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 2);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d);
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      int t = mmuTranslateWriteUserData (a);  //a+2が必要なので上書き不可
      if ((a & 2) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, d);
      } else {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d >> 16);
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 2);  //偶数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, d);
      }
    }
  }  //mmuWriteLongEven(int,int,int)

  //mmuWriteLongFour (a, d, supervisor)
  //  ライトロング(4の倍数)
  public static void mmuWriteLongFour (int a, int d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
      a = mmuTranslateWriteSuperData (a);
      (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdWl (a, d);
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
      a = mmuTranslateWriteUserData (a);
      (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[a >>> XEiJ.BUS_PAGE_BITS].mmdWl (a, d);
    }
  }  //mmuWriteLongFour(int,int,int)

  //mmuWriteQuadData (a, d, supervisor)
  //  ライトクワッド(データ)
  public static void mmuWriteQuadData (int a, long d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int t = mmuTranslateWriteSuperData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 32));
        t = mmuTranslateWriteSuperData (a + 4);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) d);
      } else if ((a & 1) == 0) {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 48));
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 2);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 16));
        t = mmuTranslateWriteSuperData (a + 6);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) d);
      } else if ((a & 3) == 1) {  //4の倍数+1
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 1);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 40));
        t = mmuTranslateWriteSuperData (a + 3);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 8));
        t = mmuTranslateWriteSuperData (a + 7);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      } else {  //  //4の倍数+3
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteSuperData (a + 1);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 24));
        t = mmuTranslateWriteSuperData (a + 5);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 8));
        t = mmuTranslateWriteSuperData (a + 7);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_USER_DATA;
      int t = mmuTranslateWriteUserData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 32));
        t = mmuTranslateWriteUserData (a + 4);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) d);
      } else if ((a & 1) == 0) {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 48));
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 2);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 16));
        t = mmuTranslateWriteUserData (a + 6);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) d);
      } else if ((a & 3) == 1) {  //4の倍数+1
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 1);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 40));
        t = mmuTranslateWriteUserData (a + 3);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 8));
        t = mmuTranslateWriteUserData (a + 7);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      } else {  //  //4の倍数+3
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_IOMA_FIRST ^ M68kException.M6E_FSLW_IOMA_SECOND;
        t = mmuTranslateWriteUserData (a + 1);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 24));
        t = mmuTranslateWriteUserData (a + 5);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 8));
        t = mmuTranslateWriteUserData (a + 7);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      }
    }
  }  //mmuWriteQuadData(int,long,int)

  //mmuWriteQuadSecond (a, d, supervisor)
  //  ライトクワッド(2番目)
  //  エクステンデッドとラインの2番目で使う
  public static void mmuWriteQuadSecond (int a, long d, int supervisor) throws M68kException {
    if (supervisor != 0) {  //スーパーバイザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_SECOND | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_SUPER_DATA;
      int t = mmuTranslateWriteSuperData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 32));
        t = mmuTranslateWriteSuperData (a + 4);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) d);
      } else if ((a & 1) == 0) {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 48));
        t = mmuTranslateWriteSuperData (a + 2);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 16));
        t = mmuTranslateWriteSuperData (a + 6);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) d);
      } else if ((a & 3) == 1) {  //4の倍数+1
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        t = mmuTranslateWriteSuperData (a + 1);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 40));
        t = mmuTranslateWriteSuperData (a + 3);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 8));
        t = mmuTranslateWriteSuperData (a + 7);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      } else {  //  //4の倍数+3
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        t = mmuTranslateWriteSuperData (a + 1);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 24));
        t = mmuTranslateWriteSuperData (a + 5);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 8));
        t = mmuTranslateWriteSuperData (a + 7);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      }
    } else {  //ユーザモード
      M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_SECOND | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_QUAD | M68kException.M6E_FSLW_TM_USER_DATA;
      int t = mmuTranslateWriteUserData (a);  //a+1,a+2,a+3,a+4,a+5,a+6,a+7が必要なので上書き不可
      if ((a & 3) == 0) {  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 32));
        t = mmuTranslateWriteUserData (a + 4);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) d);
      } else if ((a & 1) == 0) {  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 48));
        t = mmuTranslateWriteUserData (a + 2);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 16));
        t = mmuTranslateWriteUserData (a + 6);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) d);
      } else if ((a & 3) == 1) {  //4の倍数+1
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        t = mmuTranslateWriteUserData (a + 1);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 40));
        t = mmuTranslateWriteUserData (a + 3);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 8));
        t = mmuTranslateWriteUserData (a + 7);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      } else {  //  //4の倍数+3
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) (d >> 56));
        t = mmuTranslateWriteUserData (a + 1);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWl (t, (int) (d >> 24));
        t = mmuTranslateWriteUserData (a + 5);  //4の倍数
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWw (t, (int) (d >> 8));
        t = mmuTranslateWriteUserData (a + 7);  //4の倍数+2
        (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap)[t >>> XEiJ.BUS_PAGE_BITS].mmdWb (t, (int) d);
      }
    }
  }  //mmuWriteQuadSecond(int,int,int)

  //mmuWriteByteArray (address, array, offset, length, supervisor)
  //  ライトバイト配列
  public static void mmuWriteByteArray (int address, byte[] array, int offset, int length, int supervisor) throws M68kException {
    if (false) {  //1バイトずつアドレス変換する
      for (int index = 0; index < length; index++) {
        mmuWriteByteData (address + index, array[offset + index], supervisor);
      }
    } else {  //1ページずつアドレス変換する
      int pageSize = Math.min (XEiJ.BUS_PAGE_SIZE, mmuPageSize);
      if (supervisor != 0) {  //スーパーバイザモード
        if (false) {  //1バイトずつ転送する
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
        }
        MemoryMappedDevice[] mm = DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap;
        while (0 < length) {
          int l = Math.min (pageSize - (address & (pageSize - 1)), length);  //今回転送する長さ
          int t = mmuTranslateWriteSuperData (address);
          MemoryMappedDevice d = mm[t >>> XEiJ.BUS_PAGE_BITS];
          if (false) {  //1バイトずつ転送する
            for (int i = 0; i < l; i++) {
              d.mmdWb (t + i, array[offset + i]);
            }
          } else {  //4バイトずつ転送する。ウェイトサイクルを減らす
            int o = offset;
            int z = t + l;
            if ((t & 1) != 0 && t < z) {  //2n+1で残り1以上。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
              d.mmdWb (t++, array[o++]);
            }
            if ((t & 2) != 0 && t + 1 < z) {  //4n+2で残り2以上。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
              d.mmdWw (t,
                       (array[o    ]      ) <<  8 |
                       (array[o + 1] & 255));
              t += 2;
              o += 2;
            }
            if (t + 3 < z) {  //4nで残り4以上。4バイトずつ転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_SUPER_DATA;
              do {
                d.mmdWl (t,
                         (array[o    ]      ) << 24 |
                         (array[o + 1] & 255) << 16 |
                         (array[o + 2] & 255) <<  8 |
                         (array[o + 3] & 255));
                t += 4;
                o += 4;
              } while (t + 3 < z);
            }
            if (t + 1 < z) {  //4nで残り2または3。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_SUPER_DATA;
              d.mmdWw (t,
                       (array[o    ]      ) <<  8 |
                       (array[o + 1] & 255));
              t += 2;
              o += 2;
            }
            if (t < z) {  //4nで残り1。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_SUPER_DATA;
              d.mmdWb (t++, array[o++]);
            }
          }  //if 1バイトずつ/4バイトずつ
          address += l;
          offset += l;
          length -= l;
        }  //while 0<length
      } else {  //ユーザモード
        if (false) {  //1バイトずつ転送する
          M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
        }
        MemoryMappedDevice[] mm = DataBreakPoint.DBP_ON ? DataBreakPoint.dbpUserMap : XEiJ.busUserMap;
        while (0 < length) {
          int l = Math.min (pageSize - (address & (pageSize - 1)), length);  //今回転送する長さ
          int t = mmuTranslateWriteUserData (address);
          MemoryMappedDevice d = mm[t >>> XEiJ.BUS_PAGE_BITS];
          if (false) {  //1バイトずつ転送する
            for (int i = 0; i < l; i++) {
              d.mmdWb (t + i, array[offset + i]);
            }
          } else {  //4バイトずつ転送する。ウェイトサイクルを減らす
            int o = offset;
            int z = t + l;
            if ((t & 1) != 0 && t < z) {  //2n+1で残り1以上。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
              d.mmdWb (t++, array[o++]);
            }
            if ((t & 2) != 0 && t + 1 < z) {  //4n+2で残り2以上。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
              d.mmdWw (t,
                       (array[o    ]      ) <<  8 |
                       (array[o + 1] & 255));
              t += 2;
              o += 2;
            }
            if (t + 3 < z) {  //4nで残り4以上。4バイトずつ転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_LONG | M68kException.M6E_FSLW_TM_USER_DATA;
              do {
                d.mmdWl (t,
                         (array[o    ]      ) << 24 |
                         (array[o + 1] & 255) << 16 |
                         (array[o + 2] & 255) <<  8 |
                         (array[o + 3] & 255));
                t += 4;
                o += 4;
              } while (t + 3 < z);
            }
            if (t + 1 < z) {  //4nで残り2または3。2バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_WORD | M68kException.M6E_FSLW_TM_USER_DATA;
              d.mmdWw (t,
                       (array[o    ]      ) <<  8 |
                       (array[o + 1] & 255));
              t += 2;
              o += 2;
            }
            if (t < z) {  //4nで残り1。1バイト転送する
              M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | M68kException.M6E_FSLW_TM_USER_DATA;
              d.mmdWb (t++, array[o++]);
            }
          }  //if 1バイトずつ/4バイトずつ
          address += l;
          offset += l;
          length -= l;
        }  //while 0<length
      }  //if スーパーバイザモード/ユーザモード
    }  //if 1バイトずつ/1ページずつ
  }  //mmuWriteByteArray(int,byte[],int,int,int)

  //--------------------------------------------------------------------------------
  //アドレス変換

  //pa = mmuLoadPhysicalAddressRead (a)
  //  PLPAR (An)
  //  DFCに従って論理アドレスを物理アドレスに変換する(リードアクセス)
  //    DFC  1=ユーザデータ,2=ユーザ命令,5=スーパーバイザデータ,6=スーパーバイザ命令
  //    pa   物理アドレス
  //    a    論理アドレス
  public static int mmuLoadPhysicalAddressRead (int a) throws M68kException {
    M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_READ | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuDFC << 16;
    return ((0b10011111 << 24 << XEiJ.mpuDFC) < 0 ?
            (0b00101010 << 24 << XEiJ.mpuDFC) < 0 ? mmuTranslateReadSuperCode (a) : mmuTranslateReadSuperData (a) :
            (0b00101010 << 24 << XEiJ.mpuDFC) < 0 ? mmuTranslateReadUserCode (a) : mmuTranslateReadUserData (a));
  }  //mmuLoadPhysicalAddressRead(int)

  //pa = mmuLoadPhysicalAddressWrite (a)
  //  PLPAW (An)
  //  DFCに従って論理アドレスを物理アドレスに変換する(ライトアクセス)
  //    DFC  1=ユーザデータ,2=ユーザ命令,5=スーパーバイザデータ,6=スーパーバイザ命令
  //    pa   物理アドレス
  //    a    論理アドレス
  public static int mmuLoadPhysicalAddressWrite (int a) throws M68kException {
    M68kException.m6eFSLW = M68kException.M6E_FSLW_IOMA_FIRST | M68kException.M6E_FSLW_RW_WRITE | M68kException.M6E_FSLW_SIZE_BYTE | XEiJ.mpuDFC << 16;
    return ((0b10011111 << 24 << XEiJ.mpuDFC) < 0 ?
            (0b00101010 << 24 << XEiJ.mpuDFC) < 0 ? mmuTranslateWriteSuperCode (a) : mmuTranslateWriteSuperData (a) :
            (0b00101010 << 24 << XEiJ.mpuDFC) < 0 ? mmuTranslateWriteUserCode (a) : mmuTranslateWriteUserData (a));
  }  //mmuLoadPhysicalAddressWrite(int)

  //pa = mmuTranslateReadUserData (a)
  //  アドレス変換を行う(リードユーザデータ)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateReadUserData (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuUserDataCache[head] == logicalPage) {  //リード用の論理ページアドレスと一致した
      return mmuUserDataCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuUserDataCache[i] == logicalPage) {  //リード用の論理ページアドレスと一致した
          //int logicalRead  = mmuUserDataCache[i    ];
          int logicalWrite = mmuUserDataCache[i + 1];
          int physicalPage = mmuUserDataCache[i + 2];
          int globalFlag   = mmuUserDataCache[i + 3];
          for (; i > head; i -= 4) {
            mmuUserDataCache[i    ] = mmuUserDataCache[i - 4];
            mmuUserDataCache[i + 1] = mmuUserDataCache[i - 3];
            mmuUserDataCache[i + 2] = mmuUserDataCache[i - 2];
            mmuUserDataCache[i + 3] = mmuUserDataCache[i - 1];
          }
          mmuUserDataCache[i    ] = logicalPage;  //logicalRead
          mmuUserDataCache[i + 1] = logicalWrite;
          mmuUserDataCache[i + 2] = physicalPage;
          mmuUserDataCache[i + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, false, false, false);
  }  //mmuTranslateReadUserData(int)

  //pa = mmuTranslateReadUserCode (a)
  //  アドレス変換を行う(リードユーザコード)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateReadUserCode (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuUserCodeCache[head] == logicalPage) {  //リード用の論理ページアドレスと一致した
      return mmuUserCodeCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuUserCodeCache[i] == logicalPage) {  //リード用の論理ページアドレスと一致した
          //int logicalRead  = mmuUserCodeCache[i    ];
          int logicalWrite = mmuUserCodeCache[i + 1];
          int physicalPage = mmuUserCodeCache[i + 2];
          int globalFlag   = mmuUserCodeCache[i + 3];
          for (; i > head; i -= 4) {
            mmuUserCodeCache[i    ] = mmuUserCodeCache[i - 4];
            mmuUserCodeCache[i + 1] = mmuUserCodeCache[i - 3];
            mmuUserCodeCache[i + 2] = mmuUserCodeCache[i - 2];
            mmuUserCodeCache[i + 3] = mmuUserCodeCache[i - 1];
          }
          mmuUserCodeCache[head    ] = logicalPage;  //logicalRead
          mmuUserCodeCache[head + 1] = logicalWrite;
          mmuUserCodeCache[head + 2] = physicalPage;
          mmuUserCodeCache[head + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, false, false, true);
  }  //mmuTranslateReadUserCode(int)

  //pa = mmuTranslateReadSuperData (a)
  //  アドレス変換を行う(リードスーパーバイザデータ)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateReadSuperData (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuSuperDataCache[head] == logicalPage) {  //リード用の論理ページアドレスと一致した
      return mmuSuperDataCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuSuperDataCache[i] == logicalPage) {  //リード用の論理ページアドレスと一致した
          //int logicalRead  = mmuSuperDataCache[i    ];
          int logicalWrite = mmuSuperDataCache[i + 1];
          int physicalPage = mmuSuperDataCache[i + 2];
          int globalFlag   = mmuSuperDataCache[i + 3];
          for (; i > head; i -= 4) {
            mmuSuperDataCache[i    ] = mmuSuperDataCache[i - 4];
            mmuSuperDataCache[i + 1] = mmuSuperDataCache[i - 3];
            mmuSuperDataCache[i + 2] = mmuSuperDataCache[i - 2];
            mmuSuperDataCache[i + 3] = mmuSuperDataCache[i - 1];
          }
          mmuSuperDataCache[i    ] = logicalPage;  //logicalRead
          mmuSuperDataCache[i + 1] = logicalWrite;
          mmuSuperDataCache[i + 2] = physicalPage;
          mmuSuperDataCache[i + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, false, true, false);
  }  //mmuTranslateReadSuperData(int)

  //pa = mmuTranslateReadSuperCode (a)
  //  アドレス変換を行う(リードスーパーバイザコード)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateReadSuperCode (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuSuperCodeCache[head] == logicalPage) {  //リード用の論理ページアドレスと一致した
      return mmuSuperCodeCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuSuperCodeCache[i] == logicalPage) {  //リード用の論理ページアドレスと一致した
          //int logicalRead  = mmuSuperCodeCache[i    ];
          int logicalWrite = mmuSuperCodeCache[i + 1];
          int physicalPage = mmuSuperCodeCache[i + 2];
          int globalFlag   = mmuSuperCodeCache[i + 3];
          for (; i > head; i -= 4) {
            mmuSuperCodeCache[i    ] = mmuSuperCodeCache[i - 4];
            mmuSuperCodeCache[i + 1] = mmuSuperCodeCache[i - 3];
            mmuSuperCodeCache[i + 2] = mmuSuperCodeCache[i - 2];
            mmuSuperCodeCache[i + 3] = mmuSuperCodeCache[i - 1];
          }
          mmuSuperCodeCache[head    ] = logicalPage;  //logicalRead
          mmuSuperCodeCache[head + 1] = logicalWrite;
          mmuSuperCodeCache[head + 2] = physicalPage;
          mmuSuperCodeCache[head + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, false, true, true);
  }  //mmuTranslateReadSuperCode(int)

  //pa = mmuTranslateWriteUserData (a)
  //  アドレス変換を行う(ライトユーザデータ)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateWriteUserData (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuUserDataCache[head + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
      return mmuUserDataCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuUserDataCache[i + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
          int logicalRead  = mmuUserDataCache[i    ];
          //int logicalWrite = mmuUserDataCache[i + 1];
          int physicalPage = mmuUserDataCache[i + 2];
          int globalFlag   = mmuUserDataCache[i + 3];
          for (; i > head; i -= 4) {
            mmuUserDataCache[i    ] = mmuUserDataCache[i - 4];
            mmuUserDataCache[i + 1] = mmuUserDataCache[i - 3];
            mmuUserDataCache[i + 2] = mmuUserDataCache[i - 2];
            mmuUserDataCache[i + 3] = mmuUserDataCache[i - 1];
          }
          mmuUserDataCache[i    ] = logicalRead;
          mmuUserDataCache[i + 1] = logicalPage;  //logicalWrite
          mmuUserDataCache[i + 2] = physicalPage;
          mmuUserDataCache[i + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, true, false, false);
  }  //mmuTranslateWriteUserData(int)

  //pa = mmuTranslateWriteUserCode (a)
  //  アドレス変換を行う(ライトユーザコード)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateWriteUserCode (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuUserCodeCache[head + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
      return mmuUserCodeCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuUserCodeCache[i + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
          int logicalRead  = mmuUserCodeCache[i    ];
          //int logicalWrite = mmuUserCodeCache[i + 1];
          int physicalPage = mmuUserCodeCache[i + 2];
          int globalFlag   = mmuUserCodeCache[i + 3];
          for (; i > head; i -= 4) {
            mmuUserCodeCache[i    ] = mmuUserCodeCache[i - 4];
            mmuUserCodeCache[i + 1] = mmuUserCodeCache[i - 3];
            mmuUserCodeCache[i + 2] = mmuUserCodeCache[i - 2];
            mmuUserCodeCache[i + 3] = mmuUserCodeCache[i - 1];
          }
          mmuUserCodeCache[head    ] = logicalRead;
          mmuUserCodeCache[head + 1] = logicalPage;  //logicalWrite
          mmuUserCodeCache[head + 2] = physicalPage;
          mmuUserCodeCache[head + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, true, false, true);
  }  //mmuTranslateWriteUserCode(int)

  //pa = mmuTranslateWriteSuperData (a)
  //  アドレス変換を行う(ライトスーパーバイザデータ)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateWriteSuperData (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuSuperDataCache[head + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
      return mmuSuperDataCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuSuperDataCache[i + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
          int logicalRead  = mmuSuperDataCache[i    ];
          //int logicalWrite = mmuSuperDataCache[i + 1];
          int physicalPage = mmuSuperDataCache[i + 2];
          int globalFlag   = mmuSuperDataCache[i + 3];
          for (; i > head; i -= 4) {
            mmuSuperDataCache[i    ] = mmuSuperDataCache[i - 4];
            mmuSuperDataCache[i + 1] = mmuSuperDataCache[i - 3];
            mmuSuperDataCache[i + 2] = mmuSuperDataCache[i - 2];
            mmuSuperDataCache[i + 3] = mmuSuperDataCache[i - 1];
          }
          mmuSuperDataCache[i    ] = logicalRead;
          mmuSuperDataCache[i + 1] = logicalPage;  //logicalWrite
          mmuSuperDataCache[i + 2] = physicalPage;
          mmuSuperDataCache[i + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, true, true, false);
  }  //mmuTranslateWriteSuperData(int)

  //pa = mmuTranslateWriteSuperCode (a)
  //  アドレス変換を行う(ライトスーパーバイザコード)
  //    pa  物理アドレス
  //    a   論理アドレス
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateWriteSuperCode (int a) throws M68kException {
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
    if (mmuSuperCodeCache[head + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
      return mmuSuperCodeCache[head + 2] | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
    }
    if (MMU_CACHE_WAYS >= 2) {  //2ways以上
      int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ
      for (int i = head + 4; i <= tail; i += 4) {
        if (mmuSuperCodeCache[i + 1] == logicalPage) {  //ライト用の論理ページアドレスと一致した
          int logicalRead  = mmuSuperCodeCache[i    ];
          //int logicalWrite = mmuSuperCodeCache[i + 1];
          int physicalPage = mmuSuperCodeCache[i + 2];
          int globalFlag   = mmuSuperCodeCache[i + 3];
          for (; i > head; i -= 4) {
            mmuSuperCodeCache[i    ] = mmuSuperCodeCache[i - 4];
            mmuSuperCodeCache[i + 1] = mmuSuperCodeCache[i - 3];
            mmuSuperCodeCache[i + 2] = mmuSuperCodeCache[i - 2];
            mmuSuperCodeCache[i + 3] = mmuSuperCodeCache[i - 1];
          }
          mmuSuperCodeCache[head    ] = logicalRead;
          mmuSuperCodeCache[head + 1] = logicalPage;  //logicalWrite
          mmuSuperCodeCache[head + 2] = physicalPage;
          mmuSuperCodeCache[head + 3] = globalFlag;
          return physicalPage | (a & mmuPageOffsetMask);  //物理ページアドレスとページオフセットを連結する
        }
      }  //for i
    }
    return mmuTranslateCommon (a, true, true, true);
  }  //mmuTranslateWriteSuperCode(int)

  //pa = mmuTranslateCommon (a, write, supervisor, instruction)
  //  透過変換とテーブルサーチを行い、アドレス変換キャッシュ更新する
  //  アドレス変換キャッシュがミスしたときに呼び出す
  //    pa           物理アドレス
  //    a            論理アドレス
  //    write        true=ライト,false=リード
  //    supervisor   true=スーパーバイザ,false=ユーザ。通常はXEiJ.regSRS!=0、PLPAR/PLPAWでは(XEiJ.mpuDFC&4)!=0
  //    instruction  true=命令,false=データ。通常は命令フェッチまたは拡張ワードのときtrue、PLPAR/PLPAWでは(XEiJ.mpuDFC&2)!=0
  //  M68kException.m6eFSLWのMA,RW,SIZE,TM,IOをセットしてから呼び出すこと
  public static int mmuTranslateCommon (int a, boolean write, boolean supervisor, boolean instruction) throws M68kException {
    if (MMU_DEBUG_TRANSLATION) {
      System.out.printf ("%08x mmuTranslateCommon(0x%08x,%b,%b,%b)", XEiJ.regPC0, a, write, supervisor, instruction);
    }
    int logicalPage = a & mmuPageAddressMask;  //リード用の論理ページアドレス
    int logicalWrite;  //ライト用の論理ページアドレス
    int physicalPage;  //物理ページアドレス
    int globalFlag;  //グローバルフラグ。-1=Global,0=NonGlobal
    int pa;  //物理アドレス
    //透過変換
    //  透過変換はスーパーバイザモードかどうかを条件にすることができる(しないこともできる)
    //    条件が合わなければヒットしないだけで、スーパーバイザプロテクトのアクセスフォルトになならない
    //  透過変換をアドレス変換キャッシュに乗せる場合
    //    アドレス変換キャッシュがヒットしてバスエラーが発生したとき
    //      透過変換かどうかを再確認してFSLWのTTRをセットしなければならない
    //    透過変換レジスタが操作されたとき
    //      OFF→ONの領域だけでなくON→OFFの領域もフラッシュしなければならない
    //      透過変換レジスタを頻繁に操作されると重くなるかも知れない
    int tt = (supervisor ?
              instruction ? mmuSuperCodeTransparent : mmuSuperDataTransparent :
              instruction ? mmuUserCodeTransparent : mmuUserDataTransparent)[a >>> 24];
    if (tt != 0) {  //透過変換あり
      M68kException.m6eFSLW |= M68kException.M6E_FSLW_TRANSPARENT;
      if (write &&  //ライトで
          tt < 0) {  //透過変換によるライトプロテクト
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" write protected by transparent translation\n", a);
        }
        M68kException.m6eFSLW |= M68kException.M6E_FSLW_WRITE_PROTECT;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      logicalWrite = logicalPage;  //ライト用の論理ページアドレス
      physicalPage = logicalPage;  //物理ページアドレス
      globalFlag = -1;  //グローバルフラグ。-1=Global,0=NonGlobal
      pa = a;
      if (MMU_DEBUG_TRANSLATION) {
        System.out.printf ("=0x%08x (transparent translation)\n", pa);
      }
    } else if (mmuEnabled) {  //透過変換なし、アドレス変換あり
      //テーブルサーチ
      //  スーパーバイザプロテクトまたはライトプロテクトで停止したときディスクリプタの使用済みフラグはセットされない
      //  リードモディファイライトはライトでアロケートするのでリードする前にライトプロテクトに引っかかる
      //    例えばROMの内容をインクリメントしようとしたときライトだけでなくリードも行われない
      M68kException.m6eFSLW |= M68kException.M6E_FSLW_TABLE_SEARCH;
      //ルートテーブル
      int rootDescriptorAddress = (supervisor ? mmuSRP : mmuURP) + ((a & MMU_ROOT_INDEX_MASK) >>> MMU_ROOT_INDEX_BIT0 - 2);  //ルートテーブルディスクリプタのアドレス
      MemoryMappedDevice rootDescriptorDevice = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[rootDescriptorAddress >>> XEiJ.BUS_PAGE_BITS];
      int rootDescriptor = rootDescriptorDevice.mmdRls (rootDescriptorAddress);  //ルートテーブルディスクリプタ
      if ((rootDescriptor & MMU_DESCRIPTOR_UDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" invalid root descriptor 0x%08x at 0x%08x\n", rootDescriptor, rootDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_ROOT_DESCRIPTOR;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if (write &&  //ライトで
          (rootDescriptor & MMU_DESCRIPTOR_WRITE_PROTECTED) != 0) {  //ライトプロテクトされているとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" write protected by root descriptor 0x%08x at 0x%08x\n", rootDescriptor, rootDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_WRITE_PROTECT;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if ((rootDescriptor & MMU_DESCRIPTOR_USED) == 0) {  //ディスクリプタが未使用のとき
        rootDescriptor |= MMU_DESCRIPTOR_USED;  //使用済み
        rootDescriptorDevice.mmdWl (rootDescriptorAddress, rootDescriptor);
      }
      //ポインタテーブル
      int pointerDescriptorAddress = (rootDescriptor & MMU_DESCRIPTOR_POINTER_TABLE_ADDRESS) + ((a & MMU_POINTER_INDEX_MASK) >>> MMU_POINTER_INDEX_BIT0 - 2);  //ポインタテーブルディスクリプタのアドレス
      MemoryMappedDevice pointerDescriptorDevice = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[pointerDescriptorAddress >>> XEiJ.BUS_PAGE_BITS];
      int pointerDescriptor = pointerDescriptorDevice.mmdRls (pointerDescriptorAddress);  //ポインタテーブルディスクリプタ
      if ((pointerDescriptor & MMU_DESCRIPTOR_UDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" invalid pointer descriptor 0x%08x at 0x%08x\n", pointerDescriptor, pointerDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_POINTER_DESCRIPTOR;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if (write &&  //ライトで
          (pointerDescriptor & MMU_DESCRIPTOR_WRITE_PROTECTED) != 0) {  //ライトプロテクトされているとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" write protected by pointer descriptor 0x%08x at 0x%08x\n", pointerDescriptor, pointerDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_WRITE_PROTECT;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if ((pointerDescriptor & MMU_DESCRIPTOR_USED) == 0) {  //ディスクリプタが未使用のとき
        pointerDescriptor |= MMU_DESCRIPTOR_USED;  //使用済み
        pointerDescriptorDevice.mmdWl (pointerDescriptorAddress, pointerDescriptor);
      }
      //ページテーブル
      int pageDescriptorAddress = (pointerDescriptor & mmuPageTableMask) + ((a & mmuPageIndexMask) >>> mmuPageIndexBit2);  //ページテーブルディスクリプタのアドレス
      MemoryMappedDevice pageDescriptorDevice = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[pageDescriptorAddress >>> XEiJ.BUS_PAGE_BITS];
      int pageDescriptor = pageDescriptorDevice.mmdRls (pageDescriptorAddress);  //ページテーブルディスクリプタ
      if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" invalid page descriptor 0x%08x at 0x%08x\n", pageDescriptor, pageDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_PAGE_FAULT;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INDIRECT) {  //ディスクリプタが間接のとき
        pageDescriptorAddress = pageDescriptor & MMU_DESCRIPTOR_INDIRECT_ADDRESS;  //ページテーブルディスクリプタのアドレス
        pageDescriptorDevice = (DataBreakPoint.DBP_ON ? DataBreakPoint.dbpSuperMap : XEiJ.busSuperMap)[pageDescriptorAddress >>> XEiJ.BUS_PAGE_BITS];
        pageDescriptor = pageDescriptorDevice.mmdRls (pageDescriptorAddress);  //ページテーブルディスクリプタ
        if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
          if (MMU_DEBUG_TRANSLATION) {
            System.out.printf (" invalid page descriptor 0x%08x at 0x%08x\n", pageDescriptor, pageDescriptorAddress);
          }
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_PAGE_FAULT;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          throw M68kException.m6eSignal;
        }
        if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INDIRECT) {  //ディスクリプタが二重間接のとき
          if (MMU_DEBUG_TRANSLATION) {
            System.out.printf (" indirect page descriptor 0x%08x at 0x%08x\n", pageDescriptor, pageDescriptorAddress);
          }
          M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_INDIRECT_LEVEL;
          M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
          M68kException.m6eAddress = a;
          throw M68kException.m6eSignal;
        }
      }
      if (!supervisor &&  //ユーザモードで
          (pageDescriptor & MMU_DESCRIPTOR_SUPERVISOR_PROTECTED) != 0) {  //スーパーバイザプロテクトされているとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" supervisor protected by page descriptor 0x%08x at 0x%08x\n", pageDescriptor, pageDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_SUPERVISOR_PROTECT;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if (write &&  //ライトで
          (pageDescriptor & MMU_DESCRIPTOR_WRITE_PROTECTED) != 0) {  //ライトプロテクトされているとき
        if (MMU_DEBUG_TRANSLATION) {
          System.out.printf (" write protected by page descriptor 0x%08x at 0x%08x\n", pageDescriptor, pageDescriptorAddress);
        }
        M68kException.m6eFSLW ^= M68kException.M6E_FSLW_TABLE_SEARCH ^ M68kException.M6E_FSLW_WRITE_PROTECT;
        M68kException.m6eNumber = M68kException.M6E_ACCESS_FAULT;
        M68kException.m6eAddress = a;
        throw M68kException.m6eSignal;
      }
      if ((pageDescriptor & MMU_DESCRIPTOR_USED) == 0) {  //ディスクリプタが未使用のとき
        pageDescriptor |= MMU_DESCRIPTOR_USED;  //使用済みにする
        pageDescriptorDevice.mmdWl (pageDescriptorAddress, pageDescriptor);
      }
      if (write &&  //ライトで
          (pageDescriptor & MMU_DESCRIPTOR_MODIFIED) == 0) {  //修正済みでないとき
        pageDescriptor |= MMU_DESCRIPTOR_MODIFIED;  //修正済みにする
        pageDescriptorDevice.mmdWl (pageDescriptorAddress, pageDescriptor);
      }
      //テーブルサーチ終了
      M68kException.m6eFSLW &= ~M68kException.M6E_FSLW_TABLE_SEARCH;
      //logicalWrite = (pageDescriptor & (MMU_DESCRIPTOR_MODIFIED | MMU_DESCRIPTOR_WRITE_PROTECTED)) == MMU_DESCRIPTOR_MODIFIED ? logicalPage : 1;  //ライト用の論理ページアドレス。修正済みかつライトプロテクトされていないときだけ有効
      logicalWrite = (pageDescriptor & MMU_DESCRIPTOR_WRITE_PROTECTED) == 0 ? logicalPage : 1;  //ライト用の論理ページアドレス。ライトプロテクトされていないときだけ有効
      physicalPage = pageDescriptor & mmuPageAddressMask;  //物理ページアドレス
      globalFlag = (pageDescriptor & MMU_DESCRIPTOR_GLOBAL) != 0 ? -1 : 0;  //グローバルフラグ。-1=Global,0=NonGlobal
      pa = physicalPage | a & mmuPageOffsetMask;  //物理ページアドレスとページオフセットを連結する
      if (MMU_DEBUG_TRANSLATION) {
        System.out.printf ("=0x%08x (table search)\n", pa);
        System.out.printf ("  rootTable=0x%08x\n", supervisor ? mmuSRP : mmuURP);
        System.out.printf ("  rootIndex=0x%08x\n", (a & MMU_ROOT_INDEX_MASK) >>> MMU_ROOT_INDEX_BIT0);
        System.out.printf ("  rootDescriptorAddress=0x%08x\n", rootDescriptorAddress);
        System.out.printf ("  rootDescriptor=0x%08x\n", rootDescriptor);
        System.out.printf ("  pointerTable=0x%08x\n", rootDescriptor & MMU_DESCRIPTOR_POINTER_TABLE_ADDRESS);
        System.out.printf ("  pointerIndex=0x%08x\n", (a & MMU_POINTER_INDEX_MASK) >>> MMU_POINTER_INDEX_BIT0);
        System.out.printf ("  pointerDescriptorAddress=0x%08x\n", pointerDescriptorAddress);
        System.out.printf ("  pointerDescriptor=0x%08x\n", pointerDescriptor);
        System.out.printf ("  pageTable=0x%08x\n", pointerDescriptor & mmuPageTableMask);
        System.out.printf ("  pageIndex=0x%08x\n", (a & mmuPageIndexMask) >>> mmuPageIndexBit2 + 2);
        System.out.printf ("  pageDescriptorAddress=0x%08x\n", pageDescriptorAddress);
        System.out.printf ("  pageDescriptor=0x%08x\n", pageDescriptor);
      }
    } else {  //透過変換なし、アドレス変換なし
      logicalWrite = logicalPage;  //ライト用の論理ページアドレス
      physicalPage = logicalPage;  //物理ページアドレス
      globalFlag = -1;  //グローバルフラグ。-1=Global,0=NonGlobal
      pa = a;
      if (MMU_DEBUG_TRANSLATION) {
        System.out.printf ("=0x%08x (no translation)\n", pa);
      }
    }
    if (!(MMU_NOT_ALLOCATE_CACHE ||
          (instruction ? mmuNotAllocateCode : mmuNotAllocateData))) {
      //アドレス変換キャッシュを更新する
      //  同じ論理ページアドレスのエントリが存在する場合
      //    (リードでアロケートしたとき修正済みでなかったためライトでアロケートしなかった場合)
      //    同じ論理ページアドレスのエントリよりも前にあるエントリを後ろにずらす
      //    空いた先頭のエントリに上書きする
      //  同じ論理ページアドレスのエントリが存在しない場合
      //    末尾以外のエントリを後ろにずらす
      //    空いた先頭のエントリに上書きする
      int[] cache = (supervisor ?
                     instruction ? mmuSuperCodeCache : mmuSuperDataCache :
                     instruction ? mmuUserCodeCache : mmuUserDataCache);
      int head = (logicalPage * MMU_HASH_COEFF >>> -MMU_HASH_BITS) * (4 * MMU_CACHE_WAYS);  //先頭のエントリ
      if (MMU_CACHE_WAYS >= 2) {  //2ways以上のとき
        int tail = head + (4 * MMU_CACHE_WAYS - 4);  //末尾のエントリ→捨てるエントリ
        if (write) {  //ライトのとき
          for (int i = head; i < tail; i += 4) {
            if (cache[i] == logicalPage) {  //リードでアロケートされていた
              tail = i;
              break;
            }
          }
        }
        //  捨てるエントリよりも前にあるエントリを後ろにずらす
        for (; tail > head; tail -= 4) {
          cache[tail    ] = cache[tail - 4];
          cache[tail + 1] = cache[tail - 3];
          cache[tail + 2] = cache[tail - 2];
          cache[tail + 3] = cache[tail - 1];
        }
      }
      //  先頭のエントリに上書きする
      cache[head    ] = logicalPage;  //リード用の論理ページアドレス
      cache[head + 1] = logicalWrite;  //ライト用の論理ページアドレス
      cache[head + 2] = physicalPage;  //物理ページアドレス
      cache[head + 3] = globalFlag;  //グローバルフラグ
      if (MMU_DEBUG_TRANSLATION) {
        System.out.printf ("  ATC[%d]={0x%08x,0x%08x,0x%08x,%d}\n",
                           head / (4 * MMU_CACHE_WAYS), logicalPage, logicalWrite, physicalPage, globalFlag);
      }
    }
    return pa;
  }  //mmuTranslateCommon(int,boolean,boolean,boolean)

  public static int mmuPeekFlags;

  //pa = mmuTranslatePeek (a, supervisor, instruction) {
  //  アドレス変換を行う(デバッガ用、例外なし、テーブル更新なし)
  //    pa           物理アドレス。a^1=エラー
  //    a            論理アドレス
  //    supervisor   0=ユーザ,0以外=スーパーバイザ。通常はXEiJ.regSRS、PLPAR/PLPAWではXEiJ.mpuDFC&4
  //    instruction  0=データ,0以外=命令。通常は命令フェッチまたは拡張ワードのとき1、PLPAR/PLPAWではXEiJ.mpuDFC&2
  public static int mmuTranslatePeek (int a, int supervisor, int instruction) {
    //透過変換の確認
    //  透過変換はスーパーバイザモードかどうかを条件にすることができる(しないこともできる)
    //  透過変換にスーパーバイザプロテクトの機能はない
    {
      int[] tta = new int[2];
      if (instruction != 0) {
        tta[0] = mmuITT0;
        tta[1] = mmuITT1;
      } else {
        tta[0] = mmuDTT0;
        tta[1] = mmuDTT1;
      }
      for (int i = 0; i < 2; i++) {
        int ttr = tta[i];
        if ((ttr & 0x8000) != 0 &&  //Enable
            ((ttr & 0x4000) != 0 || ((ttr & 0x2000) != 0) == (supervisor != 0)) &&
            ((a ^ ttr) & ~ttr << 8) >>> 24 == 0) {
          mmuPeekFlags = ttr & MMU_TTR_WRITE_PROTECT;
          return a;
        }
      }
    }
    //透過変換なし
    if (!mmuEnabled) {  //アドレス変換なし
      mmuPeekFlags = 0;
      return a;
    }
    //アドレス変換あり
    int logicalPage = a & mmuPageAddressMask;  //論理ページアドレス
    //テーブルサーチ開始
    //  スーパーバイザプロテクトまたはライトプロテクトで停止したときディスクリプタの使用済みフラグはセットされない
    //  リードモディファイライトはライトでアロケートするのでリードする前にライトプロテクトに引っかかる
    //    例えばROMの内容をインクリメントしようとしたときライトだけでなくリードも行われない
    //ルートテーブル
    int rootDescriptorAddress = (supervisor != 0 ? mmuSRP : mmuURP) + ((a & MMU_ROOT_INDEX_MASK) >>> MMU_ROOT_INDEX_BIT0 - 2);  //ルートテーブルディスクリプタのアドレス
    int rootDescriptor = XEiJ.busPlsf (rootDescriptorAddress);  //ルートテーブルディスクリプタ
    if ((rootDescriptor & MMU_DESCRIPTOR_UDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
      return a ^ 1;
    }
    //ポインタテーブル
    int pointerDescriptorAddress = (rootDescriptor & MMU_DESCRIPTOR_POINTER_TABLE_ADDRESS) + ((a & MMU_POINTER_INDEX_MASK) >>> MMU_POINTER_INDEX_BIT0 - 2);  //ポインタテーブルディスクリプタのアドレス
    int pointerDescriptor = XEiJ.busPlsf (pointerDescriptorAddress);  //ポインタテーブルディスクリプタ
    if ((pointerDescriptor & MMU_DESCRIPTOR_UDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
      return a ^ 1;
    }
    //ページテーブル
    int pageDescriptorAddress = (pointerDescriptor & mmuPageTableMask) + ((a & mmuPageIndexMask) >>> mmuPageIndexBit2);  //ページテーブルディスクリプタのアドレス
    int pageDescriptor = XEiJ.busPlsf (pageDescriptorAddress);  //ページテーブルディスクリプタ
    if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
      return a ^ 1;
    }
    if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INDIRECT) {  //ディスクリプタが間接のとき
      pageDescriptorAddress = pageDescriptor & MMU_DESCRIPTOR_INDIRECT_ADDRESS;  //ページテーブルディスクリプタのアドレス
      pageDescriptor = XEiJ.busPlsf (pageDescriptorAddress);  //ページテーブルディスクリプタ
      if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INVALID) {  //ディスクリプタが無効のとき
        return a ^ 1;
      }
      if ((pageDescriptor & MMU_DESCRIPTOR_PDT) == MMU_DESCRIPTOR_TYPE_INDIRECT) {  //ディスクリプタが二重間接のとき
        return a ^ 1;
      }
    }
    if (supervisor == 0 &&  //ユーザモードで
        (pageDescriptor & MMU_DESCRIPTOR_SUPERVISOR_PROTECTED) != 0) {  //スーパーバイザプロテクトされているとき
      return a ^ 1;
    }
    int physicalPage = pageDescriptor & mmuPageAddressMask;  //物理ページアドレス
    //テーブルサーチ終了
    mmuPeekFlags = pageDescriptor & (MMU_DESCRIPTOR_SUPERVISOR_PROTECTED |
                                     MMU_DESCRIPTOR_MODIFIED |
                                     MMU_DESCRIPTOR_USED |
                                     MMU_DESCRIPTOR_WRITE_PROTECTED);
    return physicalPage | a & mmuPageOffsetMask;  //物理ページアドレスとページオフセットを連結する
  }  //mmuTranslatePeek(int,int,int)



}  //class MC68060



